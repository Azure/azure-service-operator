// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101storage

import (
	"fmt"
	v20201101s "github.com/Azure/azure-service-operator/v2/api/network/v1beta20201101storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Storage version of v1alpha1api20201101.NetworkInterface
// Deprecated version of NetworkInterface. Use v1beta20201101.NetworkInterface instead
type NetworkInterface struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              NetworkInterface_Spec                                        `json:"spec,omitempty"`
	Status            NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded `json:"status,omitempty"`
}

var _ conditions.Conditioner = &NetworkInterface{}

// GetConditions returns the conditions of the resource
func (networkInterface *NetworkInterface) GetConditions() conditions.Conditions {
	return networkInterface.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (networkInterface *NetworkInterface) SetConditions(conditions conditions.Conditions) {
	networkInterface.Status.Conditions = conditions
}

var _ conversion.Convertible = &NetworkInterface{}

// ConvertFrom populates our NetworkInterface from the provided hub NetworkInterface
func (networkInterface *NetworkInterface) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20201101s.NetworkInterface)
	if !ok {
		return fmt.Errorf("expected network/v1beta20201101storage/NetworkInterface but received %T instead", hub)
	}

	return networkInterface.AssignPropertiesFromNetworkInterface(source)
}

// ConvertTo populates the provided hub NetworkInterface from our NetworkInterface
func (networkInterface *NetworkInterface) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20201101s.NetworkInterface)
	if !ok {
		return fmt.Errorf("expected network/v1beta20201101storage/NetworkInterface but received %T instead", hub)
	}

	return networkInterface.AssignPropertiesToNetworkInterface(destination)
}

var _ genruntime.KubernetesResource = &NetworkInterface{}

// AzureName returns the Azure name of the resource
func (networkInterface *NetworkInterface) AzureName() string {
	return networkInterface.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2020-11-01"
func (networkInterface NetworkInterface) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceKind returns the kind of the resource
func (networkInterface *NetworkInterface) GetResourceKind() genruntime.ResourceKind {
	return genruntime.ResourceKindNormal
}

// GetSpec returns the specification of this resource
func (networkInterface *NetworkInterface) GetSpec() genruntime.ConvertibleSpec {
	return &networkInterface.Spec
}

// GetStatus returns the status of this resource
func (networkInterface *NetworkInterface) GetStatus() genruntime.ConvertibleStatus {
	return &networkInterface.Status
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Network/networkInterfaces"
func (networkInterface *NetworkInterface) GetType() string {
	return "Microsoft.Network/networkInterfaces"
}

// NewEmptyStatus returns a new empty (blank) status
func (networkInterface *NetworkInterface) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded{}
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (networkInterface *NetworkInterface) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(networkInterface.Spec)
	return &genruntime.ResourceReference{
		Group: group,
		Kind:  kind,
		Name:  networkInterface.Spec.Owner.Name,
	}
}

// SetStatus sets the status of this resource
func (networkInterface *NetworkInterface) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded); ok {
		networkInterface.Status = *st
		return nil
	}

	// Convert status to required version
	var st NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	networkInterface.Status = st
	return nil
}

// AssignPropertiesFromNetworkInterface populates our NetworkInterface from the provided source NetworkInterface
func (networkInterface *NetworkInterface) AssignPropertiesFromNetworkInterface(source *v20201101s.NetworkInterface) error {

	// ObjectMeta
	networkInterface.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec NetworkInterface_Spec
	err := spec.AssignPropertiesFromNetworkInterface_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromNetworkInterface_Spec() to populate field Spec")
	}
	networkInterface.Spec = spec

	// Status
	var status NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded
	err = status.AssignPropertiesFromNetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromNetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded() to populate field Status")
	}
	networkInterface.Status = status

	// No error
	return nil
}

// AssignPropertiesToNetworkInterface populates the provided destination NetworkInterface from our NetworkInterface
func (networkInterface *NetworkInterface) AssignPropertiesToNetworkInterface(destination *v20201101s.NetworkInterface) error {

	// ObjectMeta
	destination.ObjectMeta = *networkInterface.ObjectMeta.DeepCopy()

	// Spec
	var spec v20201101s.NetworkInterface_Spec
	err := networkInterface.Spec.AssignPropertiesToNetworkInterface_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToNetworkInterface_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20201101s.NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded
	err = networkInterface.Status.AssignPropertiesToNetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToNetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (networkInterface *NetworkInterface) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: networkInterface.Spec.OriginalVersion,
		Kind:    "NetworkInterface",
	}
}

// +kubebuilder:object:root=true
// Storage version of v1alpha1api20201101.NetworkInterface
// Deprecated version of NetworkInterface. Use v1beta20201101.NetworkInterface instead
type NetworkInterfaceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []NetworkInterface `json:"items"`
}

// Storage version of v1alpha1api20201101.NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded
// Deprecated version of NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded. Use v1beta20201101.NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded instead
type NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded struct {
	Conditions                  []conditions.Condition                                                         `json:"conditions,omitempty"`
	DnsSettings                 *NetworkInterfaceDnsSettings_STATUS                                            `json:"dnsSettings,omitempty"`
	DscpConfiguration           *SubResource_STATUS                                                            `json:"dscpConfiguration,omitempty"`
	EnableAcceleratedNetworking *bool                                                                          `json:"enableAcceleratedNetworking,omitempty"`
	EnableIPForwarding          *bool                                                                          `json:"enableIPForwarding,omitempty"`
	Etag                        *string                                                                        `json:"etag,omitempty"`
	ExtendedLocation            *ExtendedLocation_STATUS                                                       `json:"extendedLocation,omitempty"`
	HostedWorkloads             []string                                                                       `json:"hostedWorkloads,omitempty"`
	Id                          *string                                                                        `json:"id,omitempty"`
	IpConfigurations            []NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded  `json:"ipConfigurations,omitempty"`
	Location                    *string                                                                        `json:"location,omitempty"`
	MacAddress                  *string                                                                        `json:"macAddress,omitempty"`
	MigrationPhase              *string                                                                        `json:"migrationPhase,omitempty"`
	Name                        *string                                                                        `json:"name,omitempty"`
	NetworkSecurityGroup        *NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded              `json:"networkSecurityGroup,omitempty"`
	NicType                     *string                                                                        `json:"nicType,omitempty"`
	Primary                     *bool                                                                          `json:"primary,omitempty"`
	PrivateEndpoint             *PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded                   `json:"privateEndpoint,omitempty"`
	PrivateLinkService          *PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded                `json:"privateLinkService,omitempty"`
	PropertyBag                 genruntime.PropertyBag                                                         `json:"$propertyBag,omitempty"`
	ProvisioningState           *string                                                                        `json:"provisioningState,omitempty"`
	ResourceGuid                *string                                                                        `json:"resourceGuid,omitempty"`
	Tags                        map[string]string                                                              `json:"tags,omitempty"`
	TapConfigurations           []NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded `json:"tapConfigurations,omitempty"`
	Type                        *string                                                                        `json:"type,omitempty"`
	VirtualMachine              *SubResource_STATUS                                                            `json:"virtualMachine,omitempty"`
}

var _ genruntime.ConvertibleStatus = &NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded{}

// ConvertStatusFrom populates our NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded from the provided source
func (embedded *NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20201101s.NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded)
	if ok {
		// Populate our instance from source
		return embedded.AssignPropertiesFromNetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded(src)
	}

	// Convert to an intermediate form
	src = &v20201101s.NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = embedded.AssignPropertiesFromNetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20201101s.NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded)
	if ok {
		// Populate destination from our instance
		return embedded.AssignPropertiesToNetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded(dst)
	}

	// Convert to an intermediate form
	dst = &v20201101s.NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded{}
	err := embedded.AssignPropertiesToNetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

// AssignPropertiesFromNetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded populates our NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded from the provided source NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromNetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded(source *v20201101s.NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Conditions
	embedded.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting NetworkInterfaceDnsSettings_STATUS
		err := dnsSetting.AssignPropertiesFromNetworkInterfaceDnsSettings_STATUS(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromNetworkInterfaceDnsSettings_STATUS() to populate field DnsSettings")
		}
		embedded.DnsSettings = &dnsSetting
	} else {
		embedded.DnsSettings = nil
	}

	// DscpConfiguration
	if source.DscpConfiguration != nil {
		var dscpConfiguration SubResource_STATUS
		err := dscpConfiguration.AssignPropertiesFromSubResource_STATUS(source.DscpConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource_STATUS() to populate field DscpConfiguration")
		}
		embedded.DscpConfiguration = &dscpConfiguration
	} else {
		embedded.DscpConfiguration = nil
	}

	// EnableAcceleratedNetworking
	if source.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *source.EnableAcceleratedNetworking
		embedded.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		embedded.EnableAcceleratedNetworking = nil
	}

	// EnableIPForwarding
	if source.EnableIPForwarding != nil {
		enableIPForwarding := *source.EnableIPForwarding
		embedded.EnableIPForwarding = &enableIPForwarding
	} else {
		embedded.EnableIPForwarding = nil
	}

	// Etag
	embedded.Etag = genruntime.ClonePointerToString(source.Etag)

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_STATUS
		err := extendedLocation.AssignPropertiesFromExtendedLocation_STATUS(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		embedded.ExtendedLocation = &extendedLocation
	} else {
		embedded.ExtendedLocation = nil
	}

	// HostedWorkloads
	embedded.HostedWorkloads = genruntime.CloneSliceOfString(source.HostedWorkloads)

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// IpConfigurations
	if source.IpConfigurations != nil {
		ipConfigurationList := make([]NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded, len(source.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded
			err := ipConfiguration.AssignPropertiesFromNetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded(&ipConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromNetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		embedded.IpConfigurations = ipConfigurationList
	} else {
		embedded.IpConfigurations = nil
	}

	// Location
	embedded.Location = genruntime.ClonePointerToString(source.Location)

	// MacAddress
	embedded.MacAddress = genruntime.ClonePointerToString(source.MacAddress)

	// MigrationPhase
	embedded.MigrationPhase = genruntime.ClonePointerToString(source.MigrationPhase)

	// Name
	embedded.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkSecurityGroup
	if source.NetworkSecurityGroup != nil {
		var networkSecurityGroup NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded
		err := networkSecurityGroup.AssignPropertiesFromNetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded(source.NetworkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromNetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded() to populate field NetworkSecurityGroup")
		}
		embedded.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		embedded.NetworkSecurityGroup = nil
	}

	// NicType
	embedded.NicType = genruntime.ClonePointerToString(source.NicType)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		embedded.Primary = &primary
	} else {
		embedded.Primary = nil
	}

	// PrivateEndpoint
	if source.PrivateEndpoint != nil {
		var privateEndpoint PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded
		err := privateEndpoint.AssignPropertiesFromPrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded(source.PrivateEndpoint)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded() to populate field PrivateEndpoint")
		}
		embedded.PrivateEndpoint = &privateEndpoint
	} else {
		embedded.PrivateEndpoint = nil
	}

	// PrivateLinkService
	if source.PrivateLinkService != nil {
		var privateLinkService PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded
		err := privateLinkService.AssignPropertiesFromPrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded(source.PrivateLinkService)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded() to populate field PrivateLinkService")
		}
		embedded.PrivateLinkService = &privateLinkService
	} else {
		embedded.PrivateLinkService = nil
	}

	// ProvisioningState
	embedded.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// ResourceGuid
	embedded.ResourceGuid = genruntime.ClonePointerToString(source.ResourceGuid)

	// Tags
	embedded.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TapConfigurations
	if source.TapConfigurations != nil {
		tapConfigurationList := make([]NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded, len(source.TapConfigurations))
		for tapConfigurationIndex, tapConfigurationItem := range source.TapConfigurations {
			// Shadow the loop variable to avoid aliasing
			tapConfigurationItem := tapConfigurationItem
			var tapConfiguration NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded
			err := tapConfiguration.AssignPropertiesFromNetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded(&tapConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromNetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded() to populate field TapConfigurations")
			}
			tapConfigurationList[tapConfigurationIndex] = tapConfiguration
		}
		embedded.TapConfigurations = tapConfigurationList
	} else {
		embedded.TapConfigurations = nil
	}

	// Type
	embedded.Type = genruntime.ClonePointerToString(source.Type)

	// VirtualMachine
	if source.VirtualMachine != nil {
		var virtualMachine SubResource_STATUS
		err := virtualMachine.AssignPropertiesFromSubResource_STATUS(source.VirtualMachine)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource_STATUS() to populate field VirtualMachine")
		}
		embedded.VirtualMachine = &virtualMachine
	} else {
		embedded.VirtualMachine = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToNetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded populates the provided destination NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded from our NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded) AssignPropertiesToNetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded(destination *v20201101s.NetworkInterface_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(embedded.Conditions)

	// DnsSettings
	if embedded.DnsSettings != nil {
		var dnsSetting v20201101s.NetworkInterfaceDnsSettings_STATUS
		err := embedded.DnsSettings.AssignPropertiesToNetworkInterfaceDnsSettings_STATUS(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToNetworkInterfaceDnsSettings_STATUS() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// DscpConfiguration
	if embedded.DscpConfiguration != nil {
		var dscpConfiguration v20201101s.SubResource_STATUS
		err := embedded.DscpConfiguration.AssignPropertiesToSubResource_STATUS(&dscpConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource_STATUS() to populate field DscpConfiguration")
		}
		destination.DscpConfiguration = &dscpConfiguration
	} else {
		destination.DscpConfiguration = nil
	}

	// EnableAcceleratedNetworking
	if embedded.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *embedded.EnableAcceleratedNetworking
		destination.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		destination.EnableAcceleratedNetworking = nil
	}

	// EnableIPForwarding
	if embedded.EnableIPForwarding != nil {
		enableIPForwarding := *embedded.EnableIPForwarding
		destination.EnableIPForwarding = &enableIPForwarding
	} else {
		destination.EnableIPForwarding = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(embedded.Etag)

	// ExtendedLocation
	if embedded.ExtendedLocation != nil {
		var extendedLocation v20201101s.ExtendedLocation_STATUS
		err := embedded.ExtendedLocation.AssignPropertiesToExtendedLocation_STATUS(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// HostedWorkloads
	destination.HostedWorkloads = genruntime.CloneSliceOfString(embedded.HostedWorkloads)

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// IpConfigurations
	if embedded.IpConfigurations != nil {
		ipConfigurationList := make([]v20201101s.NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded, len(embedded.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range embedded.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration v20201101s.NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded
			err := ipConfigurationItem.AssignPropertiesToNetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded(&ipConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToNetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		destination.IpConfigurations = ipConfigurationList
	} else {
		destination.IpConfigurations = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(embedded.Location)

	// MacAddress
	destination.MacAddress = genruntime.ClonePointerToString(embedded.MacAddress)

	// MigrationPhase
	destination.MigrationPhase = genruntime.ClonePointerToString(embedded.MigrationPhase)

	// Name
	destination.Name = genruntime.ClonePointerToString(embedded.Name)

	// NetworkSecurityGroup
	if embedded.NetworkSecurityGroup != nil {
		var networkSecurityGroup v20201101s.NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded
		err := embedded.NetworkSecurityGroup.AssignPropertiesToNetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded(&networkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToNetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded() to populate field NetworkSecurityGroup")
		}
		destination.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		destination.NetworkSecurityGroup = nil
	}

	// NicType
	destination.NicType = genruntime.ClonePointerToString(embedded.NicType)

	// Primary
	if embedded.Primary != nil {
		primary := *embedded.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// PrivateEndpoint
	if embedded.PrivateEndpoint != nil {
		var privateEndpoint v20201101s.PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded
		err := embedded.PrivateEndpoint.AssignPropertiesToPrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded(&privateEndpoint)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded() to populate field PrivateEndpoint")
		}
		destination.PrivateEndpoint = &privateEndpoint
	} else {
		destination.PrivateEndpoint = nil
	}

	// PrivateLinkService
	if embedded.PrivateLinkService != nil {
		var privateLinkService v20201101s.PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded
		err := embedded.PrivateLinkService.AssignPropertiesToPrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded(&privateLinkService)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded() to populate field PrivateLinkService")
		}
		destination.PrivateLinkService = &privateLinkService
	} else {
		destination.PrivateLinkService = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(embedded.ProvisioningState)

	// ResourceGuid
	destination.ResourceGuid = genruntime.ClonePointerToString(embedded.ResourceGuid)

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(embedded.Tags)

	// TapConfigurations
	if embedded.TapConfigurations != nil {
		tapConfigurationList := make([]v20201101s.NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded, len(embedded.TapConfigurations))
		for tapConfigurationIndex, tapConfigurationItem := range embedded.TapConfigurations {
			// Shadow the loop variable to avoid aliasing
			tapConfigurationItem := tapConfigurationItem
			var tapConfiguration v20201101s.NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded
			err := tapConfigurationItem.AssignPropertiesToNetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded(&tapConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToNetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded() to populate field TapConfigurations")
			}
			tapConfigurationList[tapConfigurationIndex] = tapConfiguration
		}
		destination.TapConfigurations = tapConfigurationList
	} else {
		destination.TapConfigurations = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(embedded.Type)

	// VirtualMachine
	if embedded.VirtualMachine != nil {
		var virtualMachine v20201101s.SubResource_STATUS
		err := embedded.VirtualMachine.AssignPropertiesToSubResource_STATUS(&virtualMachine)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource_STATUS() to populate field VirtualMachine")
		}
		destination.VirtualMachine = &virtualMachine
	} else {
		destination.VirtualMachine = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.NetworkInterface_Spec
type NetworkInterface_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName                   string                                                                 `json:"azureName,omitempty"`
	DnsSettings                 *NetworkInterfaceDnsSettings                                           `json:"dnsSettings,omitempty"`
	EnableAcceleratedNetworking *bool                                                                  `json:"enableAcceleratedNetworking,omitempty"`
	EnableIPForwarding          *bool                                                                  `json:"enableIPForwarding,omitempty"`
	ExtendedLocation            *ExtendedLocation                                                      `json:"extendedLocation,omitempty"`
	IpConfigurations            []NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded `json:"ipConfigurations,omitempty"`
	Location                    *string                                                                `json:"location,omitempty"`
	MigrationPhase              *string                                                                `json:"migrationPhase,omitempty"`
	NetworkSecurityGroup        *NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded         `json:"networkSecurityGroup,omitempty"`
	NicType                     *string                                                                `json:"nicType,omitempty"`
	OriginalVersion             string                                                                 `json:"originalVersion,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner              *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`
	PrivateLinkService *PrivateLinkServiceSpec            `json:"privateLinkService,omitempty"`
	PropertyBag        genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
	Reference          *genruntime.ResourceReference      `armReference:"Id" json:"reference,omitempty"`
	Tags               map[string]string                  `json:"tags,omitempty"`
}

var _ genruntime.ConvertibleSpec = &NetworkInterface_Spec{}

// ConvertSpecFrom populates our NetworkInterface_Spec from the provided source
func (networkInterface *NetworkInterface_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20201101s.NetworkInterface_Spec)
	if ok {
		// Populate our instance from source
		return networkInterface.AssignPropertiesFromNetworkInterface_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20201101s.NetworkInterface_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = networkInterface.AssignPropertiesFromNetworkInterface_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our NetworkInterface_Spec
func (networkInterface *NetworkInterface_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20201101s.NetworkInterface_Spec)
	if ok {
		// Populate destination from our instance
		return networkInterface.AssignPropertiesToNetworkInterface_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20201101s.NetworkInterface_Spec{}
	err := networkInterface.AssignPropertiesToNetworkInterface_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignPropertiesFromNetworkInterface_Spec populates our NetworkInterface_Spec from the provided source NetworkInterface_Spec
func (networkInterface *NetworkInterface_Spec) AssignPropertiesFromNetworkInterface_Spec(source *v20201101s.NetworkInterface_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AzureName
	networkInterface.AzureName = source.AzureName

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting NetworkInterfaceDnsSettings
		err := dnsSetting.AssignPropertiesFromNetworkInterfaceDnsSettings(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromNetworkInterfaceDnsSettings() to populate field DnsSettings")
		}
		networkInterface.DnsSettings = &dnsSetting
	} else {
		networkInterface.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if source.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *source.EnableAcceleratedNetworking
		networkInterface.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		networkInterface.EnableAcceleratedNetworking = nil
	}

	// EnableIPForwarding
	if source.EnableIPForwarding != nil {
		enableIPForwarding := *source.EnableIPForwarding
		networkInterface.EnableIPForwarding = &enableIPForwarding
	} else {
		networkInterface.EnableIPForwarding = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation
		err := extendedLocation.AssignPropertiesFromExtendedLocation(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocation() to populate field ExtendedLocation")
		}
		networkInterface.ExtendedLocation = &extendedLocation
	} else {
		networkInterface.ExtendedLocation = nil
	}

	// IpConfigurations
	if source.IpConfigurations != nil {
		ipConfigurationList := make([]NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded, len(source.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded
			err := ipConfiguration.AssignPropertiesFromNetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded(&ipConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromNetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		networkInterface.IpConfigurations = ipConfigurationList
	} else {
		networkInterface.IpConfigurations = nil
	}

	// Location
	networkInterface.Location = genruntime.ClonePointerToString(source.Location)

	// MigrationPhase
	networkInterface.MigrationPhase = genruntime.ClonePointerToString(source.MigrationPhase)

	// NetworkSecurityGroup
	if source.NetworkSecurityGroup != nil {
		var networkSecurityGroup NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded
		err := networkSecurityGroup.AssignPropertiesFromNetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded(source.NetworkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromNetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded() to populate field NetworkSecurityGroup")
		}
		networkInterface.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		networkInterface.NetworkSecurityGroup = nil
	}

	// NicType
	networkInterface.NicType = genruntime.ClonePointerToString(source.NicType)

	// OriginalVersion
	networkInterface.OriginalVersion = source.OriginalVersion

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		networkInterface.Owner = &owner
	} else {
		networkInterface.Owner = nil
	}

	// PrivateLinkService
	if source.PrivateLinkService != nil {
		var privateLinkService PrivateLinkServiceSpec
		err := privateLinkService.AssignPropertiesFromPrivateLinkServiceSpec(source.PrivateLinkService)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPrivateLinkServiceSpec() to populate field PrivateLinkService")
		}
		networkInterface.PrivateLinkService = &privateLinkService
	} else {
		networkInterface.PrivateLinkService = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		networkInterface.Reference = &reference
	} else {
		networkInterface.Reference = nil
	}

	// Tags
	networkInterface.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		networkInterface.PropertyBag = propertyBag
	} else {
		networkInterface.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToNetworkInterface_Spec populates the provided destination NetworkInterface_Spec from our NetworkInterface_Spec
func (networkInterface *NetworkInterface_Spec) AssignPropertiesToNetworkInterface_Spec(destination *v20201101s.NetworkInterface_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(networkInterface.PropertyBag)

	// AzureName
	destination.AzureName = networkInterface.AzureName

	// DnsSettings
	if networkInterface.DnsSettings != nil {
		var dnsSetting v20201101s.NetworkInterfaceDnsSettings
		err := networkInterface.DnsSettings.AssignPropertiesToNetworkInterfaceDnsSettings(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToNetworkInterfaceDnsSettings() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if networkInterface.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *networkInterface.EnableAcceleratedNetworking
		destination.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		destination.EnableAcceleratedNetworking = nil
	}

	// EnableIPForwarding
	if networkInterface.EnableIPForwarding != nil {
		enableIPForwarding := *networkInterface.EnableIPForwarding
		destination.EnableIPForwarding = &enableIPForwarding
	} else {
		destination.EnableIPForwarding = nil
	}

	// ExtendedLocation
	if networkInterface.ExtendedLocation != nil {
		var extendedLocation v20201101s.ExtendedLocation
		err := networkInterface.ExtendedLocation.AssignPropertiesToExtendedLocation(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocation() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// IpConfigurations
	if networkInterface.IpConfigurations != nil {
		ipConfigurationList := make([]v20201101s.NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded, len(networkInterface.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range networkInterface.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration v20201101s.NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded
			err := ipConfigurationItem.AssignPropertiesToNetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded(&ipConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToNetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		destination.IpConfigurations = ipConfigurationList
	} else {
		destination.IpConfigurations = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(networkInterface.Location)

	// MigrationPhase
	destination.MigrationPhase = genruntime.ClonePointerToString(networkInterface.MigrationPhase)

	// NetworkSecurityGroup
	if networkInterface.NetworkSecurityGroup != nil {
		var networkSecurityGroup v20201101s.NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded
		err := networkInterface.NetworkSecurityGroup.AssignPropertiesToNetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded(&networkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToNetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded() to populate field NetworkSecurityGroup")
		}
		destination.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		destination.NetworkSecurityGroup = nil
	}

	// NicType
	destination.NicType = genruntime.ClonePointerToString(networkInterface.NicType)

	// OriginalVersion
	destination.OriginalVersion = networkInterface.OriginalVersion

	// Owner
	if networkInterface.Owner != nil {
		owner := networkInterface.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// PrivateLinkService
	if networkInterface.PrivateLinkService != nil {
		var privateLinkService v20201101s.PrivateLinkServiceSpec
		err := networkInterface.PrivateLinkService.AssignPropertiesToPrivateLinkServiceSpec(&privateLinkService)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPrivateLinkServiceSpec() to populate field PrivateLinkService")
		}
		destination.PrivateLinkService = &privateLinkService
	} else {
		destination.PrivateLinkService = nil
	}

	// Reference
	if networkInterface.Reference != nil {
		reference := networkInterface.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(networkInterface.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.NetworkInterfaceDnsSettings
// Deprecated version of NetworkInterfaceDnsSettings. Use v1beta20201101.NetworkInterfaceDnsSettings instead
type NetworkInterfaceDnsSettings struct {
	DnsServers           []string               `json:"dnsServers,omitempty"`
	InternalDnsNameLabel *string                `json:"internalDnsNameLabel,omitempty"`
	PropertyBag          genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromNetworkInterfaceDnsSettings populates our NetworkInterfaceDnsSettings from the provided source NetworkInterfaceDnsSettings
func (settings *NetworkInterfaceDnsSettings) AssignPropertiesFromNetworkInterfaceDnsSettings(source *v20201101s.NetworkInterfaceDnsSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DnsServers
	settings.DnsServers = genruntime.CloneSliceOfString(source.DnsServers)

	// InternalDnsNameLabel
	settings.InternalDnsNameLabel = genruntime.ClonePointerToString(source.InternalDnsNameLabel)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToNetworkInterfaceDnsSettings populates the provided destination NetworkInterfaceDnsSettings from our NetworkInterfaceDnsSettings
func (settings *NetworkInterfaceDnsSettings) AssignPropertiesToNetworkInterfaceDnsSettings(destination *v20201101s.NetworkInterfaceDnsSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// DnsServers
	destination.DnsServers = genruntime.CloneSliceOfString(settings.DnsServers)

	// InternalDnsNameLabel
	destination.InternalDnsNameLabel = genruntime.ClonePointerToString(settings.InternalDnsNameLabel)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.NetworkInterfaceDnsSettings_STATUS
// Deprecated version of NetworkInterfaceDnsSettings_STATUS. Use v1beta20201101.NetworkInterfaceDnsSettings_STATUS instead
type NetworkInterfaceDnsSettings_STATUS struct {
	AppliedDnsServers        []string               `json:"appliedDnsServers,omitempty"`
	DnsServers               []string               `json:"dnsServers,omitempty"`
	InternalDnsNameLabel     *string                `json:"internalDnsNameLabel,omitempty"`
	InternalDomainNameSuffix *string                `json:"internalDomainNameSuffix,omitempty"`
	InternalFqdn             *string                `json:"internalFqdn,omitempty"`
	PropertyBag              genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromNetworkInterfaceDnsSettings_STATUS populates our NetworkInterfaceDnsSettings_STATUS from the provided source NetworkInterfaceDnsSettings_STATUS
func (settings *NetworkInterfaceDnsSettings_STATUS) AssignPropertiesFromNetworkInterfaceDnsSettings_STATUS(source *v20201101s.NetworkInterfaceDnsSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AppliedDnsServers
	settings.AppliedDnsServers = genruntime.CloneSliceOfString(source.AppliedDnsServers)

	// DnsServers
	settings.DnsServers = genruntime.CloneSliceOfString(source.DnsServers)

	// InternalDnsNameLabel
	settings.InternalDnsNameLabel = genruntime.ClonePointerToString(source.InternalDnsNameLabel)

	// InternalDomainNameSuffix
	settings.InternalDomainNameSuffix = genruntime.ClonePointerToString(source.InternalDomainNameSuffix)

	// InternalFqdn
	settings.InternalFqdn = genruntime.ClonePointerToString(source.InternalFqdn)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToNetworkInterfaceDnsSettings_STATUS populates the provided destination NetworkInterfaceDnsSettings_STATUS from our NetworkInterfaceDnsSettings_STATUS
func (settings *NetworkInterfaceDnsSettings_STATUS) AssignPropertiesToNetworkInterfaceDnsSettings_STATUS(destination *v20201101s.NetworkInterfaceDnsSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// AppliedDnsServers
	destination.AppliedDnsServers = genruntime.CloneSliceOfString(settings.AppliedDnsServers)

	// DnsServers
	destination.DnsServers = genruntime.CloneSliceOfString(settings.DnsServers)

	// InternalDnsNameLabel
	destination.InternalDnsNameLabel = genruntime.ClonePointerToString(settings.InternalDnsNameLabel)

	// InternalDomainNameSuffix
	destination.InternalDomainNameSuffix = genruntime.ClonePointerToString(settings.InternalDomainNameSuffix)

	// InternalFqdn
	destination.InternalFqdn = genruntime.ClonePointerToString(settings.InternalFqdn)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded
// Deprecated version of NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded. Use v1beta20201101.NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded instead
type NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded struct {
	ApplicationGatewayBackendAddressPools []ApplicationGatewayBackendAddressPool                       `json:"applicationGatewayBackendAddressPools,omitempty"`
	ApplicationSecurityGroups             []ApplicationSecurityGroupSpec                               `json:"applicationSecurityGroups,omitempty"`
	LoadBalancerBackendAddressPools       []BackendAddressPool_NetworkInterface_SubResourceEmbedded    `json:"loadBalancerBackendAddressPools,omitempty"`
	LoadBalancerInboundNatRules           []InboundNatRule_NetworkInterface_SubResourceEmbedded        `json:"loadBalancerInboundNatRules,omitempty"`
	Name                                  *string                                                      `json:"name,omitempty"`
	Primary                               *bool                                                        `json:"primary,omitempty"`
	PrivateIPAddress                      *string                                                      `json:"privateIPAddress,omitempty"`
	PrivateIPAddressVersion               *string                                                      `json:"privateIPAddressVersion,omitempty"`
	PrivateIPAllocationMethod             *string                                                      `json:"privateIPAllocationMethod,omitempty"`
	PropertyBag                           genruntime.PropertyBag                                       `json:"$propertyBag,omitempty"`
	PublicIPAddress                       *PublicIPAddressSpec                                         `json:"publicIPAddress,omitempty"`
	Reference                             *genruntime.ResourceReference                                `armReference:"Id" json:"reference,omitempty"`
	Subnet                                *Subnet_NetworkInterface_SubResourceEmbedded                 `json:"subnet,omitempty"`
	Type                                  *string                                                      `json:"type,omitempty"`
	VirtualNetworkTaps                    []VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded `json:"virtualNetworkTaps,omitempty"`
}

// AssignPropertiesFromNetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded populates our NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded from the provided source NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromNetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded(source *v20201101s.NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ApplicationGatewayBackendAddressPools
	if source.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]ApplicationGatewayBackendAddressPool, len(source.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range source.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool ApplicationGatewayBackendAddressPool
			err := applicationGatewayBackendAddressPool.AssignPropertiesFromApplicationGatewayBackendAddressPool(&applicationGatewayBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromApplicationGatewayBackendAddressPool() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		embedded.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		embedded.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if source.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]ApplicationSecurityGroupSpec, len(source.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range source.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup ApplicationSecurityGroupSpec
			err := applicationSecurityGroup.AssignPropertiesFromApplicationSecurityGroupSpec(&applicationSecurityGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromApplicationSecurityGroupSpec() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		embedded.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		embedded.ApplicationSecurityGroups = nil
	}

	// LoadBalancerBackendAddressPools
	if source.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]BackendAddressPool_NetworkInterface_SubResourceEmbedded, len(source.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range source.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool BackendAddressPool_NetworkInterface_SubResourceEmbedded
			err := loadBalancerBackendAddressPool.AssignPropertiesFromBackendAddressPool_NetworkInterface_SubResourceEmbedded(&loadBalancerBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromBackendAddressPool_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		embedded.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		embedded.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatRules
	if source.LoadBalancerInboundNatRules != nil {
		loadBalancerInboundNatRuleList := make([]InboundNatRule_NetworkInterface_SubResourceEmbedded, len(source.LoadBalancerInboundNatRules))
		for loadBalancerInboundNatRuleIndex, loadBalancerInboundNatRuleItem := range source.LoadBalancerInboundNatRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatRuleItem := loadBalancerInboundNatRuleItem
			var loadBalancerInboundNatRule InboundNatRule_NetworkInterface_SubResourceEmbedded
			err := loadBalancerInboundNatRule.AssignPropertiesFromInboundNatRule_NetworkInterface_SubResourceEmbedded(&loadBalancerInboundNatRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromInboundNatRule_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerInboundNatRules")
			}
			loadBalancerInboundNatRuleList[loadBalancerInboundNatRuleIndex] = loadBalancerInboundNatRule
		}
		embedded.LoadBalancerInboundNatRules = loadBalancerInboundNatRuleList
	} else {
		embedded.LoadBalancerInboundNatRules = nil
	}

	// Name
	embedded.Name = genruntime.ClonePointerToString(source.Name)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		embedded.Primary = &primary
	} else {
		embedded.Primary = nil
	}

	// PrivateIPAddress
	embedded.PrivateIPAddress = genruntime.ClonePointerToString(source.PrivateIPAddress)

	// PrivateIPAddressVersion
	embedded.PrivateIPAddressVersion = genruntime.ClonePointerToString(source.PrivateIPAddressVersion)

	// PrivateIPAllocationMethod
	embedded.PrivateIPAllocationMethod = genruntime.ClonePointerToString(source.PrivateIPAllocationMethod)

	// PublicIPAddress
	if source.PublicIPAddress != nil {
		var publicIPAddress PublicIPAddressSpec
		err := publicIPAddress.AssignPropertiesFromPublicIPAddressSpec(source.PublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPublicIPAddressSpec() to populate field PublicIPAddress")
		}
		embedded.PublicIPAddress = &publicIPAddress
	} else {
		embedded.PublicIPAddress = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet Subnet_NetworkInterface_SubResourceEmbedded
		err := subnet.AssignPropertiesFromSubnet_NetworkInterface_SubResourceEmbedded(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubnet_NetworkInterface_SubResourceEmbedded() to populate field Subnet")
		}
		embedded.Subnet = &subnet
	} else {
		embedded.Subnet = nil
	}

	// Type
	embedded.Type = genruntime.ClonePointerToString(source.Type)

	// VirtualNetworkTaps
	if source.VirtualNetworkTaps != nil {
		virtualNetworkTapList := make([]VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded, len(source.VirtualNetworkTaps))
		for virtualNetworkTapIndex, virtualNetworkTapItem := range source.VirtualNetworkTaps {
			// Shadow the loop variable to avoid aliasing
			virtualNetworkTapItem := virtualNetworkTapItem
			var virtualNetworkTap VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded
			err := virtualNetworkTap.AssignPropertiesFromVirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded(&virtualNetworkTapItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded() to populate field VirtualNetworkTaps")
			}
			virtualNetworkTapList[virtualNetworkTapIndex] = virtualNetworkTap
		}
		embedded.VirtualNetworkTaps = virtualNetworkTapList
	} else {
		embedded.VirtualNetworkTaps = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToNetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded populates the provided destination NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded from our NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded) AssignPropertiesToNetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded(destination *v20201101s.NetworkInterfaceIPConfiguration_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// ApplicationGatewayBackendAddressPools
	if embedded.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]v20201101s.ApplicationGatewayBackendAddressPool, len(embedded.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range embedded.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool v20201101s.ApplicationGatewayBackendAddressPool
			err := applicationGatewayBackendAddressPoolItem.AssignPropertiesToApplicationGatewayBackendAddressPool(&applicationGatewayBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToApplicationGatewayBackendAddressPool() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		destination.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		destination.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if embedded.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]v20201101s.ApplicationSecurityGroupSpec, len(embedded.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range embedded.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup v20201101s.ApplicationSecurityGroupSpec
			err := applicationSecurityGroupItem.AssignPropertiesToApplicationSecurityGroupSpec(&applicationSecurityGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToApplicationSecurityGroupSpec() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		destination.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		destination.ApplicationSecurityGroups = nil
	}

	// LoadBalancerBackendAddressPools
	if embedded.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]v20201101s.BackendAddressPool_NetworkInterface_SubResourceEmbedded, len(embedded.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range embedded.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool v20201101s.BackendAddressPool_NetworkInterface_SubResourceEmbedded
			err := loadBalancerBackendAddressPoolItem.AssignPropertiesToBackendAddressPool_NetworkInterface_SubResourceEmbedded(&loadBalancerBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToBackendAddressPool_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		destination.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		destination.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatRules
	if embedded.LoadBalancerInboundNatRules != nil {
		loadBalancerInboundNatRuleList := make([]v20201101s.InboundNatRule_NetworkInterface_SubResourceEmbedded, len(embedded.LoadBalancerInboundNatRules))
		for loadBalancerInboundNatRuleIndex, loadBalancerInboundNatRuleItem := range embedded.LoadBalancerInboundNatRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatRuleItem := loadBalancerInboundNatRuleItem
			var loadBalancerInboundNatRule v20201101s.InboundNatRule_NetworkInterface_SubResourceEmbedded
			err := loadBalancerInboundNatRuleItem.AssignPropertiesToInboundNatRule_NetworkInterface_SubResourceEmbedded(&loadBalancerInboundNatRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToInboundNatRule_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerInboundNatRules")
			}
			loadBalancerInboundNatRuleList[loadBalancerInboundNatRuleIndex] = loadBalancerInboundNatRule
		}
		destination.LoadBalancerInboundNatRules = loadBalancerInboundNatRuleList
	} else {
		destination.LoadBalancerInboundNatRules = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(embedded.Name)

	// Primary
	if embedded.Primary != nil {
		primary := *embedded.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// PrivateIPAddress
	destination.PrivateIPAddress = genruntime.ClonePointerToString(embedded.PrivateIPAddress)

	// PrivateIPAddressVersion
	destination.PrivateIPAddressVersion = genruntime.ClonePointerToString(embedded.PrivateIPAddressVersion)

	// PrivateIPAllocationMethod
	destination.PrivateIPAllocationMethod = genruntime.ClonePointerToString(embedded.PrivateIPAllocationMethod)

	// PublicIPAddress
	if embedded.PublicIPAddress != nil {
		var publicIPAddress v20201101s.PublicIPAddressSpec
		err := embedded.PublicIPAddress.AssignPropertiesToPublicIPAddressSpec(&publicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPublicIPAddressSpec() to populate field PublicIPAddress")
		}
		destination.PublicIPAddress = &publicIPAddress
	} else {
		destination.PublicIPAddress = nil
	}

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Subnet
	if embedded.Subnet != nil {
		var subnet v20201101s.Subnet_NetworkInterface_SubResourceEmbedded
		err := embedded.Subnet.AssignPropertiesToSubnet_NetworkInterface_SubResourceEmbedded(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubnet_NetworkInterface_SubResourceEmbedded() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(embedded.Type)

	// VirtualNetworkTaps
	if embedded.VirtualNetworkTaps != nil {
		virtualNetworkTapList := make([]v20201101s.VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded, len(embedded.VirtualNetworkTaps))
		for virtualNetworkTapIndex, virtualNetworkTapItem := range embedded.VirtualNetworkTaps {
			// Shadow the loop variable to avoid aliasing
			virtualNetworkTapItem := virtualNetworkTapItem
			var virtualNetworkTap v20201101s.VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded
			err := virtualNetworkTapItem.AssignPropertiesToVirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded(&virtualNetworkTap)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded() to populate field VirtualNetworkTaps")
			}
			virtualNetworkTapList[virtualNetworkTapIndex] = virtualNetworkTap
		}
		destination.VirtualNetworkTaps = virtualNetworkTapList
	} else {
		destination.VirtualNetworkTaps = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded
// Deprecated version of NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded. Use v1beta20201101.NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded instead
type NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded struct {
	ApplicationGatewayBackendAddressPools []ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded `json:"applicationGatewayBackendAddressPools,omitempty"`
	ApplicationSecurityGroups             []ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded             `json:"applicationSecurityGroups,omitempty"`
	Etag                                  *string                                                                            `json:"etag,omitempty"`
	Id                                    *string                                                                            `json:"id,omitempty"`
	LoadBalancerBackendAddressPools       []BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded                   `json:"loadBalancerBackendAddressPools,omitempty"`
	LoadBalancerInboundNatRules           []InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded                       `json:"loadBalancerInboundNatRules,omitempty"`
	Name                                  *string                                                                            `json:"name,omitempty"`
	Primary                               *bool                                                                              `json:"primary,omitempty"`
	PrivateIPAddress                      *string                                                                            `json:"privateIPAddress,omitempty"`
	PrivateIPAddressVersion               *string                                                                            `json:"privateIPAddressVersion,omitempty"`
	PrivateIPAllocationMethod             *string                                                                            `json:"privateIPAllocationMethod,omitempty"`
	PrivateLinkConnectionProperties       *NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS             `json:"privateLinkConnectionProperties,omitempty"`
	PropertyBag                           genruntime.PropertyBag                                                             `json:"$propertyBag,omitempty"`
	ProvisioningState                     *string                                                                            `json:"provisioningState,omitempty"`
	PublicIPAddress                       *PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded                       `json:"publicIPAddress,omitempty"`
	Subnet                                *Subnet_STATUS_NetworkInterface_SubResourceEmbedded                                `json:"subnet,omitempty"`
	Type                                  *string                                                                            `json:"type,omitempty"`
	VirtualNetworkTaps                    []VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded                    `json:"virtualNetworkTaps,omitempty"`
}

// AssignPropertiesFromNetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded populates our NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded from the provided source NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromNetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded(source *v20201101s.NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ApplicationGatewayBackendAddressPools
	if source.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded, len(source.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range source.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded
			err := applicationGatewayBackendAddressPool.AssignPropertiesFromApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded(&applicationGatewayBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		embedded.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		embedded.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if source.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded, len(source.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range source.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded
			err := applicationSecurityGroup.AssignPropertiesFromApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded(&applicationSecurityGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		embedded.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		embedded.ApplicationSecurityGroups = nil
	}

	// Etag
	embedded.Etag = genruntime.ClonePointerToString(source.Etag)

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// LoadBalancerBackendAddressPools
	if source.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded, len(source.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range source.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded
			err := loadBalancerBackendAddressPool.AssignPropertiesFromBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded(&loadBalancerBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		embedded.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		embedded.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatRules
	if source.LoadBalancerInboundNatRules != nil {
		loadBalancerInboundNatRuleList := make([]InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded, len(source.LoadBalancerInboundNatRules))
		for loadBalancerInboundNatRuleIndex, loadBalancerInboundNatRuleItem := range source.LoadBalancerInboundNatRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatRuleItem := loadBalancerInboundNatRuleItem
			var loadBalancerInboundNatRule InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded
			err := loadBalancerInboundNatRule.AssignPropertiesFromInboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded(&loadBalancerInboundNatRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromInboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerInboundNatRules")
			}
			loadBalancerInboundNatRuleList[loadBalancerInboundNatRuleIndex] = loadBalancerInboundNatRule
		}
		embedded.LoadBalancerInboundNatRules = loadBalancerInboundNatRuleList
	} else {
		embedded.LoadBalancerInboundNatRules = nil
	}

	// Name
	embedded.Name = genruntime.ClonePointerToString(source.Name)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		embedded.Primary = &primary
	} else {
		embedded.Primary = nil
	}

	// PrivateIPAddress
	embedded.PrivateIPAddress = genruntime.ClonePointerToString(source.PrivateIPAddress)

	// PrivateIPAddressVersion
	embedded.PrivateIPAddressVersion = genruntime.ClonePointerToString(source.PrivateIPAddressVersion)

	// PrivateIPAllocationMethod
	embedded.PrivateIPAllocationMethod = genruntime.ClonePointerToString(source.PrivateIPAllocationMethod)

	// PrivateLinkConnectionProperties
	if source.PrivateLinkConnectionProperties != nil {
		var privateLinkConnectionProperty NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS
		err := privateLinkConnectionProperty.AssignPropertiesFromNetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS(source.PrivateLinkConnectionProperties)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromNetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS() to populate field PrivateLinkConnectionProperties")
		}
		embedded.PrivateLinkConnectionProperties = &privateLinkConnectionProperty
	} else {
		embedded.PrivateLinkConnectionProperties = nil
	}

	// ProvisioningState
	embedded.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// PublicIPAddress
	if source.PublicIPAddress != nil {
		var publicIPAddress PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded
		err := publicIPAddress.AssignPropertiesFromPublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded(source.PublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded() to populate field PublicIPAddress")
		}
		embedded.PublicIPAddress = &publicIPAddress
	} else {
		embedded.PublicIPAddress = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet Subnet_STATUS_NetworkInterface_SubResourceEmbedded
		err := subnet.AssignPropertiesFromSubnet_STATUS_NetworkInterface_SubResourceEmbedded(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubnet_STATUS_NetworkInterface_SubResourceEmbedded() to populate field Subnet")
		}
		embedded.Subnet = &subnet
	} else {
		embedded.Subnet = nil
	}

	// Type
	embedded.Type = genruntime.ClonePointerToString(source.Type)

	// VirtualNetworkTaps
	if source.VirtualNetworkTaps != nil {
		virtualNetworkTapList := make([]VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded, len(source.VirtualNetworkTaps))
		for virtualNetworkTapIndex, virtualNetworkTapItem := range source.VirtualNetworkTaps {
			// Shadow the loop variable to avoid aliasing
			virtualNetworkTapItem := virtualNetworkTapItem
			var virtualNetworkTap VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded
			err := virtualNetworkTap.AssignPropertiesFromVirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded(&virtualNetworkTapItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded() to populate field VirtualNetworkTaps")
			}
			virtualNetworkTapList[virtualNetworkTapIndex] = virtualNetworkTap
		}
		embedded.VirtualNetworkTaps = virtualNetworkTapList
	} else {
		embedded.VirtualNetworkTaps = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToNetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded populates the provided destination NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded from our NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded) AssignPropertiesToNetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded(destination *v20201101s.NetworkInterfaceIPConfiguration_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// ApplicationGatewayBackendAddressPools
	if embedded.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]v20201101s.ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded, len(embedded.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range embedded.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool v20201101s.ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded
			err := applicationGatewayBackendAddressPoolItem.AssignPropertiesToApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded(&applicationGatewayBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		destination.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		destination.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if embedded.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]v20201101s.ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded, len(embedded.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range embedded.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup v20201101s.ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded
			err := applicationSecurityGroupItem.AssignPropertiesToApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded(&applicationSecurityGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		destination.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		destination.ApplicationSecurityGroups = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(embedded.Etag)

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// LoadBalancerBackendAddressPools
	if embedded.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]v20201101s.BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded, len(embedded.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range embedded.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool v20201101s.BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded
			err := loadBalancerBackendAddressPoolItem.AssignPropertiesToBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded(&loadBalancerBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		destination.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		destination.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatRules
	if embedded.LoadBalancerInboundNatRules != nil {
		loadBalancerInboundNatRuleList := make([]v20201101s.InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded, len(embedded.LoadBalancerInboundNatRules))
		for loadBalancerInboundNatRuleIndex, loadBalancerInboundNatRuleItem := range embedded.LoadBalancerInboundNatRules {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatRuleItem := loadBalancerInboundNatRuleItem
			var loadBalancerInboundNatRule v20201101s.InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded
			err := loadBalancerInboundNatRuleItem.AssignPropertiesToInboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded(&loadBalancerInboundNatRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToInboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerInboundNatRules")
			}
			loadBalancerInboundNatRuleList[loadBalancerInboundNatRuleIndex] = loadBalancerInboundNatRule
		}
		destination.LoadBalancerInboundNatRules = loadBalancerInboundNatRuleList
	} else {
		destination.LoadBalancerInboundNatRules = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(embedded.Name)

	// Primary
	if embedded.Primary != nil {
		primary := *embedded.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// PrivateIPAddress
	destination.PrivateIPAddress = genruntime.ClonePointerToString(embedded.PrivateIPAddress)

	// PrivateIPAddressVersion
	destination.PrivateIPAddressVersion = genruntime.ClonePointerToString(embedded.PrivateIPAddressVersion)

	// PrivateIPAllocationMethod
	destination.PrivateIPAllocationMethod = genruntime.ClonePointerToString(embedded.PrivateIPAllocationMethod)

	// PrivateLinkConnectionProperties
	if embedded.PrivateLinkConnectionProperties != nil {
		var privateLinkConnectionProperty v20201101s.NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS
		err := embedded.PrivateLinkConnectionProperties.AssignPropertiesToNetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS(&privateLinkConnectionProperty)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToNetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS() to populate field PrivateLinkConnectionProperties")
		}
		destination.PrivateLinkConnectionProperties = &privateLinkConnectionProperty
	} else {
		destination.PrivateLinkConnectionProperties = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(embedded.ProvisioningState)

	// PublicIPAddress
	if embedded.PublicIPAddress != nil {
		var publicIPAddress v20201101s.PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded
		err := embedded.PublicIPAddress.AssignPropertiesToPublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded(&publicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded() to populate field PublicIPAddress")
		}
		destination.PublicIPAddress = &publicIPAddress
	} else {
		destination.PublicIPAddress = nil
	}

	// Subnet
	if embedded.Subnet != nil {
		var subnet v20201101s.Subnet_STATUS_NetworkInterface_SubResourceEmbedded
		err := embedded.Subnet.AssignPropertiesToSubnet_STATUS_NetworkInterface_SubResourceEmbedded(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubnet_STATUS_NetworkInterface_SubResourceEmbedded() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(embedded.Type)

	// VirtualNetworkTaps
	if embedded.VirtualNetworkTaps != nil {
		virtualNetworkTapList := make([]v20201101s.VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded, len(embedded.VirtualNetworkTaps))
		for virtualNetworkTapIndex, virtualNetworkTapItem := range embedded.VirtualNetworkTaps {
			// Shadow the loop variable to avoid aliasing
			virtualNetworkTapItem := virtualNetworkTapItem
			var virtualNetworkTap v20201101s.VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded
			err := virtualNetworkTapItem.AssignPropertiesToVirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded(&virtualNetworkTap)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded() to populate field VirtualNetworkTaps")
			}
			virtualNetworkTapList[virtualNetworkTapIndex] = virtualNetworkTap
		}
		destination.VirtualNetworkTaps = virtualNetworkTapList
	} else {
		destination.VirtualNetworkTaps = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded
// Deprecated version of NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded. Use v1beta20201101.NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded instead
type NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded struct {
	Id          *string                `json:"id,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromNetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded populates our NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded from the provided source NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromNetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded(source *v20201101s.NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToNetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded populates the provided destination NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded from our NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded) AssignPropertiesToNetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded(destination *v20201101s.NetworkInterfaceTapConfiguration_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded
// Deprecated version of NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded. Use v1beta20201101.NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded instead
type NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded struct {
	Location      *string                                             `json:"location,omitempty"`
	PropertyBag   genruntime.PropertyBag                              `json:"$propertyBag,omitempty"`
	Reference     *genruntime.ResourceReference                       `armReference:"Id" json:"reference,omitempty"`
	SecurityRules []SecurityRule_NetworkInterface_SubResourceEmbedded `json:"securityRules,omitempty"`
	Tags          map[string]string                                   `json:"tags,omitempty"`
}

// AssignPropertiesFromNetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded populates our NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded from the provided source NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromNetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded(source *v20201101s.NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Location
	embedded.Location = genruntime.ClonePointerToString(source.Location)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// SecurityRules
	if source.SecurityRules != nil {
		securityRuleList := make([]SecurityRule_NetworkInterface_SubResourceEmbedded, len(source.SecurityRules))
		for securityRuleIndex, securityRuleItem := range source.SecurityRules {
			// Shadow the loop variable to avoid aliasing
			securityRuleItem := securityRuleItem
			var securityRule SecurityRule_NetworkInterface_SubResourceEmbedded
			err := securityRule.AssignPropertiesFromSecurityRule_NetworkInterface_SubResourceEmbedded(&securityRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSecurityRule_NetworkInterface_SubResourceEmbedded() to populate field SecurityRules")
			}
			securityRuleList[securityRuleIndex] = securityRule
		}
		embedded.SecurityRules = securityRuleList
	} else {
		embedded.SecurityRules = nil
	}

	// Tags
	embedded.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToNetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded populates the provided destination NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded from our NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded) AssignPropertiesToNetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded(destination *v20201101s.NetworkSecurityGroupSpec_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// Location
	destination.Location = genruntime.ClonePointerToString(embedded.Location)

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// SecurityRules
	if embedded.SecurityRules != nil {
		securityRuleList := make([]v20201101s.SecurityRule_NetworkInterface_SubResourceEmbedded, len(embedded.SecurityRules))
		for securityRuleIndex, securityRuleItem := range embedded.SecurityRules {
			// Shadow the loop variable to avoid aliasing
			securityRuleItem := securityRuleItem
			var securityRule v20201101s.SecurityRule_NetworkInterface_SubResourceEmbedded
			err := securityRuleItem.AssignPropertiesToSecurityRule_NetworkInterface_SubResourceEmbedded(&securityRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSecurityRule_NetworkInterface_SubResourceEmbedded() to populate field SecurityRules")
			}
			securityRuleList[securityRuleIndex] = securityRule
		}
		destination.SecurityRules = securityRuleList
	} else {
		destination.SecurityRules = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(embedded.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded
// Deprecated version of NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded. Use v1beta20201101.NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded instead
type NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded struct {
	Id          *string                `json:"id,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromNetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded populates our NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded from the provided source NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromNetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded(source *v20201101s.NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToNetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded populates the provided destination NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded from our NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded) AssignPropertiesToNetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded(destination *v20201101s.NetworkSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded
// Deprecated version of PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded. Use v1beta20201101.PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded instead
type PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded struct {
	ExtendedLocation *ExtendedLocation_STATUS `json:"extendedLocation,omitempty"`
	Id               *string                  `json:"id,omitempty"`
	PropertyBag      genruntime.PropertyBag   `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromPrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded populates our PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded from the provided source PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromPrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded(source *v20201101s.PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_STATUS
		err := extendedLocation.AssignPropertiesFromExtendedLocation_STATUS(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		embedded.ExtendedLocation = &extendedLocation
	} else {
		embedded.ExtendedLocation = nil
	}

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToPrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded populates the provided destination PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded from our PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded) AssignPropertiesToPrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded(destination *v20201101s.PrivateEndpoint_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// ExtendedLocation
	if embedded.ExtendedLocation != nil {
		var extendedLocation v20201101s.ExtendedLocation_STATUS
		err := embedded.ExtendedLocation.AssignPropertiesToExtendedLocation_STATUS(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.PrivateLinkServiceSpec
// Deprecated version of PrivateLinkServiceSpec. Use v1beta20201101.PrivateLinkServiceSpec instead
type PrivateLinkServiceSpec struct {
	AutoApproval                         *ResourceSet                                                             `json:"autoApproval,omitempty"`
	EnableProxyProtocol                  *bool                                                                    `json:"enableProxyProtocol,omitempty"`
	ExtendedLocation                     *ExtendedLocation                                                        `json:"extendedLocation,omitempty"`
	Fqdns                                []string                                                                 `json:"fqdns,omitempty"`
	IpConfigurations                     []PrivateLinkServiceIpConfiguration_NetworkInterface_SubResourceEmbedded `json:"ipConfigurations,omitempty"`
	LoadBalancerFrontendIpConfigurations []FrontendIPConfiguration_NetworkInterface_SubResourceEmbedded           `json:"loadBalancerFrontendIpConfigurations,omitempty"`
	Location                             *string                                                                  `json:"location,omitempty"`
	PropertyBag                          genruntime.PropertyBag                                                   `json:"$propertyBag,omitempty"`
	Reference                            *genruntime.ResourceReference                                            `armReference:"Id" json:"reference,omitempty"`
	Tags                                 map[string]string                                                        `json:"tags,omitempty"`
	Visibility                           *ResourceSet                                                             `json:"visibility,omitempty"`
}

// AssignPropertiesFromPrivateLinkServiceSpec populates our PrivateLinkServiceSpec from the provided source PrivateLinkServiceSpec
func (service *PrivateLinkServiceSpec) AssignPropertiesFromPrivateLinkServiceSpec(source *v20201101s.PrivateLinkServiceSpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AutoApproval
	if source.AutoApproval != nil {
		var autoApproval ResourceSet
		err := autoApproval.AssignPropertiesFromResourceSet(source.AutoApproval)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromResourceSet() to populate field AutoApproval")
		}
		service.AutoApproval = &autoApproval
	} else {
		service.AutoApproval = nil
	}

	// EnableProxyProtocol
	if source.EnableProxyProtocol != nil {
		enableProxyProtocol := *source.EnableProxyProtocol
		service.EnableProxyProtocol = &enableProxyProtocol
	} else {
		service.EnableProxyProtocol = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation
		err := extendedLocation.AssignPropertiesFromExtendedLocation(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocation() to populate field ExtendedLocation")
		}
		service.ExtendedLocation = &extendedLocation
	} else {
		service.ExtendedLocation = nil
	}

	// Fqdns
	service.Fqdns = genruntime.CloneSliceOfString(source.Fqdns)

	// IpConfigurations
	if source.IpConfigurations != nil {
		ipConfigurationList := make([]PrivateLinkServiceIpConfiguration_NetworkInterface_SubResourceEmbedded, len(source.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration PrivateLinkServiceIpConfiguration_NetworkInterface_SubResourceEmbedded
			err := ipConfiguration.AssignPropertiesFromPrivateLinkServiceIpConfiguration_NetworkInterface_SubResourceEmbedded(&ipConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromPrivateLinkServiceIpConfiguration_NetworkInterface_SubResourceEmbedded() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		service.IpConfigurations = ipConfigurationList
	} else {
		service.IpConfigurations = nil
	}

	// LoadBalancerFrontendIpConfigurations
	if source.LoadBalancerFrontendIpConfigurations != nil {
		loadBalancerFrontendIpConfigurationList := make([]FrontendIPConfiguration_NetworkInterface_SubResourceEmbedded, len(source.LoadBalancerFrontendIpConfigurations))
		for loadBalancerFrontendIpConfigurationIndex, loadBalancerFrontendIpConfigurationItem := range source.LoadBalancerFrontendIpConfigurations {
			// Shadow the loop variable to avoid aliasing
			loadBalancerFrontendIpConfigurationItem := loadBalancerFrontendIpConfigurationItem
			var loadBalancerFrontendIpConfiguration FrontendIPConfiguration_NetworkInterface_SubResourceEmbedded
			err := loadBalancerFrontendIpConfiguration.AssignPropertiesFromFrontendIPConfiguration_NetworkInterface_SubResourceEmbedded(&loadBalancerFrontendIpConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromFrontendIPConfiguration_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerFrontendIpConfigurations")
			}
			loadBalancerFrontendIpConfigurationList[loadBalancerFrontendIpConfigurationIndex] = loadBalancerFrontendIpConfiguration
		}
		service.LoadBalancerFrontendIpConfigurations = loadBalancerFrontendIpConfigurationList
	} else {
		service.LoadBalancerFrontendIpConfigurations = nil
	}

	// Location
	service.Location = genruntime.ClonePointerToString(source.Location)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		service.Reference = &reference
	} else {
		service.Reference = nil
	}

	// Tags
	service.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Visibility
	if source.Visibility != nil {
		var visibility ResourceSet
		err := visibility.AssignPropertiesFromResourceSet(source.Visibility)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromResourceSet() to populate field Visibility")
		}
		service.Visibility = &visibility
	} else {
		service.Visibility = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		service.PropertyBag = propertyBag
	} else {
		service.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToPrivateLinkServiceSpec populates the provided destination PrivateLinkServiceSpec from our PrivateLinkServiceSpec
func (service *PrivateLinkServiceSpec) AssignPropertiesToPrivateLinkServiceSpec(destination *v20201101s.PrivateLinkServiceSpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(service.PropertyBag)

	// AutoApproval
	if service.AutoApproval != nil {
		var autoApproval v20201101s.ResourceSet
		err := service.AutoApproval.AssignPropertiesToResourceSet(&autoApproval)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToResourceSet() to populate field AutoApproval")
		}
		destination.AutoApproval = &autoApproval
	} else {
		destination.AutoApproval = nil
	}

	// EnableProxyProtocol
	if service.EnableProxyProtocol != nil {
		enableProxyProtocol := *service.EnableProxyProtocol
		destination.EnableProxyProtocol = &enableProxyProtocol
	} else {
		destination.EnableProxyProtocol = nil
	}

	// ExtendedLocation
	if service.ExtendedLocation != nil {
		var extendedLocation v20201101s.ExtendedLocation
		err := service.ExtendedLocation.AssignPropertiesToExtendedLocation(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocation() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// Fqdns
	destination.Fqdns = genruntime.CloneSliceOfString(service.Fqdns)

	// IpConfigurations
	if service.IpConfigurations != nil {
		ipConfigurationList := make([]v20201101s.PrivateLinkServiceIpConfiguration_NetworkInterface_SubResourceEmbedded, len(service.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range service.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration v20201101s.PrivateLinkServiceIpConfiguration_NetworkInterface_SubResourceEmbedded
			err := ipConfigurationItem.AssignPropertiesToPrivateLinkServiceIpConfiguration_NetworkInterface_SubResourceEmbedded(&ipConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToPrivateLinkServiceIpConfiguration_NetworkInterface_SubResourceEmbedded() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		destination.IpConfigurations = ipConfigurationList
	} else {
		destination.IpConfigurations = nil
	}

	// LoadBalancerFrontendIpConfigurations
	if service.LoadBalancerFrontendIpConfigurations != nil {
		loadBalancerFrontendIpConfigurationList := make([]v20201101s.FrontendIPConfiguration_NetworkInterface_SubResourceEmbedded, len(service.LoadBalancerFrontendIpConfigurations))
		for loadBalancerFrontendIpConfigurationIndex, loadBalancerFrontendIpConfigurationItem := range service.LoadBalancerFrontendIpConfigurations {
			// Shadow the loop variable to avoid aliasing
			loadBalancerFrontendIpConfigurationItem := loadBalancerFrontendIpConfigurationItem
			var loadBalancerFrontendIpConfiguration v20201101s.FrontendIPConfiguration_NetworkInterface_SubResourceEmbedded
			err := loadBalancerFrontendIpConfigurationItem.AssignPropertiesToFrontendIPConfiguration_NetworkInterface_SubResourceEmbedded(&loadBalancerFrontendIpConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToFrontendIPConfiguration_NetworkInterface_SubResourceEmbedded() to populate field LoadBalancerFrontendIpConfigurations")
			}
			loadBalancerFrontendIpConfigurationList[loadBalancerFrontendIpConfigurationIndex] = loadBalancerFrontendIpConfiguration
		}
		destination.LoadBalancerFrontendIpConfigurations = loadBalancerFrontendIpConfigurationList
	} else {
		destination.LoadBalancerFrontendIpConfigurations = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(service.Location)

	// Reference
	if service.Reference != nil {
		reference := service.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(service.Tags)

	// Visibility
	if service.Visibility != nil {
		var visibility v20201101s.ResourceSet
		err := service.Visibility.AssignPropertiesToResourceSet(&visibility)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToResourceSet() to populate field Visibility")
		}
		destination.Visibility = &visibility
	} else {
		destination.Visibility = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded
// Deprecated version of PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded. Use v1beta20201101.PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded instead
type PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded struct {
	ExtendedLocation *ExtendedLocation_STATUS `json:"extendedLocation,omitempty"`
	Id               *string                  `json:"id,omitempty"`
	PropertyBag      genruntime.PropertyBag   `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromPrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded populates our PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded from the provided source PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromPrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded(source *v20201101s.PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_STATUS
		err := extendedLocation.AssignPropertiesFromExtendedLocation_STATUS(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		embedded.ExtendedLocation = &extendedLocation
	} else {
		embedded.ExtendedLocation = nil
	}

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToPrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded populates the provided destination PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded from our PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded) AssignPropertiesToPrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded(destination *v20201101s.PrivateLinkService_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// ExtendedLocation
	if embedded.ExtendedLocation != nil {
		var extendedLocation v20201101s.ExtendedLocation_STATUS
		err := embedded.ExtendedLocation.AssignPropertiesToExtendedLocation_STATUS(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.SubResource_STATUS
// Deprecated version of SubResource_STATUS. Use v1beta20201101.SubResource_STATUS instead
type SubResource_STATUS struct {
	Id          *string                `json:"id,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromSubResource_STATUS populates our SubResource_STATUS from the provided source SubResource_STATUS
func (resource *SubResource_STATUS) AssignPropertiesFromSubResource_STATUS(source *v20201101s.SubResource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Id
	resource.Id = genruntime.ClonePointerToString(source.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		resource.PropertyBag = propertyBag
	} else {
		resource.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSubResource_STATUS populates the provided destination SubResource_STATUS from our SubResource_STATUS
func (resource *SubResource_STATUS) AssignPropertiesToSubResource_STATUS(destination *v20201101s.SubResource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(resource.PropertyBag)

	// Id
	destination.Id = genruntime.ClonePointerToString(resource.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.ApplicationGatewayBackendAddressPool
// Deprecated version of ApplicationGatewayBackendAddressPool. Use v1beta20201101.ApplicationGatewayBackendAddressPool instead
type ApplicationGatewayBackendAddressPool struct {
	BackendAddresses []ApplicationGatewayBackendAddress `json:"backendAddresses,omitempty"`
	Name             *string                            `json:"name,omitempty"`
	PropertyBag      genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
	Reference        *genruntime.ResourceReference      `armReference:"Id" json:"reference,omitempty"`
}

// AssignPropertiesFromApplicationGatewayBackendAddressPool populates our ApplicationGatewayBackendAddressPool from the provided source ApplicationGatewayBackendAddressPool
func (pool *ApplicationGatewayBackendAddressPool) AssignPropertiesFromApplicationGatewayBackendAddressPool(source *v20201101s.ApplicationGatewayBackendAddressPool) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BackendAddresses
	if source.BackendAddresses != nil {
		backendAddressList := make([]ApplicationGatewayBackendAddress, len(source.BackendAddresses))
		for backendAddressIndex, backendAddressItem := range source.BackendAddresses {
			// Shadow the loop variable to avoid aliasing
			backendAddressItem := backendAddressItem
			var backendAddress ApplicationGatewayBackendAddress
			err := backendAddress.AssignPropertiesFromApplicationGatewayBackendAddress(&backendAddressItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromApplicationGatewayBackendAddress() to populate field BackendAddresses")
			}
			backendAddressList[backendAddressIndex] = backendAddress
		}
		pool.BackendAddresses = backendAddressList
	} else {
		pool.BackendAddresses = nil
	}

	// Name
	pool.Name = genruntime.ClonePointerToString(source.Name)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		pool.Reference = &reference
	} else {
		pool.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		pool.PropertyBag = propertyBag
	} else {
		pool.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToApplicationGatewayBackendAddressPool populates the provided destination ApplicationGatewayBackendAddressPool from our ApplicationGatewayBackendAddressPool
func (pool *ApplicationGatewayBackendAddressPool) AssignPropertiesToApplicationGatewayBackendAddressPool(destination *v20201101s.ApplicationGatewayBackendAddressPool) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(pool.PropertyBag)

	// BackendAddresses
	if pool.BackendAddresses != nil {
		backendAddressList := make([]v20201101s.ApplicationGatewayBackendAddress, len(pool.BackendAddresses))
		for backendAddressIndex, backendAddressItem := range pool.BackendAddresses {
			// Shadow the loop variable to avoid aliasing
			backendAddressItem := backendAddressItem
			var backendAddress v20201101s.ApplicationGatewayBackendAddress
			err := backendAddressItem.AssignPropertiesToApplicationGatewayBackendAddress(&backendAddress)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToApplicationGatewayBackendAddress() to populate field BackendAddresses")
			}
			backendAddressList[backendAddressIndex] = backendAddress
		}
		destination.BackendAddresses = backendAddressList
	} else {
		destination.BackendAddresses = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(pool.Name)

	// Reference
	if pool.Reference != nil {
		reference := pool.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded
// Deprecated version of ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded. Use v1beta20201101.ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded instead
type ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded struct {
	BackendAddresses  []ApplicationGatewayBackendAddress_STATUS `json:"backendAddresses,omitempty"`
	Etag              *string                                   `json:"etag,omitempty"`
	Id                *string                                   `json:"id,omitempty"`
	Name              *string                                   `json:"name,omitempty"`
	PropertyBag       genruntime.PropertyBag                    `json:"$propertyBag,omitempty"`
	ProvisioningState *string                                   `json:"provisioningState,omitempty"`
	Type              *string                                   `json:"type,omitempty"`
}

// AssignPropertiesFromApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded populates our ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded from the provided source ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded(source *v20201101s.ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BackendAddresses
	if source.BackendAddresses != nil {
		backendAddressList := make([]ApplicationGatewayBackendAddress_STATUS, len(source.BackendAddresses))
		for backendAddressIndex, backendAddressItem := range source.BackendAddresses {
			// Shadow the loop variable to avoid aliasing
			backendAddressItem := backendAddressItem
			var backendAddress ApplicationGatewayBackendAddress_STATUS
			err := backendAddress.AssignPropertiesFromApplicationGatewayBackendAddress_STATUS(&backendAddressItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromApplicationGatewayBackendAddress_STATUS() to populate field BackendAddresses")
			}
			backendAddressList[backendAddressIndex] = backendAddress
		}
		embedded.BackendAddresses = backendAddressList
	} else {
		embedded.BackendAddresses = nil
	}

	// Etag
	embedded.Etag = genruntime.ClonePointerToString(source.Etag)

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// Name
	embedded.Name = genruntime.ClonePointerToString(source.Name)

	// ProvisioningState
	embedded.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// Type
	embedded.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded populates the provided destination ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded from our ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded) AssignPropertiesToApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded(destination *v20201101s.ApplicationGatewayBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// BackendAddresses
	if embedded.BackendAddresses != nil {
		backendAddressList := make([]v20201101s.ApplicationGatewayBackendAddress_STATUS, len(embedded.BackendAddresses))
		for backendAddressIndex, backendAddressItem := range embedded.BackendAddresses {
			// Shadow the loop variable to avoid aliasing
			backendAddressItem := backendAddressItem
			var backendAddress v20201101s.ApplicationGatewayBackendAddress_STATUS
			err := backendAddressItem.AssignPropertiesToApplicationGatewayBackendAddress_STATUS(&backendAddress)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToApplicationGatewayBackendAddress_STATUS() to populate field BackendAddresses")
			}
			backendAddressList[backendAddressIndex] = backendAddress
		}
		destination.BackendAddresses = backendAddressList
	} else {
		destination.BackendAddresses = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(embedded.Etag)

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Name
	destination.Name = genruntime.ClonePointerToString(embedded.Name)

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(embedded.ProvisioningState)

	// Type
	destination.Type = genruntime.ClonePointerToString(embedded.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded
// Deprecated version of ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded. Use v1beta20201101.ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded instead
type ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded struct {
	Id          *string                `json:"id,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded populates our ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded from the provided source ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded(source *v20201101s.ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded populates the provided destination ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded from our ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded) AssignPropertiesToApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded(destination *v20201101s.ApplicationSecurityGroup_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.BackendAddressPool_NetworkInterface_SubResourceEmbedded
// Deprecated version of BackendAddressPool_NetworkInterface_SubResourceEmbedded. Use v1beta20201101.BackendAddressPool_NetworkInterface_SubResourceEmbedded instead
type BackendAddressPool_NetworkInterface_SubResourceEmbedded struct {
	PropertyBag genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	Reference   *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

// AssignPropertiesFromBackendAddressPool_NetworkInterface_SubResourceEmbedded populates our BackendAddressPool_NetworkInterface_SubResourceEmbedded from the provided source BackendAddressPool_NetworkInterface_SubResourceEmbedded
func (embedded *BackendAddressPool_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromBackendAddressPool_NetworkInterface_SubResourceEmbedded(source *v20201101s.BackendAddressPool_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToBackendAddressPool_NetworkInterface_SubResourceEmbedded populates the provided destination BackendAddressPool_NetworkInterface_SubResourceEmbedded from our BackendAddressPool_NetworkInterface_SubResourceEmbedded
func (embedded *BackendAddressPool_NetworkInterface_SubResourceEmbedded) AssignPropertiesToBackendAddressPool_NetworkInterface_SubResourceEmbedded(destination *v20201101s.BackendAddressPool_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded
// Deprecated version of BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded. Use v1beta20201101.BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded instead
type BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded struct {
	Id          *string                `json:"id,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded populates our BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded from the provided source BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded(source *v20201101s.BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded populates the provided destination BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded from our BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded) AssignPropertiesToBackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded(destination *v20201101s.BackendAddressPool_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.FrontendIPConfiguration_NetworkInterface_SubResourceEmbedded
// Deprecated version of FrontendIPConfiguration_NetworkInterface_SubResourceEmbedded. Use v1beta20201101.FrontendIPConfiguration_NetworkInterface_SubResourceEmbedded instead
type FrontendIPConfiguration_NetworkInterface_SubResourceEmbedded struct {
	Name                      *string                                      `json:"name,omitempty"`
	PrivateIPAddress          *string                                      `json:"privateIPAddress,omitempty"`
	PrivateIPAddressVersion   *string                                      `json:"privateIPAddressVersion,omitempty"`
	PrivateIPAllocationMethod *string                                      `json:"privateIPAllocationMethod,omitempty"`
	PropertyBag               genruntime.PropertyBag                       `json:"$propertyBag,omitempty"`
	PublicIPAddress           *PublicIPAddressSpec                         `json:"publicIPAddress,omitempty"`
	PublicIPPrefix            *SubResource                                 `json:"publicIPPrefix,omitempty"`
	Reference                 *genruntime.ResourceReference                `armReference:"Id" json:"reference,omitempty"`
	Subnet                    *Subnet_NetworkInterface_SubResourceEmbedded `json:"subnet,omitempty"`
	Zones                     []string                                     `json:"zones,omitempty"`
}

// AssignPropertiesFromFrontendIPConfiguration_NetworkInterface_SubResourceEmbedded populates our FrontendIPConfiguration_NetworkInterface_SubResourceEmbedded from the provided source FrontendIPConfiguration_NetworkInterface_SubResourceEmbedded
func (embedded *FrontendIPConfiguration_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromFrontendIPConfiguration_NetworkInterface_SubResourceEmbedded(source *v20201101s.FrontendIPConfiguration_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	embedded.Name = genruntime.ClonePointerToString(source.Name)

	// PrivateIPAddress
	embedded.PrivateIPAddress = genruntime.ClonePointerToString(source.PrivateIPAddress)

	// PrivateIPAddressVersion
	embedded.PrivateIPAddressVersion = genruntime.ClonePointerToString(source.PrivateIPAddressVersion)

	// PrivateIPAllocationMethod
	embedded.PrivateIPAllocationMethod = genruntime.ClonePointerToString(source.PrivateIPAllocationMethod)

	// PublicIPAddress
	if source.PublicIPAddress != nil {
		var publicIPAddress PublicIPAddressSpec
		err := publicIPAddress.AssignPropertiesFromPublicIPAddressSpec(source.PublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPublicIPAddressSpec() to populate field PublicIPAddress")
		}
		embedded.PublicIPAddress = &publicIPAddress
	} else {
		embedded.PublicIPAddress = nil
	}

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var publicIPPrefix SubResource
		err := publicIPPrefix.AssignPropertiesFromSubResource(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubResource() to populate field PublicIPPrefix")
		}
		embedded.PublicIPPrefix = &publicIPPrefix
	} else {
		embedded.PublicIPPrefix = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet Subnet_NetworkInterface_SubResourceEmbedded
		err := subnet.AssignPropertiesFromSubnet_NetworkInterface_SubResourceEmbedded(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubnet_NetworkInterface_SubResourceEmbedded() to populate field Subnet")
		}
		embedded.Subnet = &subnet
	} else {
		embedded.Subnet = nil
	}

	// Zones
	embedded.Zones = genruntime.CloneSliceOfString(source.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToFrontendIPConfiguration_NetworkInterface_SubResourceEmbedded populates the provided destination FrontendIPConfiguration_NetworkInterface_SubResourceEmbedded from our FrontendIPConfiguration_NetworkInterface_SubResourceEmbedded
func (embedded *FrontendIPConfiguration_NetworkInterface_SubResourceEmbedded) AssignPropertiesToFrontendIPConfiguration_NetworkInterface_SubResourceEmbedded(destination *v20201101s.FrontendIPConfiguration_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(embedded.Name)

	// PrivateIPAddress
	destination.PrivateIPAddress = genruntime.ClonePointerToString(embedded.PrivateIPAddress)

	// PrivateIPAddressVersion
	destination.PrivateIPAddressVersion = genruntime.ClonePointerToString(embedded.PrivateIPAddressVersion)

	// PrivateIPAllocationMethod
	destination.PrivateIPAllocationMethod = genruntime.ClonePointerToString(embedded.PrivateIPAllocationMethod)

	// PublicIPAddress
	if embedded.PublicIPAddress != nil {
		var publicIPAddress v20201101s.PublicIPAddressSpec
		err := embedded.PublicIPAddress.AssignPropertiesToPublicIPAddressSpec(&publicIPAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPublicIPAddressSpec() to populate field PublicIPAddress")
		}
		destination.PublicIPAddress = &publicIPAddress
	} else {
		destination.PublicIPAddress = nil
	}

	// PublicIPPrefix
	if embedded.PublicIPPrefix != nil {
		var publicIPPrefix v20201101s.SubResource
		err := embedded.PublicIPPrefix.AssignPropertiesToSubResource(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubResource() to populate field PublicIPPrefix")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Subnet
	if embedded.Subnet != nil {
		var subnet v20201101s.Subnet_NetworkInterface_SubResourceEmbedded
		err := embedded.Subnet.AssignPropertiesToSubnet_NetworkInterface_SubResourceEmbedded(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubnet_NetworkInterface_SubResourceEmbedded() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(embedded.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.InboundNatRule_NetworkInterface_SubResourceEmbedded
// Deprecated version of InboundNatRule_NetworkInterface_SubResourceEmbedded. Use v1beta20201101.InboundNatRule_NetworkInterface_SubResourceEmbedded instead
type InboundNatRule_NetworkInterface_SubResourceEmbedded struct {
	PropertyBag genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	Reference   *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

// AssignPropertiesFromInboundNatRule_NetworkInterface_SubResourceEmbedded populates our InboundNatRule_NetworkInterface_SubResourceEmbedded from the provided source InboundNatRule_NetworkInterface_SubResourceEmbedded
func (embedded *InboundNatRule_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromInboundNatRule_NetworkInterface_SubResourceEmbedded(source *v20201101s.InboundNatRule_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToInboundNatRule_NetworkInterface_SubResourceEmbedded populates the provided destination InboundNatRule_NetworkInterface_SubResourceEmbedded from our InboundNatRule_NetworkInterface_SubResourceEmbedded
func (embedded *InboundNatRule_NetworkInterface_SubResourceEmbedded) AssignPropertiesToInboundNatRule_NetworkInterface_SubResourceEmbedded(destination *v20201101s.InboundNatRule_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded
// Deprecated version of InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded. Use v1beta20201101.InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded instead
type InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded struct {
	Id          *string                `json:"id,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromInboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded populates our InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded from the provided source InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromInboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded(source *v20201101s.InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToInboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded populates the provided destination InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded from our InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded) AssignPropertiesToInboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded(destination *v20201101s.InboundNatRule_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS
// Deprecated version of NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS. Use v1beta20201101.NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS instead
type NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS struct {
	Fqdns              []string               `json:"fqdns,omitempty"`
	GroupId            *string                `json:"groupId,omitempty"`
	PropertyBag        genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RequiredMemberName *string                `json:"requiredMemberName,omitempty"`
}

// AssignPropertiesFromNetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS populates our NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS from the provided source NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS
func (properties *NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS) AssignPropertiesFromNetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS(source *v20201101s.NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Fqdns
	properties.Fqdns = genruntime.CloneSliceOfString(source.Fqdns)

	// GroupId
	properties.GroupId = genruntime.ClonePointerToString(source.GroupId)

	// RequiredMemberName
	properties.RequiredMemberName = genruntime.ClonePointerToString(source.RequiredMemberName)

	// Update the property bag
	if len(propertyBag) > 0 {
		properties.PropertyBag = propertyBag
	} else {
		properties.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToNetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS populates the provided destination NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS from our NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS
func (properties *NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS) AssignPropertiesToNetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS(destination *v20201101s.NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(properties.PropertyBag)

	// Fqdns
	destination.Fqdns = genruntime.CloneSliceOfString(properties.Fqdns)

	// GroupId
	destination.GroupId = genruntime.ClonePointerToString(properties.GroupId)

	// RequiredMemberName
	destination.RequiredMemberName = genruntime.ClonePointerToString(properties.RequiredMemberName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.PrivateLinkServiceIpConfiguration_NetworkInterface_SubResourceEmbedded
// Deprecated version of PrivateLinkServiceIpConfiguration_NetworkInterface_SubResourceEmbedded. Use v1beta20201101.PrivateLinkServiceIpConfiguration_NetworkInterface_SubResourceEmbedded instead
type PrivateLinkServiceIpConfiguration_NetworkInterface_SubResourceEmbedded struct {
	Name                      *string                                      `json:"name,omitempty"`
	Primary                   *bool                                        `json:"primary,omitempty"`
	PrivateIPAddress          *string                                      `json:"privateIPAddress,omitempty"`
	PrivateIPAddressVersion   *string                                      `json:"privateIPAddressVersion,omitempty"`
	PrivateIPAllocationMethod *string                                      `json:"privateIPAllocationMethod,omitempty"`
	PropertyBag               genruntime.PropertyBag                       `json:"$propertyBag,omitempty"`
	Reference                 *genruntime.ResourceReference                `armReference:"Id" json:"reference,omitempty"`
	Subnet                    *Subnet_NetworkInterface_SubResourceEmbedded `json:"subnet,omitempty"`
}

// AssignPropertiesFromPrivateLinkServiceIpConfiguration_NetworkInterface_SubResourceEmbedded populates our PrivateLinkServiceIpConfiguration_NetworkInterface_SubResourceEmbedded from the provided source PrivateLinkServiceIpConfiguration_NetworkInterface_SubResourceEmbedded
func (embedded *PrivateLinkServiceIpConfiguration_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromPrivateLinkServiceIpConfiguration_NetworkInterface_SubResourceEmbedded(source *v20201101s.PrivateLinkServiceIpConfiguration_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	embedded.Name = genruntime.ClonePointerToString(source.Name)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		embedded.Primary = &primary
	} else {
		embedded.Primary = nil
	}

	// PrivateIPAddress
	embedded.PrivateIPAddress = genruntime.ClonePointerToString(source.PrivateIPAddress)

	// PrivateIPAddressVersion
	embedded.PrivateIPAddressVersion = genruntime.ClonePointerToString(source.PrivateIPAddressVersion)

	// PrivateIPAllocationMethod
	embedded.PrivateIPAllocationMethod = genruntime.ClonePointerToString(source.PrivateIPAllocationMethod)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet Subnet_NetworkInterface_SubResourceEmbedded
		err := subnet.AssignPropertiesFromSubnet_NetworkInterface_SubResourceEmbedded(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSubnet_NetworkInterface_SubResourceEmbedded() to populate field Subnet")
		}
		embedded.Subnet = &subnet
	} else {
		embedded.Subnet = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToPrivateLinkServiceIpConfiguration_NetworkInterface_SubResourceEmbedded populates the provided destination PrivateLinkServiceIpConfiguration_NetworkInterface_SubResourceEmbedded from our PrivateLinkServiceIpConfiguration_NetworkInterface_SubResourceEmbedded
func (embedded *PrivateLinkServiceIpConfiguration_NetworkInterface_SubResourceEmbedded) AssignPropertiesToPrivateLinkServiceIpConfiguration_NetworkInterface_SubResourceEmbedded(destination *v20201101s.PrivateLinkServiceIpConfiguration_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(embedded.Name)

	// Primary
	if embedded.Primary != nil {
		primary := *embedded.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// PrivateIPAddress
	destination.PrivateIPAddress = genruntime.ClonePointerToString(embedded.PrivateIPAddress)

	// PrivateIPAddressVersion
	destination.PrivateIPAddressVersion = genruntime.ClonePointerToString(embedded.PrivateIPAddressVersion)

	// PrivateIPAllocationMethod
	destination.PrivateIPAllocationMethod = genruntime.ClonePointerToString(embedded.PrivateIPAllocationMethod)

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Subnet
	if embedded.Subnet != nil {
		var subnet v20201101s.Subnet_NetworkInterface_SubResourceEmbedded
		err := embedded.Subnet.AssignPropertiesToSubnet_NetworkInterface_SubResourceEmbedded(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSubnet_NetworkInterface_SubResourceEmbedded() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded
// Deprecated version of PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded. Use v1beta20201101.PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded instead
type PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded struct {
	ExtendedLocation *ExtendedLocation_STATUS   `json:"extendedLocation,omitempty"`
	Id               *string                    `json:"id,omitempty"`
	PropertyBag      genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
	Sku              *PublicIPAddressSku_STATUS `json:"sku,omitempty"`
	Zones            []string                   `json:"zones,omitempty"`
}

// AssignPropertiesFromPublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded populates our PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded from the provided source PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromPublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded(source *v20201101s.PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_STATUS
		err := extendedLocation.AssignPropertiesFromExtendedLocation_STATUS(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		embedded.ExtendedLocation = &extendedLocation
	} else {
		embedded.ExtendedLocation = nil
	}

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// Sku
	if source.Sku != nil {
		var sku PublicIPAddressSku_STATUS
		err := sku.AssignPropertiesFromPublicIPAddressSku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPublicIPAddressSku_STATUS() to populate field Sku")
		}
		embedded.Sku = &sku
	} else {
		embedded.Sku = nil
	}

	// Zones
	embedded.Zones = genruntime.CloneSliceOfString(source.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToPublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded populates the provided destination PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded from our PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded) AssignPropertiesToPublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded(destination *v20201101s.PublicIPAddress_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// ExtendedLocation
	if embedded.ExtendedLocation != nil {
		var extendedLocation v20201101s.ExtendedLocation_STATUS
		err := embedded.ExtendedLocation.AssignPropertiesToExtendedLocation_STATUS(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Sku
	if embedded.Sku != nil {
		var sku v20201101s.PublicIPAddressSku_STATUS
		err := embedded.Sku.AssignPropertiesToPublicIPAddressSku_STATUS(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPublicIPAddressSku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(embedded.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.ResourceSet
// Deprecated version of ResourceSet. Use v1beta20201101.ResourceSet instead
type ResourceSet struct {
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Subscriptions []string               `json:"subscriptions,omitempty"`
}

// AssignPropertiesFromResourceSet populates our ResourceSet from the provided source ResourceSet
func (resourceSet *ResourceSet) AssignPropertiesFromResourceSet(source *v20201101s.ResourceSet) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Subscriptions
	resourceSet.Subscriptions = genruntime.CloneSliceOfString(source.Subscriptions)

	// Update the property bag
	if len(propertyBag) > 0 {
		resourceSet.PropertyBag = propertyBag
	} else {
		resourceSet.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToResourceSet populates the provided destination ResourceSet from our ResourceSet
func (resourceSet *ResourceSet) AssignPropertiesToResourceSet(destination *v20201101s.ResourceSet) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(resourceSet.PropertyBag)

	// Subscriptions
	destination.Subscriptions = genruntime.CloneSliceOfString(resourceSet.Subscriptions)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.SecurityRule_NetworkInterface_SubResourceEmbedded
// Deprecated version of SecurityRule_NetworkInterface_SubResourceEmbedded. Use v1beta20201101.SecurityRule_NetworkInterface_SubResourceEmbedded instead
type SecurityRule_NetworkInterface_SubResourceEmbedded struct {
	PropertyBag genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	Reference   *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

// AssignPropertiesFromSecurityRule_NetworkInterface_SubResourceEmbedded populates our SecurityRule_NetworkInterface_SubResourceEmbedded from the provided source SecurityRule_NetworkInterface_SubResourceEmbedded
func (embedded *SecurityRule_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromSecurityRule_NetworkInterface_SubResourceEmbedded(source *v20201101s.SecurityRule_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSecurityRule_NetworkInterface_SubResourceEmbedded populates the provided destination SecurityRule_NetworkInterface_SubResourceEmbedded from our SecurityRule_NetworkInterface_SubResourceEmbedded
func (embedded *SecurityRule_NetworkInterface_SubResourceEmbedded) AssignPropertiesToSecurityRule_NetworkInterface_SubResourceEmbedded(destination *v20201101s.SecurityRule_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.Subnet_NetworkInterface_SubResourceEmbedded
// Deprecated version of Subnet_NetworkInterface_SubResourceEmbedded. Use v1beta20201101.Subnet_NetworkInterface_SubResourceEmbedded instead
type Subnet_NetworkInterface_SubResourceEmbedded struct {
	PropertyBag genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	Reference   *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

// AssignPropertiesFromSubnet_NetworkInterface_SubResourceEmbedded populates our Subnet_NetworkInterface_SubResourceEmbedded from the provided source Subnet_NetworkInterface_SubResourceEmbedded
func (embedded *Subnet_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromSubnet_NetworkInterface_SubResourceEmbedded(source *v20201101s.Subnet_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSubnet_NetworkInterface_SubResourceEmbedded populates the provided destination Subnet_NetworkInterface_SubResourceEmbedded from our Subnet_NetworkInterface_SubResourceEmbedded
func (embedded *Subnet_NetworkInterface_SubResourceEmbedded) AssignPropertiesToSubnet_NetworkInterface_SubResourceEmbedded(destination *v20201101s.Subnet_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.Subnet_STATUS_NetworkInterface_SubResourceEmbedded
// Deprecated version of Subnet_STATUS_NetworkInterface_SubResourceEmbedded. Use v1beta20201101.Subnet_STATUS_NetworkInterface_SubResourceEmbedded instead
type Subnet_STATUS_NetworkInterface_SubResourceEmbedded struct {
	Id          *string                `json:"id,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromSubnet_STATUS_NetworkInterface_SubResourceEmbedded populates our Subnet_STATUS_NetworkInterface_SubResourceEmbedded from the provided source Subnet_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *Subnet_STATUS_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromSubnet_STATUS_NetworkInterface_SubResourceEmbedded(source *v20201101s.Subnet_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSubnet_STATUS_NetworkInterface_SubResourceEmbedded populates the provided destination Subnet_STATUS_NetworkInterface_SubResourceEmbedded from our Subnet_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *Subnet_STATUS_NetworkInterface_SubResourceEmbedded) AssignPropertiesToSubnet_STATUS_NetworkInterface_SubResourceEmbedded(destination *v20201101s.Subnet_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded
// Deprecated version of VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded. Use v1beta20201101.VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded instead
type VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded struct {
	DestinationLoadBalancerFrontEndIPConfiguration *FrontendIPConfiguration_NetworkInterface_SubResourceEmbedded `json:"destinationLoadBalancerFrontEndIPConfiguration,omitempty"`
	DestinationPort                                *int                                                          `json:"destinationPort,omitempty"`
	Location                                       *string                                                       `json:"location,omitempty"`
	PropertyBag                                    genruntime.PropertyBag                                        `json:"$propertyBag,omitempty"`
	Reference                                      *genruntime.ResourceReference                                 `armReference:"Id" json:"reference,omitempty"`
	Tags                                           map[string]string                                             `json:"tags,omitempty"`
}

// AssignPropertiesFromVirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded populates our VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded from the provided source VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded
func (embedded *VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromVirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded(source *v20201101s.VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DestinationLoadBalancerFrontEndIPConfiguration
	if source.DestinationLoadBalancerFrontEndIPConfiguration != nil {
		var destinationLoadBalancerFrontEndIPConfiguration FrontendIPConfiguration_NetworkInterface_SubResourceEmbedded
		err := destinationLoadBalancerFrontEndIPConfiguration.AssignPropertiesFromFrontendIPConfiguration_NetworkInterface_SubResourceEmbedded(source.DestinationLoadBalancerFrontEndIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromFrontendIPConfiguration_NetworkInterface_SubResourceEmbedded() to populate field DestinationLoadBalancerFrontEndIPConfiguration")
		}
		embedded.DestinationLoadBalancerFrontEndIPConfiguration = &destinationLoadBalancerFrontEndIPConfiguration
	} else {
		embedded.DestinationLoadBalancerFrontEndIPConfiguration = nil
	}

	// DestinationPort
	embedded.DestinationPort = genruntime.ClonePointerToInt(source.DestinationPort)

	// Location
	embedded.Location = genruntime.ClonePointerToString(source.Location)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		embedded.Reference = &reference
	} else {
		embedded.Reference = nil
	}

	// Tags
	embedded.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded populates the provided destination VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded from our VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded
func (embedded *VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded) AssignPropertiesToVirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded(destination *v20201101s.VirtualNetworkTapSpec_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// DestinationLoadBalancerFrontEndIPConfiguration
	if embedded.DestinationLoadBalancerFrontEndIPConfiguration != nil {
		var destinationLoadBalancerFrontEndIPConfiguration v20201101s.FrontendIPConfiguration_NetworkInterface_SubResourceEmbedded
		err := embedded.DestinationLoadBalancerFrontEndIPConfiguration.AssignPropertiesToFrontendIPConfiguration_NetworkInterface_SubResourceEmbedded(&destinationLoadBalancerFrontEndIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToFrontendIPConfiguration_NetworkInterface_SubResourceEmbedded() to populate field DestinationLoadBalancerFrontEndIPConfiguration")
		}
		destination.DestinationLoadBalancerFrontEndIPConfiguration = &destinationLoadBalancerFrontEndIPConfiguration
	} else {
		destination.DestinationLoadBalancerFrontEndIPConfiguration = nil
	}

	// DestinationPort
	destination.DestinationPort = genruntime.ClonePointerToInt(embedded.DestinationPort)

	// Location
	destination.Location = genruntime.ClonePointerToString(embedded.Location)

	// Reference
	if embedded.Reference != nil {
		reference := embedded.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(embedded.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded
// Deprecated version of VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded. Use v1beta20201101.VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded instead
type VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded struct {
	Id          *string                `json:"id,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromVirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded populates our VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded from the provided source VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded) AssignPropertiesFromVirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded(source *v20201101s.VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded populates the provided destination VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded from our VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded
func (embedded *VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded) AssignPropertiesToVirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded(destination *v20201101s.VirtualNetworkTap_STATUS_NetworkInterface_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.ApplicationGatewayBackendAddress
// Deprecated version of ApplicationGatewayBackendAddress. Use v1beta20201101.ApplicationGatewayBackendAddress instead
type ApplicationGatewayBackendAddress struct {
	Fqdn        *string                `json:"fqdn,omitempty"`
	IpAddress   *string                `json:"ipAddress,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromApplicationGatewayBackendAddress populates our ApplicationGatewayBackendAddress from the provided source ApplicationGatewayBackendAddress
func (address *ApplicationGatewayBackendAddress) AssignPropertiesFromApplicationGatewayBackendAddress(source *v20201101s.ApplicationGatewayBackendAddress) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Fqdn
	address.Fqdn = genruntime.ClonePointerToString(source.Fqdn)

	// IpAddress
	address.IpAddress = genruntime.ClonePointerToString(source.IpAddress)

	// Update the property bag
	if len(propertyBag) > 0 {
		address.PropertyBag = propertyBag
	} else {
		address.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToApplicationGatewayBackendAddress populates the provided destination ApplicationGatewayBackendAddress from our ApplicationGatewayBackendAddress
func (address *ApplicationGatewayBackendAddress) AssignPropertiesToApplicationGatewayBackendAddress(destination *v20201101s.ApplicationGatewayBackendAddress) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(address.PropertyBag)

	// Fqdn
	destination.Fqdn = genruntime.ClonePointerToString(address.Fqdn)

	// IpAddress
	destination.IpAddress = genruntime.ClonePointerToString(address.IpAddress)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20201101.ApplicationGatewayBackendAddress_STATUS
// Deprecated version of ApplicationGatewayBackendAddress_STATUS. Use v1beta20201101.ApplicationGatewayBackendAddress_STATUS instead
type ApplicationGatewayBackendAddress_STATUS struct {
	Fqdn        *string                `json:"fqdn,omitempty"`
	IpAddress   *string                `json:"ipAddress,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromApplicationGatewayBackendAddress_STATUS populates our ApplicationGatewayBackendAddress_STATUS from the provided source ApplicationGatewayBackendAddress_STATUS
func (address *ApplicationGatewayBackendAddress_STATUS) AssignPropertiesFromApplicationGatewayBackendAddress_STATUS(source *v20201101s.ApplicationGatewayBackendAddress_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Fqdn
	address.Fqdn = genruntime.ClonePointerToString(source.Fqdn)

	// IpAddress
	address.IpAddress = genruntime.ClonePointerToString(source.IpAddress)

	// Update the property bag
	if len(propertyBag) > 0 {
		address.PropertyBag = propertyBag
	} else {
		address.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToApplicationGatewayBackendAddress_STATUS populates the provided destination ApplicationGatewayBackendAddress_STATUS from our ApplicationGatewayBackendAddress_STATUS
func (address *ApplicationGatewayBackendAddress_STATUS) AssignPropertiesToApplicationGatewayBackendAddress_STATUS(destination *v20201101s.ApplicationGatewayBackendAddress_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(address.PropertyBag)

	// Fqdn
	destination.Fqdn = genruntime.ClonePointerToString(address.Fqdn)

	// IpAddress
	destination.IpAddress = genruntime.ClonePointerToString(address.IpAddress)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&NetworkInterface{}, &NetworkInterfaceList{})
}
