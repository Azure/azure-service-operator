// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240301

import (
	"encoding/json"
	storage "github.com/Azure/azure-service-operator/v2/api/network/v1api20240301/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AzureFirewall_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFirewall to hub returns original",
		prop.ForAll(RunResourceConversionTestForAzureFirewall, AzureFirewallGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForAzureFirewall tests if a specific instance of AzureFirewall round trips to the hub storage version and back losslessly
func RunResourceConversionTestForAzureFirewall(subject AzureFirewall) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub storage.AzureFirewall
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual AzureFirewall
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFirewall_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFirewall to AzureFirewall via AssignProperties_To_AzureFirewall & AssignProperties_From_AzureFirewall returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFirewall, AzureFirewallGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFirewall tests if a specific instance of AzureFirewall can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureFirewall(subject AzureFirewall) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AzureFirewall
	err := copied.AssignProperties_To_AzureFirewall(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFirewall
	err = actual.AssignProperties_From_AzureFirewall(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFirewall_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewall via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewall, AzureFirewallGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewall runs a test to see if a specific instance of AzureFirewall round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewall(subject AzureFirewall) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewall
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewall instances for property testing - lazily instantiated by AzureFirewallGenerator()
var azureFirewallGenerator gopter.Gen

// AzureFirewallGenerator returns a generator of AzureFirewall instances for property testing.
func AzureFirewallGenerator() gopter.Gen {
	if azureFirewallGenerator != nil {
		return azureFirewallGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAzureFirewall(generators)
	azureFirewallGenerator = gen.Struct(reflect.TypeOf(AzureFirewall{}), generators)

	return azureFirewallGenerator
}

// AddRelatedPropertyGeneratorsForAzureFirewall is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFirewall(gens map[string]gopter.Gen) {
	gens["Spec"] = AzureFirewall_SpecGenerator()
	gens["Status"] = AzureFirewall_STATUSGenerator()
}

func Test_AzureFirewallApplicationRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFirewallApplicationRule to AzureFirewallApplicationRule via AssignProperties_To_AzureFirewallApplicationRule & AssignProperties_From_AzureFirewallApplicationRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFirewallApplicationRule, AzureFirewallApplicationRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFirewallApplicationRule tests if a specific instance of AzureFirewallApplicationRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureFirewallApplicationRule(subject AzureFirewallApplicationRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AzureFirewallApplicationRule
	err := copied.AssignProperties_To_AzureFirewallApplicationRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFirewallApplicationRule
	err = actual.AssignProperties_From_AzureFirewallApplicationRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFirewallApplicationRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallApplicationRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallApplicationRule, AzureFirewallApplicationRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallApplicationRule runs a test to see if a specific instance of AzureFirewallApplicationRule round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallApplicationRule(subject AzureFirewallApplicationRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallApplicationRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallApplicationRule instances for property testing - lazily instantiated by
// AzureFirewallApplicationRuleGenerator()
var azureFirewallApplicationRuleGenerator gopter.Gen

// AzureFirewallApplicationRuleGenerator returns a generator of AzureFirewallApplicationRule instances for property testing.
// We first initialize azureFirewallApplicationRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFirewallApplicationRuleGenerator() gopter.Gen {
	if azureFirewallApplicationRuleGenerator != nil {
		return azureFirewallApplicationRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallApplicationRule(generators)
	azureFirewallApplicationRuleGenerator = gen.Struct(reflect.TypeOf(AzureFirewallApplicationRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallApplicationRule(generators)
	AddRelatedPropertyGeneratorsForAzureFirewallApplicationRule(generators)
	azureFirewallApplicationRuleGenerator = gen.Struct(reflect.TypeOf(AzureFirewallApplicationRule{}), generators)

	return azureFirewallApplicationRuleGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallApplicationRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallApplicationRule(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["FqdnTags"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SourceAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["SourceIpGroups"] = gen.SliceOf(gen.AlphaString())
	gens["TargetFqdns"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAzureFirewallApplicationRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFirewallApplicationRule(gens map[string]gopter.Gen) {
	gens["Protocols"] = gen.SliceOf(AzureFirewallApplicationRuleProtocolGenerator())
}

func Test_AzureFirewallApplicationRuleCollection_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFirewallApplicationRuleCollection to AzureFirewallApplicationRuleCollection via AssignProperties_To_AzureFirewallApplicationRuleCollection & AssignProperties_From_AzureFirewallApplicationRuleCollection returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFirewallApplicationRuleCollection, AzureFirewallApplicationRuleCollectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFirewallApplicationRuleCollection tests if a specific instance of AzureFirewallApplicationRuleCollection can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureFirewallApplicationRuleCollection(subject AzureFirewallApplicationRuleCollection) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AzureFirewallApplicationRuleCollection
	err := copied.AssignProperties_To_AzureFirewallApplicationRuleCollection(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFirewallApplicationRuleCollection
	err = actual.AssignProperties_From_AzureFirewallApplicationRuleCollection(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFirewallApplicationRuleCollection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallApplicationRuleCollection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallApplicationRuleCollection, AzureFirewallApplicationRuleCollectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallApplicationRuleCollection runs a test to see if a specific instance of AzureFirewallApplicationRuleCollection round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallApplicationRuleCollection(subject AzureFirewallApplicationRuleCollection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallApplicationRuleCollection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallApplicationRuleCollection instances for property testing - lazily instantiated by
// AzureFirewallApplicationRuleCollectionGenerator()
var azureFirewallApplicationRuleCollectionGenerator gopter.Gen

// AzureFirewallApplicationRuleCollectionGenerator returns a generator of AzureFirewallApplicationRuleCollection instances for property testing.
// We first initialize azureFirewallApplicationRuleCollectionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFirewallApplicationRuleCollectionGenerator() gopter.Gen {
	if azureFirewallApplicationRuleCollectionGenerator != nil {
		return azureFirewallApplicationRuleCollectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallApplicationRuleCollection(generators)
	azureFirewallApplicationRuleCollectionGenerator = gen.Struct(reflect.TypeOf(AzureFirewallApplicationRuleCollection{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallApplicationRuleCollection(generators)
	AddRelatedPropertyGeneratorsForAzureFirewallApplicationRuleCollection(generators)
	azureFirewallApplicationRuleCollectionGenerator = gen.Struct(reflect.TypeOf(AzureFirewallApplicationRuleCollection{}), generators)

	return azureFirewallApplicationRuleCollectionGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallApplicationRuleCollection is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallApplicationRuleCollection(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForAzureFirewallApplicationRuleCollection is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFirewallApplicationRuleCollection(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(AzureFirewallRCActionGenerator())
	gens["Rules"] = gen.SliceOf(AzureFirewallApplicationRuleGenerator())
}

func Test_AzureFirewallApplicationRuleCollection_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFirewallApplicationRuleCollection_STATUS to AzureFirewallApplicationRuleCollection_STATUS via AssignProperties_To_AzureFirewallApplicationRuleCollection_STATUS & AssignProperties_From_AzureFirewallApplicationRuleCollection_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFirewallApplicationRuleCollection_STATUS, AzureFirewallApplicationRuleCollection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFirewallApplicationRuleCollection_STATUS tests if a specific instance of AzureFirewallApplicationRuleCollection_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureFirewallApplicationRuleCollection_STATUS(subject AzureFirewallApplicationRuleCollection_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AzureFirewallApplicationRuleCollection_STATUS
	err := copied.AssignProperties_To_AzureFirewallApplicationRuleCollection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFirewallApplicationRuleCollection_STATUS
	err = actual.AssignProperties_From_AzureFirewallApplicationRuleCollection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFirewallApplicationRuleCollection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallApplicationRuleCollection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallApplicationRuleCollection_STATUS, AzureFirewallApplicationRuleCollection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallApplicationRuleCollection_STATUS runs a test to see if a specific instance of AzureFirewallApplicationRuleCollection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallApplicationRuleCollection_STATUS(subject AzureFirewallApplicationRuleCollection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallApplicationRuleCollection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallApplicationRuleCollection_STATUS instances for property testing - lazily instantiated by
// AzureFirewallApplicationRuleCollection_STATUSGenerator()
var azureFirewallApplicationRuleCollection_STATUSGenerator gopter.Gen

// AzureFirewallApplicationRuleCollection_STATUSGenerator returns a generator of AzureFirewallApplicationRuleCollection_STATUS instances for property testing.
func AzureFirewallApplicationRuleCollection_STATUSGenerator() gopter.Gen {
	if azureFirewallApplicationRuleCollection_STATUSGenerator != nil {
		return azureFirewallApplicationRuleCollection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallApplicationRuleCollection_STATUS(generators)
	azureFirewallApplicationRuleCollection_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureFirewallApplicationRuleCollection_STATUS{}), generators)

	return azureFirewallApplicationRuleCollection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallApplicationRuleCollection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallApplicationRuleCollection_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureFirewallApplicationRuleProtocol_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFirewallApplicationRuleProtocol to AzureFirewallApplicationRuleProtocol via AssignProperties_To_AzureFirewallApplicationRuleProtocol & AssignProperties_From_AzureFirewallApplicationRuleProtocol returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFirewallApplicationRuleProtocol, AzureFirewallApplicationRuleProtocolGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFirewallApplicationRuleProtocol tests if a specific instance of AzureFirewallApplicationRuleProtocol can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureFirewallApplicationRuleProtocol(subject AzureFirewallApplicationRuleProtocol) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AzureFirewallApplicationRuleProtocol
	err := copied.AssignProperties_To_AzureFirewallApplicationRuleProtocol(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFirewallApplicationRuleProtocol
	err = actual.AssignProperties_From_AzureFirewallApplicationRuleProtocol(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFirewallApplicationRuleProtocol_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallApplicationRuleProtocol via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallApplicationRuleProtocol, AzureFirewallApplicationRuleProtocolGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallApplicationRuleProtocol runs a test to see if a specific instance of AzureFirewallApplicationRuleProtocol round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallApplicationRuleProtocol(subject AzureFirewallApplicationRuleProtocol) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallApplicationRuleProtocol
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallApplicationRuleProtocol instances for property testing - lazily instantiated by
// AzureFirewallApplicationRuleProtocolGenerator()
var azureFirewallApplicationRuleProtocolGenerator gopter.Gen

// AzureFirewallApplicationRuleProtocolGenerator returns a generator of AzureFirewallApplicationRuleProtocol instances for property testing.
func AzureFirewallApplicationRuleProtocolGenerator() gopter.Gen {
	if azureFirewallApplicationRuleProtocolGenerator != nil {
		return azureFirewallApplicationRuleProtocolGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallApplicationRuleProtocol(generators)
	azureFirewallApplicationRuleProtocolGenerator = gen.Struct(reflect.TypeOf(AzureFirewallApplicationRuleProtocol{}), generators)

	return azureFirewallApplicationRuleProtocolGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallApplicationRuleProtocol is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallApplicationRuleProtocol(gens map[string]gopter.Gen) {
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["ProtocolType"] = gen.PtrOf(gen.OneConstOf(AzureFirewallApplicationRuleProtocolType_Http, AzureFirewallApplicationRuleProtocolType_Https, AzureFirewallApplicationRuleProtocolType_Mssql))
}

func Test_AzureFirewallAutoscaleConfiguration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFirewallAutoscaleConfiguration to AzureFirewallAutoscaleConfiguration via AssignProperties_To_AzureFirewallAutoscaleConfiguration & AssignProperties_From_AzureFirewallAutoscaleConfiguration returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFirewallAutoscaleConfiguration, AzureFirewallAutoscaleConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFirewallAutoscaleConfiguration tests if a specific instance of AzureFirewallAutoscaleConfiguration can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureFirewallAutoscaleConfiguration(subject AzureFirewallAutoscaleConfiguration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AzureFirewallAutoscaleConfiguration
	err := copied.AssignProperties_To_AzureFirewallAutoscaleConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFirewallAutoscaleConfiguration
	err = actual.AssignProperties_From_AzureFirewallAutoscaleConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFirewallAutoscaleConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallAutoscaleConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallAutoscaleConfiguration, AzureFirewallAutoscaleConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallAutoscaleConfiguration runs a test to see if a specific instance of AzureFirewallAutoscaleConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallAutoscaleConfiguration(subject AzureFirewallAutoscaleConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallAutoscaleConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallAutoscaleConfiguration instances for property testing - lazily instantiated by
// AzureFirewallAutoscaleConfigurationGenerator()
var azureFirewallAutoscaleConfigurationGenerator gopter.Gen

// AzureFirewallAutoscaleConfigurationGenerator returns a generator of AzureFirewallAutoscaleConfiguration instances for property testing.
func AzureFirewallAutoscaleConfigurationGenerator() gopter.Gen {
	if azureFirewallAutoscaleConfigurationGenerator != nil {
		return azureFirewallAutoscaleConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallAutoscaleConfiguration(generators)
	azureFirewallAutoscaleConfigurationGenerator = gen.Struct(reflect.TypeOf(AzureFirewallAutoscaleConfiguration{}), generators)

	return azureFirewallAutoscaleConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallAutoscaleConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallAutoscaleConfiguration(gens map[string]gopter.Gen) {
	gens["MaxCapacity"] = gen.PtrOf(gen.Int())
	gens["MinCapacity"] = gen.PtrOf(gen.Int())
}

func Test_AzureFirewallAutoscaleConfiguration_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFirewallAutoscaleConfiguration_STATUS to AzureFirewallAutoscaleConfiguration_STATUS via AssignProperties_To_AzureFirewallAutoscaleConfiguration_STATUS & AssignProperties_From_AzureFirewallAutoscaleConfiguration_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFirewallAutoscaleConfiguration_STATUS, AzureFirewallAutoscaleConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFirewallAutoscaleConfiguration_STATUS tests if a specific instance of AzureFirewallAutoscaleConfiguration_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureFirewallAutoscaleConfiguration_STATUS(subject AzureFirewallAutoscaleConfiguration_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AzureFirewallAutoscaleConfiguration_STATUS
	err := copied.AssignProperties_To_AzureFirewallAutoscaleConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFirewallAutoscaleConfiguration_STATUS
	err = actual.AssignProperties_From_AzureFirewallAutoscaleConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFirewallAutoscaleConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallAutoscaleConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallAutoscaleConfiguration_STATUS, AzureFirewallAutoscaleConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallAutoscaleConfiguration_STATUS runs a test to see if a specific instance of AzureFirewallAutoscaleConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallAutoscaleConfiguration_STATUS(subject AzureFirewallAutoscaleConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallAutoscaleConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallAutoscaleConfiguration_STATUS instances for property testing - lazily instantiated by
// AzureFirewallAutoscaleConfiguration_STATUSGenerator()
var azureFirewallAutoscaleConfiguration_STATUSGenerator gopter.Gen

// AzureFirewallAutoscaleConfiguration_STATUSGenerator returns a generator of AzureFirewallAutoscaleConfiguration_STATUS instances for property testing.
func AzureFirewallAutoscaleConfiguration_STATUSGenerator() gopter.Gen {
	if azureFirewallAutoscaleConfiguration_STATUSGenerator != nil {
		return azureFirewallAutoscaleConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallAutoscaleConfiguration_STATUS(generators)
	azureFirewallAutoscaleConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureFirewallAutoscaleConfiguration_STATUS{}), generators)

	return azureFirewallAutoscaleConfiguration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallAutoscaleConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallAutoscaleConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["MaxCapacity"] = gen.PtrOf(gen.Int())
	gens["MinCapacity"] = gen.PtrOf(gen.Int())
}

func Test_AzureFirewallIPConfiguration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFirewallIPConfiguration to AzureFirewallIPConfiguration via AssignProperties_To_AzureFirewallIPConfiguration & AssignProperties_From_AzureFirewallIPConfiguration returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFirewallIPConfiguration, AzureFirewallIPConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFirewallIPConfiguration tests if a specific instance of AzureFirewallIPConfiguration can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureFirewallIPConfiguration(subject AzureFirewallIPConfiguration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AzureFirewallIPConfiguration
	err := copied.AssignProperties_To_AzureFirewallIPConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFirewallIPConfiguration
	err = actual.AssignProperties_From_AzureFirewallIPConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFirewallIPConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallIPConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallIPConfiguration, AzureFirewallIPConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallIPConfiguration runs a test to see if a specific instance of AzureFirewallIPConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallIPConfiguration(subject AzureFirewallIPConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallIPConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallIPConfiguration instances for property testing - lazily instantiated by
// AzureFirewallIPConfigurationGenerator()
var azureFirewallIPConfigurationGenerator gopter.Gen

// AzureFirewallIPConfigurationGenerator returns a generator of AzureFirewallIPConfiguration instances for property testing.
// We first initialize azureFirewallIPConfigurationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFirewallIPConfigurationGenerator() gopter.Gen {
	if azureFirewallIPConfigurationGenerator != nil {
		return azureFirewallIPConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallIPConfiguration(generators)
	azureFirewallIPConfigurationGenerator = gen.Struct(reflect.TypeOf(AzureFirewallIPConfiguration{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallIPConfiguration(generators)
	AddRelatedPropertyGeneratorsForAzureFirewallIPConfiguration(generators)
	azureFirewallIPConfigurationGenerator = gen.Struct(reflect.TypeOf(AzureFirewallIPConfiguration{}), generators)

	return azureFirewallIPConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallIPConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallIPConfiguration(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAzureFirewallIPConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFirewallIPConfiguration(gens map[string]gopter.Gen) {
	gens["PublicIPAddress"] = gen.PtrOf(SubResourceGenerator())
	gens["Subnet"] = gen.PtrOf(SubResourceGenerator())
}

func Test_AzureFirewallIPConfiguration_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFirewallIPConfiguration_STATUS to AzureFirewallIPConfiguration_STATUS via AssignProperties_To_AzureFirewallIPConfiguration_STATUS & AssignProperties_From_AzureFirewallIPConfiguration_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFirewallIPConfiguration_STATUS, AzureFirewallIPConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFirewallIPConfiguration_STATUS tests if a specific instance of AzureFirewallIPConfiguration_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureFirewallIPConfiguration_STATUS(subject AzureFirewallIPConfiguration_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AzureFirewallIPConfiguration_STATUS
	err := copied.AssignProperties_To_AzureFirewallIPConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFirewallIPConfiguration_STATUS
	err = actual.AssignProperties_From_AzureFirewallIPConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFirewallIPConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallIPConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallIPConfiguration_STATUS, AzureFirewallIPConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallIPConfiguration_STATUS runs a test to see if a specific instance of AzureFirewallIPConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallIPConfiguration_STATUS(subject AzureFirewallIPConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallIPConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallIPConfiguration_STATUS instances for property testing - lazily instantiated by
// AzureFirewallIPConfiguration_STATUSGenerator()
var azureFirewallIPConfiguration_STATUSGenerator gopter.Gen

// AzureFirewallIPConfiguration_STATUSGenerator returns a generator of AzureFirewallIPConfiguration_STATUS instances for property testing.
func AzureFirewallIPConfiguration_STATUSGenerator() gopter.Gen {
	if azureFirewallIPConfiguration_STATUSGenerator != nil {
		return azureFirewallIPConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallIPConfiguration_STATUS(generators)
	azureFirewallIPConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureFirewallIPConfiguration_STATUS{}), generators)

	return azureFirewallIPConfiguration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallIPConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallIPConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureFirewallIpGroups_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFirewallIpGroups_STATUS to AzureFirewallIpGroups_STATUS via AssignProperties_To_AzureFirewallIpGroups_STATUS & AssignProperties_From_AzureFirewallIpGroups_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFirewallIpGroups_STATUS, AzureFirewallIpGroups_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFirewallIpGroups_STATUS tests if a specific instance of AzureFirewallIpGroups_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureFirewallIpGroups_STATUS(subject AzureFirewallIpGroups_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AzureFirewallIpGroups_STATUS
	err := copied.AssignProperties_To_AzureFirewallIpGroups_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFirewallIpGroups_STATUS
	err = actual.AssignProperties_From_AzureFirewallIpGroups_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFirewallIpGroups_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallIpGroups_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallIpGroups_STATUS, AzureFirewallIpGroups_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallIpGroups_STATUS runs a test to see if a specific instance of AzureFirewallIpGroups_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallIpGroups_STATUS(subject AzureFirewallIpGroups_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallIpGroups_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallIpGroups_STATUS instances for property testing - lazily instantiated by
// AzureFirewallIpGroups_STATUSGenerator()
var azureFirewallIpGroups_STATUSGenerator gopter.Gen

// AzureFirewallIpGroups_STATUSGenerator returns a generator of AzureFirewallIpGroups_STATUS instances for property testing.
func AzureFirewallIpGroups_STATUSGenerator() gopter.Gen {
	if azureFirewallIpGroups_STATUSGenerator != nil {
		return azureFirewallIpGroups_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallIpGroups_STATUS(generators)
	azureFirewallIpGroups_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureFirewallIpGroups_STATUS{}), generators)

	return azureFirewallIpGroups_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallIpGroups_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallIpGroups_STATUS(gens map[string]gopter.Gen) {
	gens["ChangeNumber"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureFirewallNatRCAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFirewallNatRCAction to AzureFirewallNatRCAction via AssignProperties_To_AzureFirewallNatRCAction & AssignProperties_From_AzureFirewallNatRCAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFirewallNatRCAction, AzureFirewallNatRCActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFirewallNatRCAction tests if a specific instance of AzureFirewallNatRCAction can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureFirewallNatRCAction(subject AzureFirewallNatRCAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AzureFirewallNatRCAction
	err := copied.AssignProperties_To_AzureFirewallNatRCAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFirewallNatRCAction
	err = actual.AssignProperties_From_AzureFirewallNatRCAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFirewallNatRCAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallNatRCAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallNatRCAction, AzureFirewallNatRCActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallNatRCAction runs a test to see if a specific instance of AzureFirewallNatRCAction round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallNatRCAction(subject AzureFirewallNatRCAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallNatRCAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallNatRCAction instances for property testing - lazily instantiated by
// AzureFirewallNatRCActionGenerator()
var azureFirewallNatRCActionGenerator gopter.Gen

// AzureFirewallNatRCActionGenerator returns a generator of AzureFirewallNatRCAction instances for property testing.
func AzureFirewallNatRCActionGenerator() gopter.Gen {
	if azureFirewallNatRCActionGenerator != nil {
		return azureFirewallNatRCActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallNatRCAction(generators)
	azureFirewallNatRCActionGenerator = gen.Struct(reflect.TypeOf(AzureFirewallNatRCAction{}), generators)

	return azureFirewallNatRCActionGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallNatRCAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallNatRCAction(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(AzureFirewallNatRCActionType_Dnat, AzureFirewallNatRCActionType_Snat))
}

func Test_AzureFirewallNatRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFirewallNatRule to AzureFirewallNatRule via AssignProperties_To_AzureFirewallNatRule & AssignProperties_From_AzureFirewallNatRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFirewallNatRule, AzureFirewallNatRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFirewallNatRule tests if a specific instance of AzureFirewallNatRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureFirewallNatRule(subject AzureFirewallNatRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AzureFirewallNatRule
	err := copied.AssignProperties_To_AzureFirewallNatRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFirewallNatRule
	err = actual.AssignProperties_From_AzureFirewallNatRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFirewallNatRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallNatRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallNatRule, AzureFirewallNatRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallNatRule runs a test to see if a specific instance of AzureFirewallNatRule round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallNatRule(subject AzureFirewallNatRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallNatRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallNatRule instances for property testing - lazily instantiated by
// AzureFirewallNatRuleGenerator()
var azureFirewallNatRuleGenerator gopter.Gen

// AzureFirewallNatRuleGenerator returns a generator of AzureFirewallNatRule instances for property testing.
func AzureFirewallNatRuleGenerator() gopter.Gen {
	if azureFirewallNatRuleGenerator != nil {
		return azureFirewallNatRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallNatRule(generators)
	azureFirewallNatRuleGenerator = gen.Struct(reflect.TypeOf(AzureFirewallNatRule{}), generators)

	return azureFirewallNatRuleGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallNatRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallNatRule(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DestinationAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationPorts"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocols"] = gen.SliceOf(gen.OneConstOf(
		AzureFirewallNetworkRuleProtocol_Any,
		AzureFirewallNetworkRuleProtocol_ICMP,
		AzureFirewallNetworkRuleProtocol_TCP,
		AzureFirewallNetworkRuleProtocol_UDP))
	gens["SourceAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["SourceIpGroups"] = gen.SliceOf(gen.AlphaString())
	gens["TranslatedAddress"] = gen.PtrOf(gen.AlphaString())
	gens["TranslatedFqdn"] = gen.PtrOf(gen.AlphaString())
	gens["TranslatedPort"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureFirewallNatRuleCollection_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFirewallNatRuleCollection to AzureFirewallNatRuleCollection via AssignProperties_To_AzureFirewallNatRuleCollection & AssignProperties_From_AzureFirewallNatRuleCollection returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFirewallNatRuleCollection, AzureFirewallNatRuleCollectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFirewallNatRuleCollection tests if a specific instance of AzureFirewallNatRuleCollection can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureFirewallNatRuleCollection(subject AzureFirewallNatRuleCollection) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AzureFirewallNatRuleCollection
	err := copied.AssignProperties_To_AzureFirewallNatRuleCollection(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFirewallNatRuleCollection
	err = actual.AssignProperties_From_AzureFirewallNatRuleCollection(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFirewallNatRuleCollection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallNatRuleCollection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallNatRuleCollection, AzureFirewallNatRuleCollectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallNatRuleCollection runs a test to see if a specific instance of AzureFirewallNatRuleCollection round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallNatRuleCollection(subject AzureFirewallNatRuleCollection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallNatRuleCollection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallNatRuleCollection instances for property testing - lazily instantiated by
// AzureFirewallNatRuleCollectionGenerator()
var azureFirewallNatRuleCollectionGenerator gopter.Gen

// AzureFirewallNatRuleCollectionGenerator returns a generator of AzureFirewallNatRuleCollection instances for property testing.
// We first initialize azureFirewallNatRuleCollectionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFirewallNatRuleCollectionGenerator() gopter.Gen {
	if azureFirewallNatRuleCollectionGenerator != nil {
		return azureFirewallNatRuleCollectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallNatRuleCollection(generators)
	azureFirewallNatRuleCollectionGenerator = gen.Struct(reflect.TypeOf(AzureFirewallNatRuleCollection{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallNatRuleCollection(generators)
	AddRelatedPropertyGeneratorsForAzureFirewallNatRuleCollection(generators)
	azureFirewallNatRuleCollectionGenerator = gen.Struct(reflect.TypeOf(AzureFirewallNatRuleCollection{}), generators)

	return azureFirewallNatRuleCollectionGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallNatRuleCollection is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallNatRuleCollection(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForAzureFirewallNatRuleCollection is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFirewallNatRuleCollection(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(AzureFirewallNatRCActionGenerator())
	gens["Rules"] = gen.SliceOf(AzureFirewallNatRuleGenerator())
}

func Test_AzureFirewallNatRuleCollection_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFirewallNatRuleCollection_STATUS to AzureFirewallNatRuleCollection_STATUS via AssignProperties_To_AzureFirewallNatRuleCollection_STATUS & AssignProperties_From_AzureFirewallNatRuleCollection_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFirewallNatRuleCollection_STATUS, AzureFirewallNatRuleCollection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFirewallNatRuleCollection_STATUS tests if a specific instance of AzureFirewallNatRuleCollection_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureFirewallNatRuleCollection_STATUS(subject AzureFirewallNatRuleCollection_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AzureFirewallNatRuleCollection_STATUS
	err := copied.AssignProperties_To_AzureFirewallNatRuleCollection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFirewallNatRuleCollection_STATUS
	err = actual.AssignProperties_From_AzureFirewallNatRuleCollection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFirewallNatRuleCollection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallNatRuleCollection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallNatRuleCollection_STATUS, AzureFirewallNatRuleCollection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallNatRuleCollection_STATUS runs a test to see if a specific instance of AzureFirewallNatRuleCollection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallNatRuleCollection_STATUS(subject AzureFirewallNatRuleCollection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallNatRuleCollection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallNatRuleCollection_STATUS instances for property testing - lazily instantiated by
// AzureFirewallNatRuleCollection_STATUSGenerator()
var azureFirewallNatRuleCollection_STATUSGenerator gopter.Gen

// AzureFirewallNatRuleCollection_STATUSGenerator returns a generator of AzureFirewallNatRuleCollection_STATUS instances for property testing.
func AzureFirewallNatRuleCollection_STATUSGenerator() gopter.Gen {
	if azureFirewallNatRuleCollection_STATUSGenerator != nil {
		return azureFirewallNatRuleCollection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallNatRuleCollection_STATUS(generators)
	azureFirewallNatRuleCollection_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureFirewallNatRuleCollection_STATUS{}), generators)

	return azureFirewallNatRuleCollection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallNatRuleCollection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallNatRuleCollection_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureFirewallNetworkRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFirewallNetworkRule to AzureFirewallNetworkRule via AssignProperties_To_AzureFirewallNetworkRule & AssignProperties_From_AzureFirewallNetworkRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFirewallNetworkRule, AzureFirewallNetworkRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFirewallNetworkRule tests if a specific instance of AzureFirewallNetworkRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureFirewallNetworkRule(subject AzureFirewallNetworkRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AzureFirewallNetworkRule
	err := copied.AssignProperties_To_AzureFirewallNetworkRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFirewallNetworkRule
	err = actual.AssignProperties_From_AzureFirewallNetworkRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFirewallNetworkRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallNetworkRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallNetworkRule, AzureFirewallNetworkRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallNetworkRule runs a test to see if a specific instance of AzureFirewallNetworkRule round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallNetworkRule(subject AzureFirewallNetworkRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallNetworkRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallNetworkRule instances for property testing - lazily instantiated by
// AzureFirewallNetworkRuleGenerator()
var azureFirewallNetworkRuleGenerator gopter.Gen

// AzureFirewallNetworkRuleGenerator returns a generator of AzureFirewallNetworkRule instances for property testing.
func AzureFirewallNetworkRuleGenerator() gopter.Gen {
	if azureFirewallNetworkRuleGenerator != nil {
		return azureFirewallNetworkRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallNetworkRule(generators)
	azureFirewallNetworkRuleGenerator = gen.Struct(reflect.TypeOf(AzureFirewallNetworkRule{}), generators)

	return azureFirewallNetworkRuleGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallNetworkRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallNetworkRule(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DestinationAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationFqdns"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationIpGroups"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationPorts"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocols"] = gen.SliceOf(gen.OneConstOf(
		AzureFirewallNetworkRuleProtocol_Any,
		AzureFirewallNetworkRuleProtocol_ICMP,
		AzureFirewallNetworkRuleProtocol_TCP,
		AzureFirewallNetworkRuleProtocol_UDP))
	gens["SourceAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["SourceIpGroups"] = gen.SliceOf(gen.AlphaString())
}

func Test_AzureFirewallNetworkRuleCollection_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFirewallNetworkRuleCollection to AzureFirewallNetworkRuleCollection via AssignProperties_To_AzureFirewallNetworkRuleCollection & AssignProperties_From_AzureFirewallNetworkRuleCollection returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFirewallNetworkRuleCollection, AzureFirewallNetworkRuleCollectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFirewallNetworkRuleCollection tests if a specific instance of AzureFirewallNetworkRuleCollection can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureFirewallNetworkRuleCollection(subject AzureFirewallNetworkRuleCollection) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AzureFirewallNetworkRuleCollection
	err := copied.AssignProperties_To_AzureFirewallNetworkRuleCollection(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFirewallNetworkRuleCollection
	err = actual.AssignProperties_From_AzureFirewallNetworkRuleCollection(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFirewallNetworkRuleCollection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallNetworkRuleCollection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallNetworkRuleCollection, AzureFirewallNetworkRuleCollectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallNetworkRuleCollection runs a test to see if a specific instance of AzureFirewallNetworkRuleCollection round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallNetworkRuleCollection(subject AzureFirewallNetworkRuleCollection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallNetworkRuleCollection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallNetworkRuleCollection instances for property testing - lazily instantiated by
// AzureFirewallNetworkRuleCollectionGenerator()
var azureFirewallNetworkRuleCollectionGenerator gopter.Gen

// AzureFirewallNetworkRuleCollectionGenerator returns a generator of AzureFirewallNetworkRuleCollection instances for property testing.
// We first initialize azureFirewallNetworkRuleCollectionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFirewallNetworkRuleCollectionGenerator() gopter.Gen {
	if azureFirewallNetworkRuleCollectionGenerator != nil {
		return azureFirewallNetworkRuleCollectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallNetworkRuleCollection(generators)
	azureFirewallNetworkRuleCollectionGenerator = gen.Struct(reflect.TypeOf(AzureFirewallNetworkRuleCollection{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallNetworkRuleCollection(generators)
	AddRelatedPropertyGeneratorsForAzureFirewallNetworkRuleCollection(generators)
	azureFirewallNetworkRuleCollectionGenerator = gen.Struct(reflect.TypeOf(AzureFirewallNetworkRuleCollection{}), generators)

	return azureFirewallNetworkRuleCollectionGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallNetworkRuleCollection is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallNetworkRuleCollection(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForAzureFirewallNetworkRuleCollection is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFirewallNetworkRuleCollection(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(AzureFirewallRCActionGenerator())
	gens["Rules"] = gen.SliceOf(AzureFirewallNetworkRuleGenerator())
}

func Test_AzureFirewallNetworkRuleCollection_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFirewallNetworkRuleCollection_STATUS to AzureFirewallNetworkRuleCollection_STATUS via AssignProperties_To_AzureFirewallNetworkRuleCollection_STATUS & AssignProperties_From_AzureFirewallNetworkRuleCollection_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFirewallNetworkRuleCollection_STATUS, AzureFirewallNetworkRuleCollection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFirewallNetworkRuleCollection_STATUS tests if a specific instance of AzureFirewallNetworkRuleCollection_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureFirewallNetworkRuleCollection_STATUS(subject AzureFirewallNetworkRuleCollection_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AzureFirewallNetworkRuleCollection_STATUS
	err := copied.AssignProperties_To_AzureFirewallNetworkRuleCollection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFirewallNetworkRuleCollection_STATUS
	err = actual.AssignProperties_From_AzureFirewallNetworkRuleCollection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFirewallNetworkRuleCollection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallNetworkRuleCollection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallNetworkRuleCollection_STATUS, AzureFirewallNetworkRuleCollection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallNetworkRuleCollection_STATUS runs a test to see if a specific instance of AzureFirewallNetworkRuleCollection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallNetworkRuleCollection_STATUS(subject AzureFirewallNetworkRuleCollection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallNetworkRuleCollection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallNetworkRuleCollection_STATUS instances for property testing - lazily instantiated by
// AzureFirewallNetworkRuleCollection_STATUSGenerator()
var azureFirewallNetworkRuleCollection_STATUSGenerator gopter.Gen

// AzureFirewallNetworkRuleCollection_STATUSGenerator returns a generator of AzureFirewallNetworkRuleCollection_STATUS instances for property testing.
func AzureFirewallNetworkRuleCollection_STATUSGenerator() gopter.Gen {
	if azureFirewallNetworkRuleCollection_STATUSGenerator != nil {
		return azureFirewallNetworkRuleCollection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallNetworkRuleCollection_STATUS(generators)
	azureFirewallNetworkRuleCollection_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureFirewallNetworkRuleCollection_STATUS{}), generators)

	return azureFirewallNetworkRuleCollection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallNetworkRuleCollection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallNetworkRuleCollection_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureFirewallOperatorSpec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFirewallOperatorSpec to AzureFirewallOperatorSpec via AssignProperties_To_AzureFirewallOperatorSpec & AssignProperties_From_AzureFirewallOperatorSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFirewallOperatorSpec, AzureFirewallOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFirewallOperatorSpec tests if a specific instance of AzureFirewallOperatorSpec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureFirewallOperatorSpec(subject AzureFirewallOperatorSpec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AzureFirewallOperatorSpec
	err := copied.AssignProperties_To_AzureFirewallOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFirewallOperatorSpec
	err = actual.AssignProperties_From_AzureFirewallOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFirewallOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallOperatorSpec, AzureFirewallOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallOperatorSpec runs a test to see if a specific instance of AzureFirewallOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallOperatorSpec(subject AzureFirewallOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallOperatorSpec instances for property testing - lazily instantiated by
// AzureFirewallOperatorSpecGenerator()
var azureFirewallOperatorSpecGenerator gopter.Gen

// AzureFirewallOperatorSpecGenerator returns a generator of AzureFirewallOperatorSpec instances for property testing.
func AzureFirewallOperatorSpecGenerator() gopter.Gen {
	if azureFirewallOperatorSpecGenerator != nil {
		return azureFirewallOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	azureFirewallOperatorSpecGenerator = gen.Struct(reflect.TypeOf(AzureFirewallOperatorSpec{}), generators)

	return azureFirewallOperatorSpecGenerator
}

func Test_AzureFirewallPublicIPAddress_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFirewallPublicIPAddress to AzureFirewallPublicIPAddress via AssignProperties_To_AzureFirewallPublicIPAddress & AssignProperties_From_AzureFirewallPublicIPAddress returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFirewallPublicIPAddress, AzureFirewallPublicIPAddressGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFirewallPublicIPAddress tests if a specific instance of AzureFirewallPublicIPAddress can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureFirewallPublicIPAddress(subject AzureFirewallPublicIPAddress) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AzureFirewallPublicIPAddress
	err := copied.AssignProperties_To_AzureFirewallPublicIPAddress(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFirewallPublicIPAddress
	err = actual.AssignProperties_From_AzureFirewallPublicIPAddress(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFirewallPublicIPAddress_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallPublicIPAddress via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallPublicIPAddress, AzureFirewallPublicIPAddressGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallPublicIPAddress runs a test to see if a specific instance of AzureFirewallPublicIPAddress round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallPublicIPAddress(subject AzureFirewallPublicIPAddress) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallPublicIPAddress
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallPublicIPAddress instances for property testing - lazily instantiated by
// AzureFirewallPublicIPAddressGenerator()
var azureFirewallPublicIPAddressGenerator gopter.Gen

// AzureFirewallPublicIPAddressGenerator returns a generator of AzureFirewallPublicIPAddress instances for property testing.
func AzureFirewallPublicIPAddressGenerator() gopter.Gen {
	if azureFirewallPublicIPAddressGenerator != nil {
		return azureFirewallPublicIPAddressGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallPublicIPAddress(generators)
	azureFirewallPublicIPAddressGenerator = gen.Struct(reflect.TypeOf(AzureFirewallPublicIPAddress{}), generators)

	return azureFirewallPublicIPAddressGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallPublicIPAddress is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallPublicIPAddress(gens map[string]gopter.Gen) {
	gens["Address"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureFirewallPublicIPAddress_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFirewallPublicIPAddress_STATUS to AzureFirewallPublicIPAddress_STATUS via AssignProperties_To_AzureFirewallPublicIPAddress_STATUS & AssignProperties_From_AzureFirewallPublicIPAddress_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFirewallPublicIPAddress_STATUS, AzureFirewallPublicIPAddress_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFirewallPublicIPAddress_STATUS tests if a specific instance of AzureFirewallPublicIPAddress_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureFirewallPublicIPAddress_STATUS(subject AzureFirewallPublicIPAddress_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AzureFirewallPublicIPAddress_STATUS
	err := copied.AssignProperties_To_AzureFirewallPublicIPAddress_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFirewallPublicIPAddress_STATUS
	err = actual.AssignProperties_From_AzureFirewallPublicIPAddress_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFirewallPublicIPAddress_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallPublicIPAddress_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallPublicIPAddress_STATUS, AzureFirewallPublicIPAddress_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallPublicIPAddress_STATUS runs a test to see if a specific instance of AzureFirewallPublicIPAddress_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallPublicIPAddress_STATUS(subject AzureFirewallPublicIPAddress_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallPublicIPAddress_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallPublicIPAddress_STATUS instances for property testing - lazily instantiated by
// AzureFirewallPublicIPAddress_STATUSGenerator()
var azureFirewallPublicIPAddress_STATUSGenerator gopter.Gen

// AzureFirewallPublicIPAddress_STATUSGenerator returns a generator of AzureFirewallPublicIPAddress_STATUS instances for property testing.
func AzureFirewallPublicIPAddress_STATUSGenerator() gopter.Gen {
	if azureFirewallPublicIPAddress_STATUSGenerator != nil {
		return azureFirewallPublicIPAddress_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallPublicIPAddress_STATUS(generators)
	azureFirewallPublicIPAddress_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureFirewallPublicIPAddress_STATUS{}), generators)

	return azureFirewallPublicIPAddress_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallPublicIPAddress_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallPublicIPAddress_STATUS(gens map[string]gopter.Gen) {
	gens["Address"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureFirewallRCAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFirewallRCAction to AzureFirewallRCAction via AssignProperties_To_AzureFirewallRCAction & AssignProperties_From_AzureFirewallRCAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFirewallRCAction, AzureFirewallRCActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFirewallRCAction tests if a specific instance of AzureFirewallRCAction can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureFirewallRCAction(subject AzureFirewallRCAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AzureFirewallRCAction
	err := copied.AssignProperties_To_AzureFirewallRCAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFirewallRCAction
	err = actual.AssignProperties_From_AzureFirewallRCAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFirewallRCAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallRCAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallRCAction, AzureFirewallRCActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallRCAction runs a test to see if a specific instance of AzureFirewallRCAction round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallRCAction(subject AzureFirewallRCAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallRCAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallRCAction instances for property testing - lazily instantiated by
// AzureFirewallRCActionGenerator()
var azureFirewallRCActionGenerator gopter.Gen

// AzureFirewallRCActionGenerator returns a generator of AzureFirewallRCAction instances for property testing.
func AzureFirewallRCActionGenerator() gopter.Gen {
	if azureFirewallRCActionGenerator != nil {
		return azureFirewallRCActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallRCAction(generators)
	azureFirewallRCActionGenerator = gen.Struct(reflect.TypeOf(AzureFirewallRCAction{}), generators)

	return azureFirewallRCActionGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallRCAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallRCAction(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(AzureFirewallRCActionType_Allow, AzureFirewallRCActionType_Deny))
}

func Test_AzureFirewallSku_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFirewallSku to AzureFirewallSku via AssignProperties_To_AzureFirewallSku & AssignProperties_From_AzureFirewallSku returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFirewallSku, AzureFirewallSkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFirewallSku tests if a specific instance of AzureFirewallSku can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureFirewallSku(subject AzureFirewallSku) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AzureFirewallSku
	err := copied.AssignProperties_To_AzureFirewallSku(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFirewallSku
	err = actual.AssignProperties_From_AzureFirewallSku(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFirewallSku_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallSku via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallSku, AzureFirewallSkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallSku runs a test to see if a specific instance of AzureFirewallSku round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallSku(subject AzureFirewallSku) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallSku
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallSku instances for property testing - lazily instantiated by AzureFirewallSkuGenerator()
var azureFirewallSkuGenerator gopter.Gen

// AzureFirewallSkuGenerator returns a generator of AzureFirewallSku instances for property testing.
func AzureFirewallSkuGenerator() gopter.Gen {
	if azureFirewallSkuGenerator != nil {
		return azureFirewallSkuGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallSku(generators)
	azureFirewallSkuGenerator = gen.Struct(reflect.TypeOf(AzureFirewallSku{}), generators)

	return azureFirewallSkuGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallSku is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallSku(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(AzureFirewallSku_Name_AZFW_Hub, AzureFirewallSku_Name_AZFW_VNet))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(AzureFirewallSku_Tier_Basic, AzureFirewallSku_Tier_Premium, AzureFirewallSku_Tier_Standard))
}

func Test_AzureFirewallSku_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFirewallSku_STATUS to AzureFirewallSku_STATUS via AssignProperties_To_AzureFirewallSku_STATUS & AssignProperties_From_AzureFirewallSku_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFirewallSku_STATUS, AzureFirewallSku_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFirewallSku_STATUS tests if a specific instance of AzureFirewallSku_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureFirewallSku_STATUS(subject AzureFirewallSku_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AzureFirewallSku_STATUS
	err := copied.AssignProperties_To_AzureFirewallSku_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFirewallSku_STATUS
	err = actual.AssignProperties_From_AzureFirewallSku_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFirewallSku_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallSku_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallSku_STATUS, AzureFirewallSku_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallSku_STATUS runs a test to see if a specific instance of AzureFirewallSku_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallSku_STATUS(subject AzureFirewallSku_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallSku_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallSku_STATUS instances for property testing - lazily instantiated by
// AzureFirewallSku_STATUSGenerator()
var azureFirewallSku_STATUSGenerator gopter.Gen

// AzureFirewallSku_STATUSGenerator returns a generator of AzureFirewallSku_STATUS instances for property testing.
func AzureFirewallSku_STATUSGenerator() gopter.Gen {
	if azureFirewallSku_STATUSGenerator != nil {
		return azureFirewallSku_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallSku_STATUS(generators)
	azureFirewallSku_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureFirewallSku_STATUS{}), generators)

	return azureFirewallSku_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallSku_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallSku_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(AzureFirewallSku_Name_STATUS_AZFW_Hub, AzureFirewallSku_Name_STATUS_AZFW_VNet))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(AzureFirewallSku_Tier_STATUS_Basic, AzureFirewallSku_Tier_STATUS_Premium, AzureFirewallSku_Tier_STATUS_Standard))
}

func Test_AzureFirewall_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFirewall_STATUS to AzureFirewall_STATUS via AssignProperties_To_AzureFirewall_STATUS & AssignProperties_From_AzureFirewall_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFirewall_STATUS, AzureFirewall_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFirewall_STATUS tests if a specific instance of AzureFirewall_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureFirewall_STATUS(subject AzureFirewall_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AzureFirewall_STATUS
	err := copied.AssignProperties_To_AzureFirewall_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFirewall_STATUS
	err = actual.AssignProperties_From_AzureFirewall_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFirewall_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewall_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewall_STATUS, AzureFirewall_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewall_STATUS runs a test to see if a specific instance of AzureFirewall_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewall_STATUS(subject AzureFirewall_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewall_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewall_STATUS instances for property testing - lazily instantiated by
// AzureFirewall_STATUSGenerator()
var azureFirewall_STATUSGenerator gopter.Gen

// AzureFirewall_STATUSGenerator returns a generator of AzureFirewall_STATUS instances for property testing.
// We first initialize azureFirewall_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFirewall_STATUSGenerator() gopter.Gen {
	if azureFirewall_STATUSGenerator != nil {
		return azureFirewall_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewall_STATUS(generators)
	azureFirewall_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureFirewall_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewall_STATUS(generators)
	AddRelatedPropertyGeneratorsForAzureFirewall_STATUS(generators)
	azureFirewall_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureFirewall_STATUS{}), generators)

	return azureFirewall_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewall_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewall_STATUS(gens map[string]gopter.Gen) {
	gens["AdditionalProperties"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Updating))
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["ThreatIntelMode"] = gen.PtrOf(gen.OneConstOf(AzureFirewallThreatIntelMode_STATUS_Alert, AzureFirewallThreatIntelMode_STATUS_Deny, AzureFirewallThreatIntelMode_STATUS_Off))
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAzureFirewall_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFirewall_STATUS(gens map[string]gopter.Gen) {
	gens["ApplicationRuleCollections"] = gen.SliceOf(AzureFirewallApplicationRuleCollection_STATUSGenerator())
	gens["AutoscaleConfiguration"] = gen.PtrOf(AzureFirewallAutoscaleConfiguration_STATUSGenerator())
	gens["FirewallPolicy"] = gen.PtrOf(SubResource_STATUSGenerator())
	gens["HubIPAddresses"] = gen.PtrOf(HubIPAddresses_STATUSGenerator())
	gens["IpConfigurations"] = gen.SliceOf(AzureFirewallIPConfiguration_STATUSGenerator())
	gens["IpGroups"] = gen.SliceOf(AzureFirewallIpGroups_STATUSGenerator())
	gens["ManagementIpConfiguration"] = gen.PtrOf(AzureFirewallIPConfiguration_STATUSGenerator())
	gens["NatRuleCollections"] = gen.SliceOf(AzureFirewallNatRuleCollection_STATUSGenerator())
	gens["NetworkRuleCollections"] = gen.SliceOf(AzureFirewallNetworkRuleCollection_STATUSGenerator())
	gens["Sku"] = gen.PtrOf(AzureFirewallSku_STATUSGenerator())
	gens["VirtualHub"] = gen.PtrOf(SubResource_STATUSGenerator())
}

func Test_AzureFirewall_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFirewall_Spec to AzureFirewall_Spec via AssignProperties_To_AzureFirewall_Spec & AssignProperties_From_AzureFirewall_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFirewall_Spec, AzureFirewall_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFirewall_Spec tests if a specific instance of AzureFirewall_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureFirewall_Spec(subject AzureFirewall_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AzureFirewall_Spec
	err := copied.AssignProperties_To_AzureFirewall_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFirewall_Spec
	err = actual.AssignProperties_From_AzureFirewall_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFirewall_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewall_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewall_Spec, AzureFirewall_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewall_Spec runs a test to see if a specific instance of AzureFirewall_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewall_Spec(subject AzureFirewall_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewall_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewall_Spec instances for property testing - lazily instantiated by AzureFirewall_SpecGenerator()
var azureFirewall_SpecGenerator gopter.Gen

// AzureFirewall_SpecGenerator returns a generator of AzureFirewall_Spec instances for property testing.
// We first initialize azureFirewall_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFirewall_SpecGenerator() gopter.Gen {
	if azureFirewall_SpecGenerator != nil {
		return azureFirewall_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewall_Spec(generators)
	azureFirewall_SpecGenerator = gen.Struct(reflect.TypeOf(AzureFirewall_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewall_Spec(generators)
	AddRelatedPropertyGeneratorsForAzureFirewall_Spec(generators)
	azureFirewall_SpecGenerator = gen.Struct(reflect.TypeOf(AzureFirewall_Spec{}), generators)

	return azureFirewall_SpecGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewall_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewall_Spec(gens map[string]gopter.Gen) {
	gens["AdditionalProperties"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["ThreatIntelMode"] = gen.PtrOf(gen.OneConstOf(AzureFirewallThreatIntelMode_Alert, AzureFirewallThreatIntelMode_Deny, AzureFirewallThreatIntelMode_Off))
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAzureFirewall_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFirewall_Spec(gens map[string]gopter.Gen) {
	gens["ApplicationRuleCollections"] = gen.SliceOf(AzureFirewallApplicationRuleCollectionGenerator())
	gens["AutoscaleConfiguration"] = gen.PtrOf(AzureFirewallAutoscaleConfigurationGenerator())
	gens["FirewallPolicy"] = gen.PtrOf(SubResourceGenerator())
	gens["HubIPAddresses"] = gen.PtrOf(HubIPAddressesGenerator())
	gens["IpConfigurations"] = gen.SliceOf(AzureFirewallIPConfigurationGenerator())
	gens["ManagementIpConfiguration"] = gen.PtrOf(AzureFirewallIPConfigurationGenerator())
	gens["NatRuleCollections"] = gen.SliceOf(AzureFirewallNatRuleCollectionGenerator())
	gens["NetworkRuleCollections"] = gen.SliceOf(AzureFirewallNetworkRuleCollectionGenerator())
	gens["OperatorSpec"] = gen.PtrOf(AzureFirewallOperatorSpecGenerator())
	gens["Sku"] = gen.PtrOf(AzureFirewallSkuGenerator())
	gens["VirtualHub"] = gen.PtrOf(SubResourceGenerator())
}

func Test_HubIPAddresses_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HubIPAddresses to HubIPAddresses via AssignProperties_To_HubIPAddresses & AssignProperties_From_HubIPAddresses returns original",
		prop.ForAll(RunPropertyAssignmentTestForHubIPAddresses, HubIPAddressesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHubIPAddresses tests if a specific instance of HubIPAddresses can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForHubIPAddresses(subject HubIPAddresses) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.HubIPAddresses
	err := copied.AssignProperties_To_HubIPAddresses(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HubIPAddresses
	err = actual.AssignProperties_From_HubIPAddresses(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HubIPAddresses_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HubIPAddresses via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHubIPAddresses, HubIPAddressesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHubIPAddresses runs a test to see if a specific instance of HubIPAddresses round trips to JSON and back losslessly
func RunJSONSerializationTestForHubIPAddresses(subject HubIPAddresses) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HubIPAddresses
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HubIPAddresses instances for property testing - lazily instantiated by HubIPAddressesGenerator()
var hubIPAddressesGenerator gopter.Gen

// HubIPAddressesGenerator returns a generator of HubIPAddresses instances for property testing.
// We first initialize hubIPAddressesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HubIPAddressesGenerator() gopter.Gen {
	if hubIPAddressesGenerator != nil {
		return hubIPAddressesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHubIPAddresses(generators)
	hubIPAddressesGenerator = gen.Struct(reflect.TypeOf(HubIPAddresses{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHubIPAddresses(generators)
	AddRelatedPropertyGeneratorsForHubIPAddresses(generators)
	hubIPAddressesGenerator = gen.Struct(reflect.TypeOf(HubIPAddresses{}), generators)

	return hubIPAddressesGenerator
}

// AddIndependentPropertyGeneratorsForHubIPAddresses is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHubIPAddresses(gens map[string]gopter.Gen) {
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForHubIPAddresses is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHubIPAddresses(gens map[string]gopter.Gen) {
	gens["PublicIPs"] = gen.PtrOf(HubPublicIPAddressesGenerator())
}

func Test_HubIPAddresses_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HubIPAddresses_STATUS to HubIPAddresses_STATUS via AssignProperties_To_HubIPAddresses_STATUS & AssignProperties_From_HubIPAddresses_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForHubIPAddresses_STATUS, HubIPAddresses_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHubIPAddresses_STATUS tests if a specific instance of HubIPAddresses_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForHubIPAddresses_STATUS(subject HubIPAddresses_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.HubIPAddresses_STATUS
	err := copied.AssignProperties_To_HubIPAddresses_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HubIPAddresses_STATUS
	err = actual.AssignProperties_From_HubIPAddresses_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HubIPAddresses_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HubIPAddresses_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHubIPAddresses_STATUS, HubIPAddresses_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHubIPAddresses_STATUS runs a test to see if a specific instance of HubIPAddresses_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHubIPAddresses_STATUS(subject HubIPAddresses_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HubIPAddresses_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HubIPAddresses_STATUS instances for property testing - lazily instantiated by
// HubIPAddresses_STATUSGenerator()
var hubIPAddresses_STATUSGenerator gopter.Gen

// HubIPAddresses_STATUSGenerator returns a generator of HubIPAddresses_STATUS instances for property testing.
// We first initialize hubIPAddresses_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HubIPAddresses_STATUSGenerator() gopter.Gen {
	if hubIPAddresses_STATUSGenerator != nil {
		return hubIPAddresses_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHubIPAddresses_STATUS(generators)
	hubIPAddresses_STATUSGenerator = gen.Struct(reflect.TypeOf(HubIPAddresses_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHubIPAddresses_STATUS(generators)
	AddRelatedPropertyGeneratorsForHubIPAddresses_STATUS(generators)
	hubIPAddresses_STATUSGenerator = gen.Struct(reflect.TypeOf(HubIPAddresses_STATUS{}), generators)

	return hubIPAddresses_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForHubIPAddresses_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHubIPAddresses_STATUS(gens map[string]gopter.Gen) {
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForHubIPAddresses_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHubIPAddresses_STATUS(gens map[string]gopter.Gen) {
	gens["PublicIPs"] = gen.PtrOf(HubPublicIPAddresses_STATUSGenerator())
}

func Test_HubPublicIPAddresses_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HubPublicIPAddresses to HubPublicIPAddresses via AssignProperties_To_HubPublicIPAddresses & AssignProperties_From_HubPublicIPAddresses returns original",
		prop.ForAll(RunPropertyAssignmentTestForHubPublicIPAddresses, HubPublicIPAddressesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHubPublicIPAddresses tests if a specific instance of HubPublicIPAddresses can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForHubPublicIPAddresses(subject HubPublicIPAddresses) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.HubPublicIPAddresses
	err := copied.AssignProperties_To_HubPublicIPAddresses(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HubPublicIPAddresses
	err = actual.AssignProperties_From_HubPublicIPAddresses(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HubPublicIPAddresses_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HubPublicIPAddresses via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHubPublicIPAddresses, HubPublicIPAddressesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHubPublicIPAddresses runs a test to see if a specific instance of HubPublicIPAddresses round trips to JSON and back losslessly
func RunJSONSerializationTestForHubPublicIPAddresses(subject HubPublicIPAddresses) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HubPublicIPAddresses
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HubPublicIPAddresses instances for property testing - lazily instantiated by
// HubPublicIPAddressesGenerator()
var hubPublicIPAddressesGenerator gopter.Gen

// HubPublicIPAddressesGenerator returns a generator of HubPublicIPAddresses instances for property testing.
// We first initialize hubPublicIPAddressesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HubPublicIPAddressesGenerator() gopter.Gen {
	if hubPublicIPAddressesGenerator != nil {
		return hubPublicIPAddressesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHubPublicIPAddresses(generators)
	hubPublicIPAddressesGenerator = gen.Struct(reflect.TypeOf(HubPublicIPAddresses{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHubPublicIPAddresses(generators)
	AddRelatedPropertyGeneratorsForHubPublicIPAddresses(generators)
	hubPublicIPAddressesGenerator = gen.Struct(reflect.TypeOf(HubPublicIPAddresses{}), generators)

	return hubPublicIPAddressesGenerator
}

// AddIndependentPropertyGeneratorsForHubPublicIPAddresses is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHubPublicIPAddresses(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForHubPublicIPAddresses is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHubPublicIPAddresses(gens map[string]gopter.Gen) {
	gens["Addresses"] = gen.SliceOf(AzureFirewallPublicIPAddressGenerator())
}

func Test_HubPublicIPAddresses_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HubPublicIPAddresses_STATUS to HubPublicIPAddresses_STATUS via AssignProperties_To_HubPublicIPAddresses_STATUS & AssignProperties_From_HubPublicIPAddresses_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForHubPublicIPAddresses_STATUS, HubPublicIPAddresses_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHubPublicIPAddresses_STATUS tests if a specific instance of HubPublicIPAddresses_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForHubPublicIPAddresses_STATUS(subject HubPublicIPAddresses_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.HubPublicIPAddresses_STATUS
	err := copied.AssignProperties_To_HubPublicIPAddresses_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HubPublicIPAddresses_STATUS
	err = actual.AssignProperties_From_HubPublicIPAddresses_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HubPublicIPAddresses_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HubPublicIPAddresses_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHubPublicIPAddresses_STATUS, HubPublicIPAddresses_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHubPublicIPAddresses_STATUS runs a test to see if a specific instance of HubPublicIPAddresses_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHubPublicIPAddresses_STATUS(subject HubPublicIPAddresses_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HubPublicIPAddresses_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HubPublicIPAddresses_STATUS instances for property testing - lazily instantiated by
// HubPublicIPAddresses_STATUSGenerator()
var hubPublicIPAddresses_STATUSGenerator gopter.Gen

// HubPublicIPAddresses_STATUSGenerator returns a generator of HubPublicIPAddresses_STATUS instances for property testing.
// We first initialize hubPublicIPAddresses_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HubPublicIPAddresses_STATUSGenerator() gopter.Gen {
	if hubPublicIPAddresses_STATUSGenerator != nil {
		return hubPublicIPAddresses_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHubPublicIPAddresses_STATUS(generators)
	hubPublicIPAddresses_STATUSGenerator = gen.Struct(reflect.TypeOf(HubPublicIPAddresses_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHubPublicIPAddresses_STATUS(generators)
	AddRelatedPropertyGeneratorsForHubPublicIPAddresses_STATUS(generators)
	hubPublicIPAddresses_STATUSGenerator = gen.Struct(reflect.TypeOf(HubPublicIPAddresses_STATUS{}), generators)

	return hubPublicIPAddresses_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForHubPublicIPAddresses_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHubPublicIPAddresses_STATUS(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForHubPublicIPAddresses_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHubPublicIPAddresses_STATUS(gens map[string]gopter.Gen) {
	gens["Addresses"] = gen.SliceOf(AzureFirewallPublicIPAddress_STATUSGenerator())
}

func Test_SubResource_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SubResource to SubResource via AssignProperties_To_SubResource & AssignProperties_From_SubResource returns original",
		prop.ForAll(RunPropertyAssignmentTestForSubResource, SubResourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSubResource tests if a specific instance of SubResource can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSubResource(subject SubResource) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.SubResource
	err := copied.AssignProperties_To_SubResource(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SubResource
	err = actual.AssignProperties_From_SubResource(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SubResource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubResource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubResource, SubResourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubResource runs a test to see if a specific instance of SubResource round trips to JSON and back losslessly
func RunJSONSerializationTestForSubResource(subject SubResource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubResource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubResource instances for property testing - lazily instantiated by SubResourceGenerator()
var subResourceGenerator gopter.Gen

// SubResourceGenerator returns a generator of SubResource instances for property testing.
func SubResourceGenerator() gopter.Gen {
	if subResourceGenerator != nil {
		return subResourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	subResourceGenerator = gen.Struct(reflect.TypeOf(SubResource{}), generators)

	return subResourceGenerator
}

func Test_SubResource_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SubResource_STATUS to SubResource_STATUS via AssignProperties_To_SubResource_STATUS & AssignProperties_From_SubResource_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSubResource_STATUS, SubResource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSubResource_STATUS tests if a specific instance of SubResource_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSubResource_STATUS(subject SubResource_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.SubResource_STATUS
	err := copied.AssignProperties_To_SubResource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SubResource_STATUS
	err = actual.AssignProperties_From_SubResource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SubResource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubResource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubResource_STATUS, SubResource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubResource_STATUS runs a test to see if a specific instance of SubResource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSubResource_STATUS(subject SubResource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubResource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubResource_STATUS instances for property testing - lazily instantiated by SubResource_STATUSGenerator()
var subResource_STATUSGenerator gopter.Gen

// SubResource_STATUSGenerator returns a generator of SubResource_STATUS instances for property testing.
func SubResource_STATUSGenerator() gopter.Gen {
	if subResource_STATUSGenerator != nil {
		return subResource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubResource_STATUS(generators)
	subResource_STATUSGenerator = gen.Struct(reflect.TypeOf(SubResource_STATUS{}), generators)

	return subResource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSubResource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubResource_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}
