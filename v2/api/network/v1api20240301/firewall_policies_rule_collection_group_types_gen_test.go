// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240301

import (
	"encoding/json"
	storage "github.com/Azure/azure-service-operator/v2/api/network/v1api20240301/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ApplicationRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApplicationRule to ApplicationRule via AssignProperties_To_ApplicationRule & AssignProperties_From_ApplicationRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForApplicationRule, ApplicationRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApplicationRule tests if a specific instance of ApplicationRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForApplicationRule(subject ApplicationRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ApplicationRule
	err := copied.AssignProperties_To_ApplicationRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApplicationRule
	err = actual.AssignProperties_From_ApplicationRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApplicationRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationRule, ApplicationRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationRule runs a test to see if a specific instance of ApplicationRule round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationRule(subject ApplicationRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationRule instances for property testing - lazily instantiated by ApplicationRuleGenerator()
var applicationRuleGenerator gopter.Gen

// ApplicationRuleGenerator returns a generator of ApplicationRule instances for property testing.
// We first initialize applicationRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApplicationRuleGenerator() gopter.Gen {
	if applicationRuleGenerator != nil {
		return applicationRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationRule(generators)
	applicationRuleGenerator = gen.Struct(reflect.TypeOf(ApplicationRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationRule(generators)
	AddRelatedPropertyGeneratorsForApplicationRule(generators)
	applicationRuleGenerator = gen.Struct(reflect.TypeOf(ApplicationRule{}), generators)

	return applicationRuleGenerator
}

// AddIndependentPropertyGeneratorsForApplicationRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApplicationRule(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DestinationAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["FqdnTags"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["RuleType"] = gen.PtrOf(gen.OneConstOf(ApplicationRule_RuleType_ApplicationRule))
	gens["SourceAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["SourceIpGroups"] = gen.SliceOf(gen.AlphaString())
	gens["TargetFqdns"] = gen.SliceOf(gen.AlphaString())
	gens["TargetUrls"] = gen.SliceOf(gen.AlphaString())
	gens["TerminateTLS"] = gen.PtrOf(gen.Bool())
	gens["WebCategories"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForApplicationRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApplicationRule(gens map[string]gopter.Gen) {
	gens["HttpHeadersToInsert"] = gen.SliceOf(FirewallPolicyHttpHeaderToInsertGenerator())
	gens["Protocols"] = gen.SliceOf(FirewallPolicyRuleApplicationProtocolGenerator())
}

func Test_ApplicationRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApplicationRule_STATUS to ApplicationRule_STATUS via AssignProperties_To_ApplicationRule_STATUS & AssignProperties_From_ApplicationRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForApplicationRule_STATUS, ApplicationRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApplicationRule_STATUS tests if a specific instance of ApplicationRule_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForApplicationRule_STATUS(subject ApplicationRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ApplicationRule_STATUS
	err := copied.AssignProperties_To_ApplicationRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApplicationRule_STATUS
	err = actual.AssignProperties_From_ApplicationRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApplicationRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationRule_STATUS, ApplicationRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationRule_STATUS runs a test to see if a specific instance of ApplicationRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationRule_STATUS(subject ApplicationRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationRule_STATUS instances for property testing - lazily instantiated by
// ApplicationRule_STATUSGenerator()
var applicationRule_STATUSGenerator gopter.Gen

// ApplicationRule_STATUSGenerator returns a generator of ApplicationRule_STATUS instances for property testing.
// We first initialize applicationRule_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApplicationRule_STATUSGenerator() gopter.Gen {
	if applicationRule_STATUSGenerator != nil {
		return applicationRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationRule_STATUS(generators)
	applicationRule_STATUSGenerator = gen.Struct(reflect.TypeOf(ApplicationRule_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationRule_STATUS(generators)
	AddRelatedPropertyGeneratorsForApplicationRule_STATUS(generators)
	applicationRule_STATUSGenerator = gen.Struct(reflect.TypeOf(ApplicationRule_STATUS{}), generators)

	return applicationRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForApplicationRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApplicationRule_STATUS(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DestinationAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["FqdnTags"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["RuleType"] = gen.PtrOf(gen.OneConstOf(ApplicationRule_RuleType_STATUS_ApplicationRule))
	gens["SourceAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["SourceIpGroups"] = gen.SliceOf(gen.AlphaString())
	gens["TargetFqdns"] = gen.SliceOf(gen.AlphaString())
	gens["TargetUrls"] = gen.SliceOf(gen.AlphaString())
	gens["TerminateTLS"] = gen.PtrOf(gen.Bool())
	gens["WebCategories"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForApplicationRule_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApplicationRule_STATUS(gens map[string]gopter.Gen) {
	gens["HttpHeadersToInsert"] = gen.SliceOf(FirewallPolicyHttpHeaderToInsert_STATUSGenerator())
	gens["Protocols"] = gen.SliceOf(FirewallPolicyRuleApplicationProtocol_STATUSGenerator())
}

func Test_FirewallPoliciesRuleCollectionGroup_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPoliciesRuleCollectionGroup to hub returns original",
		prop.ForAll(RunResourceConversionTestForFirewallPoliciesRuleCollectionGroup, FirewallPoliciesRuleCollectionGroupGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForFirewallPoliciesRuleCollectionGroup tests if a specific instance of FirewallPoliciesRuleCollectionGroup round trips to the hub storage version and back losslessly
func RunResourceConversionTestForFirewallPoliciesRuleCollectionGroup(subject FirewallPoliciesRuleCollectionGroup) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub storage.FirewallPoliciesRuleCollectionGroup
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual FirewallPoliciesRuleCollectionGroup
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPoliciesRuleCollectionGroup_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPoliciesRuleCollectionGroup to FirewallPoliciesRuleCollectionGroup via AssignProperties_To_FirewallPoliciesRuleCollectionGroup & AssignProperties_From_FirewallPoliciesRuleCollectionGroup returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPoliciesRuleCollectionGroup, FirewallPoliciesRuleCollectionGroupGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPoliciesRuleCollectionGroup tests if a specific instance of FirewallPoliciesRuleCollectionGroup can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPoliciesRuleCollectionGroup(subject FirewallPoliciesRuleCollectionGroup) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPoliciesRuleCollectionGroup
	err := copied.AssignProperties_To_FirewallPoliciesRuleCollectionGroup(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPoliciesRuleCollectionGroup
	err = actual.AssignProperties_From_FirewallPoliciesRuleCollectionGroup(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPoliciesRuleCollectionGroup_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPoliciesRuleCollectionGroup via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPoliciesRuleCollectionGroup, FirewallPoliciesRuleCollectionGroupGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPoliciesRuleCollectionGroup runs a test to see if a specific instance of FirewallPoliciesRuleCollectionGroup round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPoliciesRuleCollectionGroup(subject FirewallPoliciesRuleCollectionGroup) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPoliciesRuleCollectionGroup
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPoliciesRuleCollectionGroup instances for property testing - lazily instantiated by
// FirewallPoliciesRuleCollectionGroupGenerator()
var firewallPoliciesRuleCollectionGroupGenerator gopter.Gen

// FirewallPoliciesRuleCollectionGroupGenerator returns a generator of FirewallPoliciesRuleCollectionGroup instances for property testing.
func FirewallPoliciesRuleCollectionGroupGenerator() gopter.Gen {
	if firewallPoliciesRuleCollectionGroupGenerator != nil {
		return firewallPoliciesRuleCollectionGroupGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup(generators)
	firewallPoliciesRuleCollectionGroupGenerator = gen.Struct(reflect.TypeOf(FirewallPoliciesRuleCollectionGroup{}), generators)

	return firewallPoliciesRuleCollectionGroupGenerator
}

// AddRelatedPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup(gens map[string]gopter.Gen) {
	gens["Spec"] = FirewallPoliciesRuleCollectionGroup_SpecGenerator()
	gens["Status"] = FirewallPoliciesRuleCollectionGroup_STATUSGenerator()
}

func Test_FirewallPoliciesRuleCollectionGroupOperatorSpec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPoliciesRuleCollectionGroupOperatorSpec to FirewallPoliciesRuleCollectionGroupOperatorSpec via AssignProperties_To_FirewallPoliciesRuleCollectionGroupOperatorSpec & AssignProperties_From_FirewallPoliciesRuleCollectionGroupOperatorSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPoliciesRuleCollectionGroupOperatorSpec, FirewallPoliciesRuleCollectionGroupOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPoliciesRuleCollectionGroupOperatorSpec tests if a specific instance of FirewallPoliciesRuleCollectionGroupOperatorSpec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPoliciesRuleCollectionGroupOperatorSpec(subject FirewallPoliciesRuleCollectionGroupOperatorSpec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPoliciesRuleCollectionGroupOperatorSpec
	err := copied.AssignProperties_To_FirewallPoliciesRuleCollectionGroupOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPoliciesRuleCollectionGroupOperatorSpec
	err = actual.AssignProperties_From_FirewallPoliciesRuleCollectionGroupOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPoliciesRuleCollectionGroupOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPoliciesRuleCollectionGroupOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPoliciesRuleCollectionGroupOperatorSpec, FirewallPoliciesRuleCollectionGroupOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPoliciesRuleCollectionGroupOperatorSpec runs a test to see if a specific instance of FirewallPoliciesRuleCollectionGroupOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPoliciesRuleCollectionGroupOperatorSpec(subject FirewallPoliciesRuleCollectionGroupOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPoliciesRuleCollectionGroupOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPoliciesRuleCollectionGroupOperatorSpec instances for property testing - lazily instantiated by
// FirewallPoliciesRuleCollectionGroupOperatorSpecGenerator()
var firewallPoliciesRuleCollectionGroupOperatorSpecGenerator gopter.Gen

// FirewallPoliciesRuleCollectionGroupOperatorSpecGenerator returns a generator of FirewallPoliciesRuleCollectionGroupOperatorSpec instances for property testing.
func FirewallPoliciesRuleCollectionGroupOperatorSpecGenerator() gopter.Gen {
	if firewallPoliciesRuleCollectionGroupOperatorSpecGenerator != nil {
		return firewallPoliciesRuleCollectionGroupOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	firewallPoliciesRuleCollectionGroupOperatorSpecGenerator = gen.Struct(reflect.TypeOf(FirewallPoliciesRuleCollectionGroupOperatorSpec{}), generators)

	return firewallPoliciesRuleCollectionGroupOperatorSpecGenerator
}

func Test_FirewallPoliciesRuleCollectionGroup_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPoliciesRuleCollectionGroup_STATUS to FirewallPoliciesRuleCollectionGroup_STATUS via AssignProperties_To_FirewallPoliciesRuleCollectionGroup_STATUS & AssignProperties_From_FirewallPoliciesRuleCollectionGroup_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPoliciesRuleCollectionGroup_STATUS, FirewallPoliciesRuleCollectionGroup_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPoliciesRuleCollectionGroup_STATUS tests if a specific instance of FirewallPoliciesRuleCollectionGroup_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPoliciesRuleCollectionGroup_STATUS(subject FirewallPoliciesRuleCollectionGroup_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPoliciesRuleCollectionGroup_STATUS
	err := copied.AssignProperties_To_FirewallPoliciesRuleCollectionGroup_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPoliciesRuleCollectionGroup_STATUS
	err = actual.AssignProperties_From_FirewallPoliciesRuleCollectionGroup_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPoliciesRuleCollectionGroup_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPoliciesRuleCollectionGroup_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPoliciesRuleCollectionGroup_STATUS, FirewallPoliciesRuleCollectionGroup_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPoliciesRuleCollectionGroup_STATUS runs a test to see if a specific instance of FirewallPoliciesRuleCollectionGroup_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPoliciesRuleCollectionGroup_STATUS(subject FirewallPoliciesRuleCollectionGroup_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPoliciesRuleCollectionGroup_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPoliciesRuleCollectionGroup_STATUS instances for property testing - lazily instantiated by
// FirewallPoliciesRuleCollectionGroup_STATUSGenerator()
var firewallPoliciesRuleCollectionGroup_STATUSGenerator gopter.Gen

// FirewallPoliciesRuleCollectionGroup_STATUSGenerator returns a generator of FirewallPoliciesRuleCollectionGroup_STATUS instances for property testing.
// We first initialize firewallPoliciesRuleCollectionGroup_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPoliciesRuleCollectionGroup_STATUSGenerator() gopter.Gen {
	if firewallPoliciesRuleCollectionGroup_STATUSGenerator != nil {
		return firewallPoliciesRuleCollectionGroup_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup_STATUS(generators)
	firewallPoliciesRuleCollectionGroup_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPoliciesRuleCollectionGroup_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup_STATUS(generators)
	AddRelatedPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup_STATUS(generators)
	firewallPoliciesRuleCollectionGroup_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPoliciesRuleCollectionGroup_STATUS{}), generators)

	return firewallPoliciesRuleCollectionGroup_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup_STATUS(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Updating))
	gens["Size"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup_STATUS(gens map[string]gopter.Gen) {
	gens["RuleCollections"] = gen.SliceOf(FirewallPolicyRuleCollection_STATUSGenerator())
}

func Test_FirewallPoliciesRuleCollectionGroup_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPoliciesRuleCollectionGroup_Spec to FirewallPoliciesRuleCollectionGroup_Spec via AssignProperties_To_FirewallPoliciesRuleCollectionGroup_Spec & AssignProperties_From_FirewallPoliciesRuleCollectionGroup_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPoliciesRuleCollectionGroup_Spec, FirewallPoliciesRuleCollectionGroup_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPoliciesRuleCollectionGroup_Spec tests if a specific instance of FirewallPoliciesRuleCollectionGroup_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPoliciesRuleCollectionGroup_Spec(subject FirewallPoliciesRuleCollectionGroup_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPoliciesRuleCollectionGroup_Spec
	err := copied.AssignProperties_To_FirewallPoliciesRuleCollectionGroup_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPoliciesRuleCollectionGroup_Spec
	err = actual.AssignProperties_From_FirewallPoliciesRuleCollectionGroup_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPoliciesRuleCollectionGroup_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPoliciesRuleCollectionGroup_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPoliciesRuleCollectionGroup_Spec, FirewallPoliciesRuleCollectionGroup_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPoliciesRuleCollectionGroup_Spec runs a test to see if a specific instance of FirewallPoliciesRuleCollectionGroup_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPoliciesRuleCollectionGroup_Spec(subject FirewallPoliciesRuleCollectionGroup_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPoliciesRuleCollectionGroup_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPoliciesRuleCollectionGroup_Spec instances for property testing - lazily instantiated by
// FirewallPoliciesRuleCollectionGroup_SpecGenerator()
var firewallPoliciesRuleCollectionGroup_SpecGenerator gopter.Gen

// FirewallPoliciesRuleCollectionGroup_SpecGenerator returns a generator of FirewallPoliciesRuleCollectionGroup_Spec instances for property testing.
// We first initialize firewallPoliciesRuleCollectionGroup_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPoliciesRuleCollectionGroup_SpecGenerator() gopter.Gen {
	if firewallPoliciesRuleCollectionGroup_SpecGenerator != nil {
		return firewallPoliciesRuleCollectionGroup_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup_Spec(generators)
	firewallPoliciesRuleCollectionGroup_SpecGenerator = gen.Struct(reflect.TypeOf(FirewallPoliciesRuleCollectionGroup_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup_Spec(generators)
	AddRelatedPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup_Spec(generators)
	firewallPoliciesRuleCollectionGroup_SpecGenerator = gen.Struct(reflect.TypeOf(FirewallPoliciesRuleCollectionGroup_Spec{}), generators)

	return firewallPoliciesRuleCollectionGroup_SpecGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Priority"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup_Spec(gens map[string]gopter.Gen) {
	gens["OperatorSpec"] = gen.PtrOf(FirewallPoliciesRuleCollectionGroupOperatorSpecGenerator())
	gens["RuleCollections"] = gen.SliceOf(FirewallPolicyRuleCollectionGenerator())
}

func Test_FirewallPolicyFilterRuleCollection_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyFilterRuleCollection to FirewallPolicyFilterRuleCollection via AssignProperties_To_FirewallPolicyFilterRuleCollection & AssignProperties_From_FirewallPolicyFilterRuleCollection returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyFilterRuleCollection, FirewallPolicyFilterRuleCollectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyFilterRuleCollection tests if a specific instance of FirewallPolicyFilterRuleCollection can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyFilterRuleCollection(subject FirewallPolicyFilterRuleCollection) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyFilterRuleCollection
	err := copied.AssignProperties_To_FirewallPolicyFilterRuleCollection(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyFilterRuleCollection
	err = actual.AssignProperties_From_FirewallPolicyFilterRuleCollection(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyFilterRuleCollection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyFilterRuleCollection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyFilterRuleCollection, FirewallPolicyFilterRuleCollectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyFilterRuleCollection runs a test to see if a specific instance of FirewallPolicyFilterRuleCollection round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyFilterRuleCollection(subject FirewallPolicyFilterRuleCollection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyFilterRuleCollection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyFilterRuleCollection instances for property testing - lazily instantiated by
// FirewallPolicyFilterRuleCollectionGenerator()
var firewallPolicyFilterRuleCollectionGenerator gopter.Gen

// FirewallPolicyFilterRuleCollectionGenerator returns a generator of FirewallPolicyFilterRuleCollection instances for property testing.
// We first initialize firewallPolicyFilterRuleCollectionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyFilterRuleCollectionGenerator() gopter.Gen {
	if firewallPolicyFilterRuleCollectionGenerator != nil {
		return firewallPolicyFilterRuleCollectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyFilterRuleCollection(generators)
	firewallPolicyFilterRuleCollectionGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyFilterRuleCollection{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyFilterRuleCollection(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyFilterRuleCollection(generators)
	firewallPolicyFilterRuleCollectionGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyFilterRuleCollection{}), generators)

	return firewallPolicyFilterRuleCollectionGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyFilterRuleCollection is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyFilterRuleCollection(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["RuleCollectionType"] = gen.PtrOf(gen.OneConstOf(FirewallPolicyFilterRuleCollection_RuleCollectionType_FirewallPolicyFilterRuleCollection))
}

// AddRelatedPropertyGeneratorsForFirewallPolicyFilterRuleCollection is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyFilterRuleCollection(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(FirewallPolicyFilterRuleCollectionActionGenerator())
	gens["Rules"] = gen.SliceOf(FirewallPolicyRuleGenerator())
}

func Test_FirewallPolicyFilterRuleCollectionAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyFilterRuleCollectionAction to FirewallPolicyFilterRuleCollectionAction via AssignProperties_To_FirewallPolicyFilterRuleCollectionAction & AssignProperties_From_FirewallPolicyFilterRuleCollectionAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyFilterRuleCollectionAction, FirewallPolicyFilterRuleCollectionActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyFilterRuleCollectionAction tests if a specific instance of FirewallPolicyFilterRuleCollectionAction can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyFilterRuleCollectionAction(subject FirewallPolicyFilterRuleCollectionAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyFilterRuleCollectionAction
	err := copied.AssignProperties_To_FirewallPolicyFilterRuleCollectionAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyFilterRuleCollectionAction
	err = actual.AssignProperties_From_FirewallPolicyFilterRuleCollectionAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyFilterRuleCollectionAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyFilterRuleCollectionAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyFilterRuleCollectionAction, FirewallPolicyFilterRuleCollectionActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyFilterRuleCollectionAction runs a test to see if a specific instance of FirewallPolicyFilterRuleCollectionAction round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyFilterRuleCollectionAction(subject FirewallPolicyFilterRuleCollectionAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyFilterRuleCollectionAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyFilterRuleCollectionAction instances for property testing - lazily instantiated by
// FirewallPolicyFilterRuleCollectionActionGenerator()
var firewallPolicyFilterRuleCollectionActionGenerator gopter.Gen

// FirewallPolicyFilterRuleCollectionActionGenerator returns a generator of FirewallPolicyFilterRuleCollectionAction instances for property testing.
func FirewallPolicyFilterRuleCollectionActionGenerator() gopter.Gen {
	if firewallPolicyFilterRuleCollectionActionGenerator != nil {
		return firewallPolicyFilterRuleCollectionActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyFilterRuleCollectionAction(generators)
	firewallPolicyFilterRuleCollectionActionGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyFilterRuleCollectionAction{}), generators)

	return firewallPolicyFilterRuleCollectionActionGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyFilterRuleCollectionAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyFilterRuleCollectionAction(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(FirewallPolicyFilterRuleCollectionActionType_Allow, FirewallPolicyFilterRuleCollectionActionType_Deny))
}

func Test_FirewallPolicyFilterRuleCollectionAction_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyFilterRuleCollectionAction_STATUS to FirewallPolicyFilterRuleCollectionAction_STATUS via AssignProperties_To_FirewallPolicyFilterRuleCollectionAction_STATUS & AssignProperties_From_FirewallPolicyFilterRuleCollectionAction_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyFilterRuleCollectionAction_STATUS, FirewallPolicyFilterRuleCollectionAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyFilterRuleCollectionAction_STATUS tests if a specific instance of FirewallPolicyFilterRuleCollectionAction_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyFilterRuleCollectionAction_STATUS(subject FirewallPolicyFilterRuleCollectionAction_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyFilterRuleCollectionAction_STATUS
	err := copied.AssignProperties_To_FirewallPolicyFilterRuleCollectionAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyFilterRuleCollectionAction_STATUS
	err = actual.AssignProperties_From_FirewallPolicyFilterRuleCollectionAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyFilterRuleCollectionAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyFilterRuleCollectionAction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyFilterRuleCollectionAction_STATUS, FirewallPolicyFilterRuleCollectionAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyFilterRuleCollectionAction_STATUS runs a test to see if a specific instance of FirewallPolicyFilterRuleCollectionAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyFilterRuleCollectionAction_STATUS(subject FirewallPolicyFilterRuleCollectionAction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyFilterRuleCollectionAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyFilterRuleCollectionAction_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyFilterRuleCollectionAction_STATUSGenerator()
var firewallPolicyFilterRuleCollectionAction_STATUSGenerator gopter.Gen

// FirewallPolicyFilterRuleCollectionAction_STATUSGenerator returns a generator of FirewallPolicyFilterRuleCollectionAction_STATUS instances for property testing.
func FirewallPolicyFilterRuleCollectionAction_STATUSGenerator() gopter.Gen {
	if firewallPolicyFilterRuleCollectionAction_STATUSGenerator != nil {
		return firewallPolicyFilterRuleCollectionAction_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyFilterRuleCollectionAction_STATUS(generators)
	firewallPolicyFilterRuleCollectionAction_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyFilterRuleCollectionAction_STATUS{}), generators)

	return firewallPolicyFilterRuleCollectionAction_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyFilterRuleCollectionAction_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyFilterRuleCollectionAction_STATUS(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(FirewallPolicyFilterRuleCollectionActionType_STATUS_Allow, FirewallPolicyFilterRuleCollectionActionType_STATUS_Deny))
}

func Test_FirewallPolicyFilterRuleCollection_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyFilterRuleCollection_STATUS to FirewallPolicyFilterRuleCollection_STATUS via AssignProperties_To_FirewallPolicyFilterRuleCollection_STATUS & AssignProperties_From_FirewallPolicyFilterRuleCollection_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyFilterRuleCollection_STATUS, FirewallPolicyFilterRuleCollection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyFilterRuleCollection_STATUS tests if a specific instance of FirewallPolicyFilterRuleCollection_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyFilterRuleCollection_STATUS(subject FirewallPolicyFilterRuleCollection_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyFilterRuleCollection_STATUS
	err := copied.AssignProperties_To_FirewallPolicyFilterRuleCollection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyFilterRuleCollection_STATUS
	err = actual.AssignProperties_From_FirewallPolicyFilterRuleCollection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyFilterRuleCollection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyFilterRuleCollection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyFilterRuleCollection_STATUS, FirewallPolicyFilterRuleCollection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyFilterRuleCollection_STATUS runs a test to see if a specific instance of FirewallPolicyFilterRuleCollection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyFilterRuleCollection_STATUS(subject FirewallPolicyFilterRuleCollection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyFilterRuleCollection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyFilterRuleCollection_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyFilterRuleCollection_STATUSGenerator()
var firewallPolicyFilterRuleCollection_STATUSGenerator gopter.Gen

// FirewallPolicyFilterRuleCollection_STATUSGenerator returns a generator of FirewallPolicyFilterRuleCollection_STATUS instances for property testing.
// We first initialize firewallPolicyFilterRuleCollection_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyFilterRuleCollection_STATUSGenerator() gopter.Gen {
	if firewallPolicyFilterRuleCollection_STATUSGenerator != nil {
		return firewallPolicyFilterRuleCollection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyFilterRuleCollection_STATUS(generators)
	firewallPolicyFilterRuleCollection_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyFilterRuleCollection_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyFilterRuleCollection_STATUS(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyFilterRuleCollection_STATUS(generators)
	firewallPolicyFilterRuleCollection_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyFilterRuleCollection_STATUS{}), generators)

	return firewallPolicyFilterRuleCollection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyFilterRuleCollection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyFilterRuleCollection_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["RuleCollectionType"] = gen.PtrOf(gen.OneConstOf(FirewallPolicyFilterRuleCollection_RuleCollectionType_STATUS_FirewallPolicyFilterRuleCollection))
}

// AddRelatedPropertyGeneratorsForFirewallPolicyFilterRuleCollection_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyFilterRuleCollection_STATUS(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(FirewallPolicyFilterRuleCollectionAction_STATUSGenerator())
	gens["Rules"] = gen.SliceOf(FirewallPolicyRule_STATUSGenerator())
}

func Test_FirewallPolicyHttpHeaderToInsert_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyHttpHeaderToInsert to FirewallPolicyHttpHeaderToInsert via AssignProperties_To_FirewallPolicyHttpHeaderToInsert & AssignProperties_From_FirewallPolicyHttpHeaderToInsert returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyHttpHeaderToInsert, FirewallPolicyHttpHeaderToInsertGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyHttpHeaderToInsert tests if a specific instance of FirewallPolicyHttpHeaderToInsert can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyHttpHeaderToInsert(subject FirewallPolicyHttpHeaderToInsert) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyHttpHeaderToInsert
	err := copied.AssignProperties_To_FirewallPolicyHttpHeaderToInsert(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyHttpHeaderToInsert
	err = actual.AssignProperties_From_FirewallPolicyHttpHeaderToInsert(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyHttpHeaderToInsert_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyHttpHeaderToInsert via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyHttpHeaderToInsert, FirewallPolicyHttpHeaderToInsertGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyHttpHeaderToInsert runs a test to see if a specific instance of FirewallPolicyHttpHeaderToInsert round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyHttpHeaderToInsert(subject FirewallPolicyHttpHeaderToInsert) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyHttpHeaderToInsert
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyHttpHeaderToInsert instances for property testing - lazily instantiated by
// FirewallPolicyHttpHeaderToInsertGenerator()
var firewallPolicyHttpHeaderToInsertGenerator gopter.Gen

// FirewallPolicyHttpHeaderToInsertGenerator returns a generator of FirewallPolicyHttpHeaderToInsert instances for property testing.
func FirewallPolicyHttpHeaderToInsertGenerator() gopter.Gen {
	if firewallPolicyHttpHeaderToInsertGenerator != nil {
		return firewallPolicyHttpHeaderToInsertGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyHttpHeaderToInsert(generators)
	firewallPolicyHttpHeaderToInsertGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyHttpHeaderToInsert{}), generators)

	return firewallPolicyHttpHeaderToInsertGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyHttpHeaderToInsert is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyHttpHeaderToInsert(gens map[string]gopter.Gen) {
	gens["HeaderName"] = gen.PtrOf(gen.AlphaString())
	gens["HeaderValue"] = gen.PtrOf(gen.AlphaString())
}

func Test_FirewallPolicyHttpHeaderToInsert_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyHttpHeaderToInsert_STATUS to FirewallPolicyHttpHeaderToInsert_STATUS via AssignProperties_To_FirewallPolicyHttpHeaderToInsert_STATUS & AssignProperties_From_FirewallPolicyHttpHeaderToInsert_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyHttpHeaderToInsert_STATUS, FirewallPolicyHttpHeaderToInsert_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyHttpHeaderToInsert_STATUS tests if a specific instance of FirewallPolicyHttpHeaderToInsert_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyHttpHeaderToInsert_STATUS(subject FirewallPolicyHttpHeaderToInsert_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyHttpHeaderToInsert_STATUS
	err := copied.AssignProperties_To_FirewallPolicyHttpHeaderToInsert_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyHttpHeaderToInsert_STATUS
	err = actual.AssignProperties_From_FirewallPolicyHttpHeaderToInsert_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyHttpHeaderToInsert_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyHttpHeaderToInsert_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyHttpHeaderToInsert_STATUS, FirewallPolicyHttpHeaderToInsert_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyHttpHeaderToInsert_STATUS runs a test to see if a specific instance of FirewallPolicyHttpHeaderToInsert_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyHttpHeaderToInsert_STATUS(subject FirewallPolicyHttpHeaderToInsert_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyHttpHeaderToInsert_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyHttpHeaderToInsert_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyHttpHeaderToInsert_STATUSGenerator()
var firewallPolicyHttpHeaderToInsert_STATUSGenerator gopter.Gen

// FirewallPolicyHttpHeaderToInsert_STATUSGenerator returns a generator of FirewallPolicyHttpHeaderToInsert_STATUS instances for property testing.
func FirewallPolicyHttpHeaderToInsert_STATUSGenerator() gopter.Gen {
	if firewallPolicyHttpHeaderToInsert_STATUSGenerator != nil {
		return firewallPolicyHttpHeaderToInsert_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyHttpHeaderToInsert_STATUS(generators)
	firewallPolicyHttpHeaderToInsert_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyHttpHeaderToInsert_STATUS{}), generators)

	return firewallPolicyHttpHeaderToInsert_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyHttpHeaderToInsert_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyHttpHeaderToInsert_STATUS(gens map[string]gopter.Gen) {
	gens["HeaderName"] = gen.PtrOf(gen.AlphaString())
	gens["HeaderValue"] = gen.PtrOf(gen.AlphaString())
}

func Test_FirewallPolicyNatRuleCollection_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyNatRuleCollection to FirewallPolicyNatRuleCollection via AssignProperties_To_FirewallPolicyNatRuleCollection & AssignProperties_From_FirewallPolicyNatRuleCollection returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyNatRuleCollection, FirewallPolicyNatRuleCollectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyNatRuleCollection tests if a specific instance of FirewallPolicyNatRuleCollection can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyNatRuleCollection(subject FirewallPolicyNatRuleCollection) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyNatRuleCollection
	err := copied.AssignProperties_To_FirewallPolicyNatRuleCollection(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyNatRuleCollection
	err = actual.AssignProperties_From_FirewallPolicyNatRuleCollection(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyNatRuleCollection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyNatRuleCollection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyNatRuleCollection, FirewallPolicyNatRuleCollectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyNatRuleCollection runs a test to see if a specific instance of FirewallPolicyNatRuleCollection round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyNatRuleCollection(subject FirewallPolicyNatRuleCollection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyNatRuleCollection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyNatRuleCollection instances for property testing - lazily instantiated by
// FirewallPolicyNatRuleCollectionGenerator()
var firewallPolicyNatRuleCollectionGenerator gopter.Gen

// FirewallPolicyNatRuleCollectionGenerator returns a generator of FirewallPolicyNatRuleCollection instances for property testing.
// We first initialize firewallPolicyNatRuleCollectionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyNatRuleCollectionGenerator() gopter.Gen {
	if firewallPolicyNatRuleCollectionGenerator != nil {
		return firewallPolicyNatRuleCollectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyNatRuleCollection(generators)
	firewallPolicyNatRuleCollectionGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyNatRuleCollection{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyNatRuleCollection(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyNatRuleCollection(generators)
	firewallPolicyNatRuleCollectionGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyNatRuleCollection{}), generators)

	return firewallPolicyNatRuleCollectionGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyNatRuleCollection is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyNatRuleCollection(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["RuleCollectionType"] = gen.PtrOf(gen.OneConstOf(FirewallPolicyNatRuleCollection_RuleCollectionType_FirewallPolicyNatRuleCollection))
}

// AddRelatedPropertyGeneratorsForFirewallPolicyNatRuleCollection is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyNatRuleCollection(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(FirewallPolicyNatRuleCollectionActionGenerator())
	gens["Rules"] = gen.SliceOf(FirewallPolicyRuleGenerator())
}

func Test_FirewallPolicyNatRuleCollectionAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyNatRuleCollectionAction to FirewallPolicyNatRuleCollectionAction via AssignProperties_To_FirewallPolicyNatRuleCollectionAction & AssignProperties_From_FirewallPolicyNatRuleCollectionAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyNatRuleCollectionAction, FirewallPolicyNatRuleCollectionActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyNatRuleCollectionAction tests if a specific instance of FirewallPolicyNatRuleCollectionAction can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyNatRuleCollectionAction(subject FirewallPolicyNatRuleCollectionAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyNatRuleCollectionAction
	err := copied.AssignProperties_To_FirewallPolicyNatRuleCollectionAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyNatRuleCollectionAction
	err = actual.AssignProperties_From_FirewallPolicyNatRuleCollectionAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyNatRuleCollectionAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyNatRuleCollectionAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyNatRuleCollectionAction, FirewallPolicyNatRuleCollectionActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyNatRuleCollectionAction runs a test to see if a specific instance of FirewallPolicyNatRuleCollectionAction round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyNatRuleCollectionAction(subject FirewallPolicyNatRuleCollectionAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyNatRuleCollectionAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyNatRuleCollectionAction instances for property testing - lazily instantiated by
// FirewallPolicyNatRuleCollectionActionGenerator()
var firewallPolicyNatRuleCollectionActionGenerator gopter.Gen

// FirewallPolicyNatRuleCollectionActionGenerator returns a generator of FirewallPolicyNatRuleCollectionAction instances for property testing.
func FirewallPolicyNatRuleCollectionActionGenerator() gopter.Gen {
	if firewallPolicyNatRuleCollectionActionGenerator != nil {
		return firewallPolicyNatRuleCollectionActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyNatRuleCollectionAction(generators)
	firewallPolicyNatRuleCollectionActionGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyNatRuleCollectionAction{}), generators)

	return firewallPolicyNatRuleCollectionActionGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyNatRuleCollectionAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyNatRuleCollectionAction(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(FirewallPolicyNatRuleCollectionActionType_DNAT))
}

func Test_FirewallPolicyNatRuleCollectionAction_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyNatRuleCollectionAction_STATUS to FirewallPolicyNatRuleCollectionAction_STATUS via AssignProperties_To_FirewallPolicyNatRuleCollectionAction_STATUS & AssignProperties_From_FirewallPolicyNatRuleCollectionAction_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyNatRuleCollectionAction_STATUS, FirewallPolicyNatRuleCollectionAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyNatRuleCollectionAction_STATUS tests if a specific instance of FirewallPolicyNatRuleCollectionAction_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyNatRuleCollectionAction_STATUS(subject FirewallPolicyNatRuleCollectionAction_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyNatRuleCollectionAction_STATUS
	err := copied.AssignProperties_To_FirewallPolicyNatRuleCollectionAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyNatRuleCollectionAction_STATUS
	err = actual.AssignProperties_From_FirewallPolicyNatRuleCollectionAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyNatRuleCollectionAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyNatRuleCollectionAction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyNatRuleCollectionAction_STATUS, FirewallPolicyNatRuleCollectionAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyNatRuleCollectionAction_STATUS runs a test to see if a specific instance of FirewallPolicyNatRuleCollectionAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyNatRuleCollectionAction_STATUS(subject FirewallPolicyNatRuleCollectionAction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyNatRuleCollectionAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyNatRuleCollectionAction_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyNatRuleCollectionAction_STATUSGenerator()
var firewallPolicyNatRuleCollectionAction_STATUSGenerator gopter.Gen

// FirewallPolicyNatRuleCollectionAction_STATUSGenerator returns a generator of FirewallPolicyNatRuleCollectionAction_STATUS instances for property testing.
func FirewallPolicyNatRuleCollectionAction_STATUSGenerator() gopter.Gen {
	if firewallPolicyNatRuleCollectionAction_STATUSGenerator != nil {
		return firewallPolicyNatRuleCollectionAction_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyNatRuleCollectionAction_STATUS(generators)
	firewallPolicyNatRuleCollectionAction_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyNatRuleCollectionAction_STATUS{}), generators)

	return firewallPolicyNatRuleCollectionAction_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyNatRuleCollectionAction_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyNatRuleCollectionAction_STATUS(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(FirewallPolicyNatRuleCollectionActionType_STATUS_DNAT))
}

func Test_FirewallPolicyNatRuleCollection_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyNatRuleCollection_STATUS to FirewallPolicyNatRuleCollection_STATUS via AssignProperties_To_FirewallPolicyNatRuleCollection_STATUS & AssignProperties_From_FirewallPolicyNatRuleCollection_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyNatRuleCollection_STATUS, FirewallPolicyNatRuleCollection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyNatRuleCollection_STATUS tests if a specific instance of FirewallPolicyNatRuleCollection_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyNatRuleCollection_STATUS(subject FirewallPolicyNatRuleCollection_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyNatRuleCollection_STATUS
	err := copied.AssignProperties_To_FirewallPolicyNatRuleCollection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyNatRuleCollection_STATUS
	err = actual.AssignProperties_From_FirewallPolicyNatRuleCollection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyNatRuleCollection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyNatRuleCollection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyNatRuleCollection_STATUS, FirewallPolicyNatRuleCollection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyNatRuleCollection_STATUS runs a test to see if a specific instance of FirewallPolicyNatRuleCollection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyNatRuleCollection_STATUS(subject FirewallPolicyNatRuleCollection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyNatRuleCollection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyNatRuleCollection_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyNatRuleCollection_STATUSGenerator()
var firewallPolicyNatRuleCollection_STATUSGenerator gopter.Gen

// FirewallPolicyNatRuleCollection_STATUSGenerator returns a generator of FirewallPolicyNatRuleCollection_STATUS instances for property testing.
// We first initialize firewallPolicyNatRuleCollection_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyNatRuleCollection_STATUSGenerator() gopter.Gen {
	if firewallPolicyNatRuleCollection_STATUSGenerator != nil {
		return firewallPolicyNatRuleCollection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyNatRuleCollection_STATUS(generators)
	firewallPolicyNatRuleCollection_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyNatRuleCollection_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyNatRuleCollection_STATUS(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyNatRuleCollection_STATUS(generators)
	firewallPolicyNatRuleCollection_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyNatRuleCollection_STATUS{}), generators)

	return firewallPolicyNatRuleCollection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyNatRuleCollection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyNatRuleCollection_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["RuleCollectionType"] = gen.PtrOf(gen.OneConstOf(FirewallPolicyNatRuleCollection_RuleCollectionType_STATUS_FirewallPolicyNatRuleCollection))
}

// AddRelatedPropertyGeneratorsForFirewallPolicyNatRuleCollection_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyNatRuleCollection_STATUS(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(FirewallPolicyNatRuleCollectionAction_STATUSGenerator())
	gens["Rules"] = gen.SliceOf(FirewallPolicyRule_STATUSGenerator())
}

func Test_FirewallPolicyRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyRule to FirewallPolicyRule via AssignProperties_To_FirewallPolicyRule & AssignProperties_From_FirewallPolicyRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyRule, FirewallPolicyRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyRule tests if a specific instance of FirewallPolicyRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyRule(subject FirewallPolicyRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyRule
	err := copied.AssignProperties_To_FirewallPolicyRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyRule
	err = actual.AssignProperties_From_FirewallPolicyRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyRule, FirewallPolicyRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyRule runs a test to see if a specific instance of FirewallPolicyRule round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyRule(subject FirewallPolicyRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyRule instances for property testing - lazily instantiated by FirewallPolicyRuleGenerator()
var firewallPolicyRuleGenerator gopter.Gen

// FirewallPolicyRuleGenerator returns a generator of FirewallPolicyRule instances for property testing.
func FirewallPolicyRuleGenerator() gopter.Gen {
	if firewallPolicyRuleGenerator != nil {
		return firewallPolicyRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForFirewallPolicyRule(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		props := map[string]gopter.Gen{propName: propGen}
		gens = append(gens, gen.Struct(reflect.TypeOf(FirewallPolicyRule{}), props))
	}
	firewallPolicyRuleGenerator = gen.OneGenOf(gens...)

	return firewallPolicyRuleGenerator
}

// AddRelatedPropertyGeneratorsForFirewallPolicyRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyRule(gens map[string]gopter.Gen) {
	gens["Application"] = ApplicationRuleGenerator().Map(func(it ApplicationRule) *ApplicationRule {
		return &it
	}) // generate one case for OneOf type
	gens["Nat"] = NatRuleGenerator().Map(func(it NatRule) *NatRule {
		return &it
	}) // generate one case for OneOf type
	gens["Network"] = NetworkRuleGenerator().Map(func(it NetworkRule) *NetworkRule {
		return &it
	}) // generate one case for OneOf type
}

func Test_FirewallPolicyRuleApplicationProtocol_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyRuleApplicationProtocol to FirewallPolicyRuleApplicationProtocol via AssignProperties_To_FirewallPolicyRuleApplicationProtocol & AssignProperties_From_FirewallPolicyRuleApplicationProtocol returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyRuleApplicationProtocol, FirewallPolicyRuleApplicationProtocolGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyRuleApplicationProtocol tests if a specific instance of FirewallPolicyRuleApplicationProtocol can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyRuleApplicationProtocol(subject FirewallPolicyRuleApplicationProtocol) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyRuleApplicationProtocol
	err := copied.AssignProperties_To_FirewallPolicyRuleApplicationProtocol(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyRuleApplicationProtocol
	err = actual.AssignProperties_From_FirewallPolicyRuleApplicationProtocol(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyRuleApplicationProtocol_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyRuleApplicationProtocol via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyRuleApplicationProtocol, FirewallPolicyRuleApplicationProtocolGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyRuleApplicationProtocol runs a test to see if a specific instance of FirewallPolicyRuleApplicationProtocol round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyRuleApplicationProtocol(subject FirewallPolicyRuleApplicationProtocol) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyRuleApplicationProtocol
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyRuleApplicationProtocol instances for property testing - lazily instantiated by
// FirewallPolicyRuleApplicationProtocolGenerator()
var firewallPolicyRuleApplicationProtocolGenerator gopter.Gen

// FirewallPolicyRuleApplicationProtocolGenerator returns a generator of FirewallPolicyRuleApplicationProtocol instances for property testing.
func FirewallPolicyRuleApplicationProtocolGenerator() gopter.Gen {
	if firewallPolicyRuleApplicationProtocolGenerator != nil {
		return firewallPolicyRuleApplicationProtocolGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyRuleApplicationProtocol(generators)
	firewallPolicyRuleApplicationProtocolGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyRuleApplicationProtocol{}), generators)

	return firewallPolicyRuleApplicationProtocolGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyRuleApplicationProtocol is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyRuleApplicationProtocol(gens map[string]gopter.Gen) {
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["ProtocolType"] = gen.PtrOf(gen.OneConstOf(FirewallPolicyRuleApplicationProtocolType_Http, FirewallPolicyRuleApplicationProtocolType_Https))
}

func Test_FirewallPolicyRuleApplicationProtocol_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyRuleApplicationProtocol_STATUS to FirewallPolicyRuleApplicationProtocol_STATUS via AssignProperties_To_FirewallPolicyRuleApplicationProtocol_STATUS & AssignProperties_From_FirewallPolicyRuleApplicationProtocol_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyRuleApplicationProtocol_STATUS, FirewallPolicyRuleApplicationProtocol_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyRuleApplicationProtocol_STATUS tests if a specific instance of FirewallPolicyRuleApplicationProtocol_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyRuleApplicationProtocol_STATUS(subject FirewallPolicyRuleApplicationProtocol_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyRuleApplicationProtocol_STATUS
	err := copied.AssignProperties_To_FirewallPolicyRuleApplicationProtocol_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyRuleApplicationProtocol_STATUS
	err = actual.AssignProperties_From_FirewallPolicyRuleApplicationProtocol_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyRuleApplicationProtocol_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyRuleApplicationProtocol_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyRuleApplicationProtocol_STATUS, FirewallPolicyRuleApplicationProtocol_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyRuleApplicationProtocol_STATUS runs a test to see if a specific instance of FirewallPolicyRuleApplicationProtocol_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyRuleApplicationProtocol_STATUS(subject FirewallPolicyRuleApplicationProtocol_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyRuleApplicationProtocol_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyRuleApplicationProtocol_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyRuleApplicationProtocol_STATUSGenerator()
var firewallPolicyRuleApplicationProtocol_STATUSGenerator gopter.Gen

// FirewallPolicyRuleApplicationProtocol_STATUSGenerator returns a generator of FirewallPolicyRuleApplicationProtocol_STATUS instances for property testing.
func FirewallPolicyRuleApplicationProtocol_STATUSGenerator() gopter.Gen {
	if firewallPolicyRuleApplicationProtocol_STATUSGenerator != nil {
		return firewallPolicyRuleApplicationProtocol_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyRuleApplicationProtocol_STATUS(generators)
	firewallPolicyRuleApplicationProtocol_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyRuleApplicationProtocol_STATUS{}), generators)

	return firewallPolicyRuleApplicationProtocol_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyRuleApplicationProtocol_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyRuleApplicationProtocol_STATUS(gens map[string]gopter.Gen) {
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["ProtocolType"] = gen.PtrOf(gen.OneConstOf(FirewallPolicyRuleApplicationProtocolType_STATUS_Http, FirewallPolicyRuleApplicationProtocolType_STATUS_Https))
}

func Test_FirewallPolicyRuleCollection_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyRuleCollection to FirewallPolicyRuleCollection via AssignProperties_To_FirewallPolicyRuleCollection & AssignProperties_From_FirewallPolicyRuleCollection returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyRuleCollection, FirewallPolicyRuleCollectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyRuleCollection tests if a specific instance of FirewallPolicyRuleCollection can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyRuleCollection(subject FirewallPolicyRuleCollection) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyRuleCollection
	err := copied.AssignProperties_To_FirewallPolicyRuleCollection(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyRuleCollection
	err = actual.AssignProperties_From_FirewallPolicyRuleCollection(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyRuleCollection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyRuleCollection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyRuleCollection, FirewallPolicyRuleCollectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyRuleCollection runs a test to see if a specific instance of FirewallPolicyRuleCollection round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyRuleCollection(subject FirewallPolicyRuleCollection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyRuleCollection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyRuleCollection instances for property testing - lazily instantiated by
// FirewallPolicyRuleCollectionGenerator()
var firewallPolicyRuleCollectionGenerator gopter.Gen

// FirewallPolicyRuleCollectionGenerator returns a generator of FirewallPolicyRuleCollection instances for property testing.
func FirewallPolicyRuleCollectionGenerator() gopter.Gen {
	if firewallPolicyRuleCollectionGenerator != nil {
		return firewallPolicyRuleCollectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForFirewallPolicyRuleCollection(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		props := map[string]gopter.Gen{propName: propGen}
		gens = append(gens, gen.Struct(reflect.TypeOf(FirewallPolicyRuleCollection{}), props))
	}
	firewallPolicyRuleCollectionGenerator = gen.OneGenOf(gens...)

	return firewallPolicyRuleCollectionGenerator
}

// AddRelatedPropertyGeneratorsForFirewallPolicyRuleCollection is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyRuleCollection(gens map[string]gopter.Gen) {
	gens["FirewallPolicyFilter"] = FirewallPolicyFilterRuleCollectionGenerator().Map(func(it FirewallPolicyFilterRuleCollection) *FirewallPolicyFilterRuleCollection {
		return &it
	}) // generate one case for OneOf type
	gens["FirewallPolicyNat"] = FirewallPolicyNatRuleCollectionGenerator().Map(func(it FirewallPolicyNatRuleCollection) *FirewallPolicyNatRuleCollection {
		return &it
	}) // generate one case for OneOf type
}

func Test_FirewallPolicyRuleCollection_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyRuleCollection_STATUS to FirewallPolicyRuleCollection_STATUS via AssignProperties_To_FirewallPolicyRuleCollection_STATUS & AssignProperties_From_FirewallPolicyRuleCollection_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyRuleCollection_STATUS, FirewallPolicyRuleCollection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyRuleCollection_STATUS tests if a specific instance of FirewallPolicyRuleCollection_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyRuleCollection_STATUS(subject FirewallPolicyRuleCollection_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyRuleCollection_STATUS
	err := copied.AssignProperties_To_FirewallPolicyRuleCollection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyRuleCollection_STATUS
	err = actual.AssignProperties_From_FirewallPolicyRuleCollection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyRuleCollection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyRuleCollection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyRuleCollection_STATUS, FirewallPolicyRuleCollection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyRuleCollection_STATUS runs a test to see if a specific instance of FirewallPolicyRuleCollection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyRuleCollection_STATUS(subject FirewallPolicyRuleCollection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyRuleCollection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyRuleCollection_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyRuleCollection_STATUSGenerator()
var firewallPolicyRuleCollection_STATUSGenerator gopter.Gen

// FirewallPolicyRuleCollection_STATUSGenerator returns a generator of FirewallPolicyRuleCollection_STATUS instances for property testing.
func FirewallPolicyRuleCollection_STATUSGenerator() gopter.Gen {
	if firewallPolicyRuleCollection_STATUSGenerator != nil {
		return firewallPolicyRuleCollection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForFirewallPolicyRuleCollection_STATUS(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		props := map[string]gopter.Gen{propName: propGen}
		gens = append(gens, gen.Struct(reflect.TypeOf(FirewallPolicyRuleCollection_STATUS{}), props))
	}
	firewallPolicyRuleCollection_STATUSGenerator = gen.OneGenOf(gens...)

	return firewallPolicyRuleCollection_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForFirewallPolicyRuleCollection_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyRuleCollection_STATUS(gens map[string]gopter.Gen) {
	gens["FirewallPolicyFilter"] = FirewallPolicyFilterRuleCollection_STATUSGenerator().Map(func(it FirewallPolicyFilterRuleCollection_STATUS) *FirewallPolicyFilterRuleCollection_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["FirewallPolicyNat"] = FirewallPolicyNatRuleCollection_STATUSGenerator().Map(func(it FirewallPolicyNatRuleCollection_STATUS) *FirewallPolicyNatRuleCollection_STATUS {
		return &it
	}) // generate one case for OneOf type
}

func Test_FirewallPolicyRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyRule_STATUS to FirewallPolicyRule_STATUS via AssignProperties_To_FirewallPolicyRule_STATUS & AssignProperties_From_FirewallPolicyRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyRule_STATUS, FirewallPolicyRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyRule_STATUS tests if a specific instance of FirewallPolicyRule_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyRule_STATUS(subject FirewallPolicyRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyRule_STATUS
	err := copied.AssignProperties_To_FirewallPolicyRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyRule_STATUS
	err = actual.AssignProperties_From_FirewallPolicyRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyRule_STATUS, FirewallPolicyRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyRule_STATUS runs a test to see if a specific instance of FirewallPolicyRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyRule_STATUS(subject FirewallPolicyRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyRule_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyRule_STATUSGenerator()
var firewallPolicyRule_STATUSGenerator gopter.Gen

// FirewallPolicyRule_STATUSGenerator returns a generator of FirewallPolicyRule_STATUS instances for property testing.
func FirewallPolicyRule_STATUSGenerator() gopter.Gen {
	if firewallPolicyRule_STATUSGenerator != nil {
		return firewallPolicyRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForFirewallPolicyRule_STATUS(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		props := map[string]gopter.Gen{propName: propGen}
		gens = append(gens, gen.Struct(reflect.TypeOf(FirewallPolicyRule_STATUS{}), props))
	}
	firewallPolicyRule_STATUSGenerator = gen.OneGenOf(gens...)

	return firewallPolicyRule_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForFirewallPolicyRule_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyRule_STATUS(gens map[string]gopter.Gen) {
	gens["Application"] = ApplicationRule_STATUSGenerator().Map(func(it ApplicationRule_STATUS) *ApplicationRule_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["Nat"] = NatRule_STATUSGenerator().Map(func(it NatRule_STATUS) *NatRule_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["Network"] = NetworkRule_STATUSGenerator().Map(func(it NetworkRule_STATUS) *NetworkRule_STATUS {
		return &it
	}) // generate one case for OneOf type
}

func Test_NatRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NatRule to NatRule via AssignProperties_To_NatRule & AssignProperties_From_NatRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForNatRule, NatRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNatRule tests if a specific instance of NatRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNatRule(subject NatRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NatRule
	err := copied.AssignProperties_To_NatRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NatRule
	err = actual.AssignProperties_From_NatRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NatRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NatRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNatRule, NatRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNatRule runs a test to see if a specific instance of NatRule round trips to JSON and back losslessly
func RunJSONSerializationTestForNatRule(subject NatRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NatRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NatRule instances for property testing - lazily instantiated by NatRuleGenerator()
var natRuleGenerator gopter.Gen

// NatRuleGenerator returns a generator of NatRule instances for property testing.
func NatRuleGenerator() gopter.Gen {
	if natRuleGenerator != nil {
		return natRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatRule(generators)
	natRuleGenerator = gen.Struct(reflect.TypeOf(NatRule{}), generators)

	return natRuleGenerator
}

// AddIndependentPropertyGeneratorsForNatRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNatRule(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DestinationAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationPorts"] = gen.SliceOf(gen.AlphaString())
	gens["IpProtocols"] = gen.SliceOf(gen.OneConstOf(
		FirewallPolicyRuleNetworkProtocol_Any,
		FirewallPolicyRuleNetworkProtocol_ICMP,
		FirewallPolicyRuleNetworkProtocol_TCP,
		FirewallPolicyRuleNetworkProtocol_UDP))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["RuleType"] = gen.PtrOf(gen.OneConstOf(NatRule_RuleType_NatRule))
	gens["SourceAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["SourceIpGroups"] = gen.SliceOf(gen.AlphaString())
	gens["TranslatedAddress"] = gen.PtrOf(gen.AlphaString())
	gens["TranslatedFqdn"] = gen.PtrOf(gen.AlphaString())
	gens["TranslatedPort"] = gen.PtrOf(gen.AlphaString())
}

func Test_NatRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NatRule_STATUS to NatRule_STATUS via AssignProperties_To_NatRule_STATUS & AssignProperties_From_NatRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNatRule_STATUS, NatRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNatRule_STATUS tests if a specific instance of NatRule_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNatRule_STATUS(subject NatRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NatRule_STATUS
	err := copied.AssignProperties_To_NatRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NatRule_STATUS
	err = actual.AssignProperties_From_NatRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NatRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NatRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNatRule_STATUS, NatRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNatRule_STATUS runs a test to see if a specific instance of NatRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNatRule_STATUS(subject NatRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NatRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NatRule_STATUS instances for property testing - lazily instantiated by NatRule_STATUSGenerator()
var natRule_STATUSGenerator gopter.Gen

// NatRule_STATUSGenerator returns a generator of NatRule_STATUS instances for property testing.
func NatRule_STATUSGenerator() gopter.Gen {
	if natRule_STATUSGenerator != nil {
		return natRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatRule_STATUS(generators)
	natRule_STATUSGenerator = gen.Struct(reflect.TypeOf(NatRule_STATUS{}), generators)

	return natRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNatRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNatRule_STATUS(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DestinationAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationPorts"] = gen.SliceOf(gen.AlphaString())
	gens["IpProtocols"] = gen.SliceOf(gen.OneConstOf(
		FirewallPolicyRuleNetworkProtocol_STATUS_Any,
		FirewallPolicyRuleNetworkProtocol_STATUS_ICMP,
		FirewallPolicyRuleNetworkProtocol_STATUS_TCP,
		FirewallPolicyRuleNetworkProtocol_STATUS_UDP))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["RuleType"] = gen.PtrOf(gen.OneConstOf(NatRule_RuleType_STATUS_NatRule))
	gens["SourceAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["SourceIpGroups"] = gen.SliceOf(gen.AlphaString())
	gens["TranslatedAddress"] = gen.PtrOf(gen.AlphaString())
	gens["TranslatedFqdn"] = gen.PtrOf(gen.AlphaString())
	gens["TranslatedPort"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkRule to NetworkRule via AssignProperties_To_NetworkRule & AssignProperties_From_NetworkRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkRule, NetworkRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkRule tests if a specific instance of NetworkRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNetworkRule(subject NetworkRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NetworkRule
	err := copied.AssignProperties_To_NetworkRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkRule
	err = actual.AssignProperties_From_NetworkRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRule, NetworkRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRule runs a test to see if a specific instance of NetworkRule round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRule(subject NetworkRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRule instances for property testing - lazily instantiated by NetworkRuleGenerator()
var networkRuleGenerator gopter.Gen

// NetworkRuleGenerator returns a generator of NetworkRule instances for property testing.
func NetworkRuleGenerator() gopter.Gen {
	if networkRuleGenerator != nil {
		return networkRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRule(generators)
	networkRuleGenerator = gen.Struct(reflect.TypeOf(NetworkRule{}), generators)

	return networkRuleGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRule(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DestinationAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationFqdns"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationIpGroups"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationPorts"] = gen.SliceOf(gen.AlphaString())
	gens["IpProtocols"] = gen.SliceOf(gen.OneConstOf(
		FirewallPolicyRuleNetworkProtocol_Any,
		FirewallPolicyRuleNetworkProtocol_ICMP,
		FirewallPolicyRuleNetworkProtocol_TCP,
		FirewallPolicyRuleNetworkProtocol_UDP))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["RuleType"] = gen.PtrOf(gen.OneConstOf(NetworkRule_RuleType_NetworkRule))
	gens["SourceAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["SourceIpGroups"] = gen.SliceOf(gen.AlphaString())
}

func Test_NetworkRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkRule_STATUS to NetworkRule_STATUS via AssignProperties_To_NetworkRule_STATUS & AssignProperties_From_NetworkRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkRule_STATUS, NetworkRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkRule_STATUS tests if a specific instance of NetworkRule_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNetworkRule_STATUS(subject NetworkRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NetworkRule_STATUS
	err := copied.AssignProperties_To_NetworkRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkRule_STATUS
	err = actual.AssignProperties_From_NetworkRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRule_STATUS, NetworkRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRule_STATUS runs a test to see if a specific instance of NetworkRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRule_STATUS(subject NetworkRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRule_STATUS instances for property testing - lazily instantiated by NetworkRule_STATUSGenerator()
var networkRule_STATUSGenerator gopter.Gen

// NetworkRule_STATUSGenerator returns a generator of NetworkRule_STATUS instances for property testing.
func NetworkRule_STATUSGenerator() gopter.Gen {
	if networkRule_STATUSGenerator != nil {
		return networkRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRule_STATUS(generators)
	networkRule_STATUSGenerator = gen.Struct(reflect.TypeOf(NetworkRule_STATUS{}), generators)

	return networkRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRule_STATUS(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DestinationAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationFqdns"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationIpGroups"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationPorts"] = gen.SliceOf(gen.AlphaString())
	gens["IpProtocols"] = gen.SliceOf(gen.OneConstOf(
		FirewallPolicyRuleNetworkProtocol_STATUS_Any,
		FirewallPolicyRuleNetworkProtocol_STATUS_ICMP,
		FirewallPolicyRuleNetworkProtocol_STATUS_TCP,
		FirewallPolicyRuleNetworkProtocol_STATUS_UDP))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["RuleType"] = gen.PtrOf(gen.OneConstOf(NetworkRule_RuleType_STATUS_NetworkRule))
	gens["SourceAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["SourceIpGroups"] = gen.SliceOf(gen.AlphaString())
}
