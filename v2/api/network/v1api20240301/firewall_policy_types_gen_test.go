// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240301

import (
	"encoding/json"
	storage "github.com/Azure/azure-service-operator/v2/api/network/v1api20240301/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_DnsSettings_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DnsSettings to DnsSettings via AssignProperties_To_DnsSettings & AssignProperties_From_DnsSettings returns original",
		prop.ForAll(RunPropertyAssignmentTestForDnsSettings, DnsSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDnsSettings tests if a specific instance of DnsSettings can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForDnsSettings(subject DnsSettings) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.DnsSettings
	err := copied.AssignProperties_To_DnsSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DnsSettings
	err = actual.AssignProperties_From_DnsSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DnsSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DnsSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDnsSettings, DnsSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDnsSettings runs a test to see if a specific instance of DnsSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForDnsSettings(subject DnsSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DnsSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DnsSettings instances for property testing - lazily instantiated by DnsSettingsGenerator()
var dnsSettingsGenerator gopter.Gen

// DnsSettingsGenerator returns a generator of DnsSettings instances for property testing.
func DnsSettingsGenerator() gopter.Gen {
	if dnsSettingsGenerator != nil {
		return dnsSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDnsSettings(generators)
	dnsSettingsGenerator = gen.Struct(reflect.TypeOf(DnsSettings{}), generators)

	return dnsSettingsGenerator
}

// AddIndependentPropertyGeneratorsForDnsSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDnsSettings(gens map[string]gopter.Gen) {
	gens["EnableProxy"] = gen.PtrOf(gen.Bool())
	gens["RequireProxyForNetworkRules"] = gen.PtrOf(gen.Bool())
	gens["Servers"] = gen.SliceOf(gen.AlphaString())
}

func Test_DnsSettings_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DnsSettings_STATUS to DnsSettings_STATUS via AssignProperties_To_DnsSettings_STATUS & AssignProperties_From_DnsSettings_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDnsSettings_STATUS, DnsSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDnsSettings_STATUS tests if a specific instance of DnsSettings_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForDnsSettings_STATUS(subject DnsSettings_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.DnsSettings_STATUS
	err := copied.AssignProperties_To_DnsSettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DnsSettings_STATUS
	err = actual.AssignProperties_From_DnsSettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DnsSettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DnsSettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDnsSettings_STATUS, DnsSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDnsSettings_STATUS runs a test to see if a specific instance of DnsSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDnsSettings_STATUS(subject DnsSettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DnsSettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DnsSettings_STATUS instances for property testing - lazily instantiated by DnsSettings_STATUSGenerator()
var dnsSettings_STATUSGenerator gopter.Gen

// DnsSettings_STATUSGenerator returns a generator of DnsSettings_STATUS instances for property testing.
func DnsSettings_STATUSGenerator() gopter.Gen {
	if dnsSettings_STATUSGenerator != nil {
		return dnsSettings_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDnsSettings_STATUS(generators)
	dnsSettings_STATUSGenerator = gen.Struct(reflect.TypeOf(DnsSettings_STATUS{}), generators)

	return dnsSettings_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDnsSettings_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDnsSettings_STATUS(gens map[string]gopter.Gen) {
	gens["EnableProxy"] = gen.PtrOf(gen.Bool())
	gens["RequireProxyForNetworkRules"] = gen.PtrOf(gen.Bool())
	gens["Servers"] = gen.SliceOf(gen.AlphaString())
}

func Test_ExplicitProxy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExplicitProxy to ExplicitProxy via AssignProperties_To_ExplicitProxy & AssignProperties_From_ExplicitProxy returns original",
		prop.ForAll(RunPropertyAssignmentTestForExplicitProxy, ExplicitProxyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExplicitProxy tests if a specific instance of ExplicitProxy can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForExplicitProxy(subject ExplicitProxy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ExplicitProxy
	err := copied.AssignProperties_To_ExplicitProxy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExplicitProxy
	err = actual.AssignProperties_From_ExplicitProxy(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExplicitProxy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExplicitProxy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExplicitProxy, ExplicitProxyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExplicitProxy runs a test to see if a specific instance of ExplicitProxy round trips to JSON and back losslessly
func RunJSONSerializationTestForExplicitProxy(subject ExplicitProxy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExplicitProxy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExplicitProxy instances for property testing - lazily instantiated by ExplicitProxyGenerator()
var explicitProxyGenerator gopter.Gen

// ExplicitProxyGenerator returns a generator of ExplicitProxy instances for property testing.
func ExplicitProxyGenerator() gopter.Gen {
	if explicitProxyGenerator != nil {
		return explicitProxyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExplicitProxy(generators)
	explicitProxyGenerator = gen.Struct(reflect.TypeOf(ExplicitProxy{}), generators)

	return explicitProxyGenerator
}

// AddIndependentPropertyGeneratorsForExplicitProxy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExplicitProxy(gens map[string]gopter.Gen) {
	gens["EnableExplicitProxy"] = gen.PtrOf(gen.Bool())
	gens["EnablePacFile"] = gen.PtrOf(gen.Bool())
	gens["HttpPort"] = gen.PtrOf(gen.Int())
	gens["HttpsPort"] = gen.PtrOf(gen.Int())
	gens["PacFile"] = gen.PtrOf(gen.AlphaString())
	gens["PacFilePort"] = gen.PtrOf(gen.Int())
}

func Test_ExplicitProxy_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExplicitProxy_STATUS to ExplicitProxy_STATUS via AssignProperties_To_ExplicitProxy_STATUS & AssignProperties_From_ExplicitProxy_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForExplicitProxy_STATUS, ExplicitProxy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExplicitProxy_STATUS tests if a specific instance of ExplicitProxy_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForExplicitProxy_STATUS(subject ExplicitProxy_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ExplicitProxy_STATUS
	err := copied.AssignProperties_To_ExplicitProxy_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExplicitProxy_STATUS
	err = actual.AssignProperties_From_ExplicitProxy_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExplicitProxy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExplicitProxy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExplicitProxy_STATUS, ExplicitProxy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExplicitProxy_STATUS runs a test to see if a specific instance of ExplicitProxy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForExplicitProxy_STATUS(subject ExplicitProxy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExplicitProxy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExplicitProxy_STATUS instances for property testing - lazily instantiated by
// ExplicitProxy_STATUSGenerator()
var explicitProxy_STATUSGenerator gopter.Gen

// ExplicitProxy_STATUSGenerator returns a generator of ExplicitProxy_STATUS instances for property testing.
func ExplicitProxy_STATUSGenerator() gopter.Gen {
	if explicitProxy_STATUSGenerator != nil {
		return explicitProxy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExplicitProxy_STATUS(generators)
	explicitProxy_STATUSGenerator = gen.Struct(reflect.TypeOf(ExplicitProxy_STATUS{}), generators)

	return explicitProxy_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForExplicitProxy_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExplicitProxy_STATUS(gens map[string]gopter.Gen) {
	gens["EnableExplicitProxy"] = gen.PtrOf(gen.Bool())
	gens["EnablePacFile"] = gen.PtrOf(gen.Bool())
	gens["HttpPort"] = gen.PtrOf(gen.Int())
	gens["HttpsPort"] = gen.PtrOf(gen.Int())
	gens["PacFile"] = gen.PtrOf(gen.AlphaString())
	gens["PacFilePort"] = gen.PtrOf(gen.Int())
}

func Test_FirewallPolicy_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicy to hub returns original",
		prop.ForAll(RunResourceConversionTestForFirewallPolicy, FirewallPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForFirewallPolicy tests if a specific instance of FirewallPolicy round trips to the hub storage version and back losslessly
func RunResourceConversionTestForFirewallPolicy(subject FirewallPolicy) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub storage.FirewallPolicy
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual FirewallPolicy
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicy to FirewallPolicy via AssignProperties_To_FirewallPolicy & AssignProperties_From_FirewallPolicy returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicy, FirewallPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicy tests if a specific instance of FirewallPolicy can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicy(subject FirewallPolicy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicy
	err := copied.AssignProperties_To_FirewallPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicy
	err = actual.AssignProperties_From_FirewallPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicy, FirewallPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicy runs a test to see if a specific instance of FirewallPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicy(subject FirewallPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicy instances for property testing - lazily instantiated by FirewallPolicyGenerator()
var firewallPolicyGenerator gopter.Gen

// FirewallPolicyGenerator returns a generator of FirewallPolicy instances for property testing.
func FirewallPolicyGenerator() gopter.Gen {
	if firewallPolicyGenerator != nil {
		return firewallPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForFirewallPolicy(generators)
	firewallPolicyGenerator = gen.Struct(reflect.TypeOf(FirewallPolicy{}), generators)

	return firewallPolicyGenerator
}

// AddRelatedPropertyGeneratorsForFirewallPolicy is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicy(gens map[string]gopter.Gen) {
	gens["Spec"] = FirewallPolicy_SpecGenerator()
	gens["Status"] = FirewallPolicy_STATUSGenerator()
}

func Test_FirewallPolicyCertificateAuthority_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyCertificateAuthority to FirewallPolicyCertificateAuthority via AssignProperties_To_FirewallPolicyCertificateAuthority & AssignProperties_From_FirewallPolicyCertificateAuthority returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyCertificateAuthority, FirewallPolicyCertificateAuthorityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyCertificateAuthority tests if a specific instance of FirewallPolicyCertificateAuthority can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyCertificateAuthority(subject FirewallPolicyCertificateAuthority) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyCertificateAuthority
	err := copied.AssignProperties_To_FirewallPolicyCertificateAuthority(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyCertificateAuthority
	err = actual.AssignProperties_From_FirewallPolicyCertificateAuthority(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyCertificateAuthority_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyCertificateAuthority via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyCertificateAuthority, FirewallPolicyCertificateAuthorityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyCertificateAuthority runs a test to see if a specific instance of FirewallPolicyCertificateAuthority round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyCertificateAuthority(subject FirewallPolicyCertificateAuthority) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyCertificateAuthority
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyCertificateAuthority instances for property testing - lazily instantiated by
// FirewallPolicyCertificateAuthorityGenerator()
var firewallPolicyCertificateAuthorityGenerator gopter.Gen

// FirewallPolicyCertificateAuthorityGenerator returns a generator of FirewallPolicyCertificateAuthority instances for property testing.
func FirewallPolicyCertificateAuthorityGenerator() gopter.Gen {
	if firewallPolicyCertificateAuthorityGenerator != nil {
		return firewallPolicyCertificateAuthorityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyCertificateAuthority(generators)
	firewallPolicyCertificateAuthorityGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyCertificateAuthority{}), generators)

	return firewallPolicyCertificateAuthorityGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyCertificateAuthority is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyCertificateAuthority(gens map[string]gopter.Gen) {
	gens["KeyVaultSecretId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_FirewallPolicyCertificateAuthority_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyCertificateAuthority_STATUS to FirewallPolicyCertificateAuthority_STATUS via AssignProperties_To_FirewallPolicyCertificateAuthority_STATUS & AssignProperties_From_FirewallPolicyCertificateAuthority_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyCertificateAuthority_STATUS, FirewallPolicyCertificateAuthority_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyCertificateAuthority_STATUS tests if a specific instance of FirewallPolicyCertificateAuthority_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyCertificateAuthority_STATUS(subject FirewallPolicyCertificateAuthority_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyCertificateAuthority_STATUS
	err := copied.AssignProperties_To_FirewallPolicyCertificateAuthority_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyCertificateAuthority_STATUS
	err = actual.AssignProperties_From_FirewallPolicyCertificateAuthority_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyCertificateAuthority_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyCertificateAuthority_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyCertificateAuthority_STATUS, FirewallPolicyCertificateAuthority_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyCertificateAuthority_STATUS runs a test to see if a specific instance of FirewallPolicyCertificateAuthority_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyCertificateAuthority_STATUS(subject FirewallPolicyCertificateAuthority_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyCertificateAuthority_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyCertificateAuthority_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyCertificateAuthority_STATUSGenerator()
var firewallPolicyCertificateAuthority_STATUSGenerator gopter.Gen

// FirewallPolicyCertificateAuthority_STATUSGenerator returns a generator of FirewallPolicyCertificateAuthority_STATUS instances for property testing.
func FirewallPolicyCertificateAuthority_STATUSGenerator() gopter.Gen {
	if firewallPolicyCertificateAuthority_STATUSGenerator != nil {
		return firewallPolicyCertificateAuthority_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyCertificateAuthority_STATUS(generators)
	firewallPolicyCertificateAuthority_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyCertificateAuthority_STATUS{}), generators)

	return firewallPolicyCertificateAuthority_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyCertificateAuthority_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyCertificateAuthority_STATUS(gens map[string]gopter.Gen) {
	gens["KeyVaultSecretId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_FirewallPolicyInsights_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyInsights to FirewallPolicyInsights via AssignProperties_To_FirewallPolicyInsights & AssignProperties_From_FirewallPolicyInsights returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyInsights, FirewallPolicyInsightsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyInsights tests if a specific instance of FirewallPolicyInsights can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyInsights(subject FirewallPolicyInsights) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyInsights
	err := copied.AssignProperties_To_FirewallPolicyInsights(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyInsights
	err = actual.AssignProperties_From_FirewallPolicyInsights(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyInsights_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyInsights via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyInsights, FirewallPolicyInsightsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyInsights runs a test to see if a specific instance of FirewallPolicyInsights round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyInsights(subject FirewallPolicyInsights) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyInsights
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyInsights instances for property testing - lazily instantiated by
// FirewallPolicyInsightsGenerator()
var firewallPolicyInsightsGenerator gopter.Gen

// FirewallPolicyInsightsGenerator returns a generator of FirewallPolicyInsights instances for property testing.
// We first initialize firewallPolicyInsightsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyInsightsGenerator() gopter.Gen {
	if firewallPolicyInsightsGenerator != nil {
		return firewallPolicyInsightsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyInsights(generators)
	firewallPolicyInsightsGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyInsights{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyInsights(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyInsights(generators)
	firewallPolicyInsightsGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyInsights{}), generators)

	return firewallPolicyInsightsGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyInsights is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyInsights(gens map[string]gopter.Gen) {
	gens["IsEnabled"] = gen.PtrOf(gen.Bool())
	gens["RetentionDays"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForFirewallPolicyInsights is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyInsights(gens map[string]gopter.Gen) {
	gens["LogAnalyticsResources"] = gen.PtrOf(FirewallPolicyLogAnalyticsResourcesGenerator())
}

func Test_FirewallPolicyInsights_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyInsights_STATUS to FirewallPolicyInsights_STATUS via AssignProperties_To_FirewallPolicyInsights_STATUS & AssignProperties_From_FirewallPolicyInsights_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyInsights_STATUS, FirewallPolicyInsights_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyInsights_STATUS tests if a specific instance of FirewallPolicyInsights_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyInsights_STATUS(subject FirewallPolicyInsights_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyInsights_STATUS
	err := copied.AssignProperties_To_FirewallPolicyInsights_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyInsights_STATUS
	err = actual.AssignProperties_From_FirewallPolicyInsights_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyInsights_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyInsights_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyInsights_STATUS, FirewallPolicyInsights_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyInsights_STATUS runs a test to see if a specific instance of FirewallPolicyInsights_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyInsights_STATUS(subject FirewallPolicyInsights_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyInsights_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyInsights_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyInsights_STATUSGenerator()
var firewallPolicyInsights_STATUSGenerator gopter.Gen

// FirewallPolicyInsights_STATUSGenerator returns a generator of FirewallPolicyInsights_STATUS instances for property testing.
// We first initialize firewallPolicyInsights_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyInsights_STATUSGenerator() gopter.Gen {
	if firewallPolicyInsights_STATUSGenerator != nil {
		return firewallPolicyInsights_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyInsights_STATUS(generators)
	firewallPolicyInsights_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyInsights_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyInsights_STATUS(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyInsights_STATUS(generators)
	firewallPolicyInsights_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyInsights_STATUS{}), generators)

	return firewallPolicyInsights_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyInsights_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyInsights_STATUS(gens map[string]gopter.Gen) {
	gens["IsEnabled"] = gen.PtrOf(gen.Bool())
	gens["RetentionDays"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForFirewallPolicyInsights_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyInsights_STATUS(gens map[string]gopter.Gen) {
	gens["LogAnalyticsResources"] = gen.PtrOf(FirewallPolicyLogAnalyticsResources_STATUSGenerator())
}

func Test_FirewallPolicyIntrusionDetection_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyIntrusionDetection to FirewallPolicyIntrusionDetection via AssignProperties_To_FirewallPolicyIntrusionDetection & AssignProperties_From_FirewallPolicyIntrusionDetection returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyIntrusionDetection, FirewallPolicyIntrusionDetectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyIntrusionDetection tests if a specific instance of FirewallPolicyIntrusionDetection can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyIntrusionDetection(subject FirewallPolicyIntrusionDetection) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyIntrusionDetection
	err := copied.AssignProperties_To_FirewallPolicyIntrusionDetection(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyIntrusionDetection
	err = actual.AssignProperties_From_FirewallPolicyIntrusionDetection(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyIntrusionDetection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyIntrusionDetection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyIntrusionDetection, FirewallPolicyIntrusionDetectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyIntrusionDetection runs a test to see if a specific instance of FirewallPolicyIntrusionDetection round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyIntrusionDetection(subject FirewallPolicyIntrusionDetection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyIntrusionDetection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyIntrusionDetection instances for property testing - lazily instantiated by
// FirewallPolicyIntrusionDetectionGenerator()
var firewallPolicyIntrusionDetectionGenerator gopter.Gen

// FirewallPolicyIntrusionDetectionGenerator returns a generator of FirewallPolicyIntrusionDetection instances for property testing.
// We first initialize firewallPolicyIntrusionDetectionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyIntrusionDetectionGenerator() gopter.Gen {
	if firewallPolicyIntrusionDetectionGenerator != nil {
		return firewallPolicyIntrusionDetectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetection(generators)
	firewallPolicyIntrusionDetectionGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetection{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetection(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetection(generators)
	firewallPolicyIntrusionDetectionGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetection{}), generators)

	return firewallPolicyIntrusionDetectionGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetection is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetection(gens map[string]gopter.Gen) {
	gens["Mode"] = gen.PtrOf(gen.OneConstOf(FirewallPolicyIntrusionDetectionStateOptions_Alert, FirewallPolicyIntrusionDetectionStateOptions_Deny, FirewallPolicyIntrusionDetectionStateOptions_Off))
	gens["Profile"] = gen.PtrOf(gen.OneConstOf(
		FirewallPolicyIntrusionDetectionProfileOptions_Advanced,
		FirewallPolicyIntrusionDetectionProfileOptions_Basic,
		FirewallPolicyIntrusionDetectionProfileOptions_Extended,
		FirewallPolicyIntrusionDetectionProfileOptions_Standard))
}

// AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetection is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetection(gens map[string]gopter.Gen) {
	gens["Configuration"] = gen.PtrOf(FirewallPolicyIntrusionDetectionConfigurationGenerator())
}

func Test_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyIntrusionDetectionBypassTrafficSpecifications to FirewallPolicyIntrusionDetectionBypassTrafficSpecifications via AssignProperties_To_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications & AssignProperties_From_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications, FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications tests if a specific instance of FirewallPolicyIntrusionDetectionBypassTrafficSpecifications can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications(subject FirewallPolicyIntrusionDetectionBypassTrafficSpecifications) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyIntrusionDetectionBypassTrafficSpecifications
	err := copied.AssignProperties_To_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyIntrusionDetectionBypassTrafficSpecifications
	err = actual.AssignProperties_From_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyIntrusionDetectionBypassTrafficSpecifications via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications, FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications runs a test to see if a specific instance of FirewallPolicyIntrusionDetectionBypassTrafficSpecifications round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications(subject FirewallPolicyIntrusionDetectionBypassTrafficSpecifications) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyIntrusionDetectionBypassTrafficSpecifications
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyIntrusionDetectionBypassTrafficSpecifications instances for property testing - lazily
// instantiated by FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator()
var firewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator gopter.Gen

// FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator returns a generator of FirewallPolicyIntrusionDetectionBypassTrafficSpecifications instances for property testing.
func FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator() gopter.Gen {
	if firewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator != nil {
		return firewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications(generators)
	firewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetectionBypassTrafficSpecifications{}), generators)

	return firewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DestinationAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationIpGroups"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationPorts"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(
		FirewallPolicyIntrusionDetectionBypassTrafficProtocol_ANY,
		FirewallPolicyIntrusionDetectionBypassTrafficProtocol_ICMP,
		FirewallPolicyIntrusionDetectionBypassTrafficProtocol_TCP,
		FirewallPolicyIntrusionDetectionBypassTrafficProtocol_UDP))
	gens["SourceAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["SourceIpGroups"] = gen.SliceOf(gen.AlphaString())
}

func Test_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS to FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS via AssignProperties_To_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS & AssignProperties_From_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS, FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS tests if a specific instance of FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS(subject FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS
	err := copied.AssignProperties_To_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS
	err = actual.AssignProperties_From_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS, FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS runs a test to see if a specific instance of FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS(subject FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS instances for property testing -
// lazily instantiated by FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator()
var firewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator gopter.Gen

// FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator returns a generator of FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS instances for property testing.
func FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator() gopter.Gen {
	if firewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator != nil {
		return firewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS(generators)
	firewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS{}), generators)

	return firewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DestinationAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationIpGroups"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationPorts"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(
		FirewallPolicyIntrusionDetectionBypassTrafficProtocol_STATUS_ANY,
		FirewallPolicyIntrusionDetectionBypassTrafficProtocol_STATUS_ICMP,
		FirewallPolicyIntrusionDetectionBypassTrafficProtocol_STATUS_TCP,
		FirewallPolicyIntrusionDetectionBypassTrafficProtocol_STATUS_UDP))
	gens["SourceAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["SourceIpGroups"] = gen.SliceOf(gen.AlphaString())
}

func Test_FirewallPolicyIntrusionDetectionConfiguration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyIntrusionDetectionConfiguration to FirewallPolicyIntrusionDetectionConfiguration via AssignProperties_To_FirewallPolicyIntrusionDetectionConfiguration & AssignProperties_From_FirewallPolicyIntrusionDetectionConfiguration returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyIntrusionDetectionConfiguration, FirewallPolicyIntrusionDetectionConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyIntrusionDetectionConfiguration tests if a specific instance of FirewallPolicyIntrusionDetectionConfiguration can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyIntrusionDetectionConfiguration(subject FirewallPolicyIntrusionDetectionConfiguration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyIntrusionDetectionConfiguration
	err := copied.AssignProperties_To_FirewallPolicyIntrusionDetectionConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyIntrusionDetectionConfiguration
	err = actual.AssignProperties_From_FirewallPolicyIntrusionDetectionConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyIntrusionDetectionConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyIntrusionDetectionConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyIntrusionDetectionConfiguration, FirewallPolicyIntrusionDetectionConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyIntrusionDetectionConfiguration runs a test to see if a specific instance of FirewallPolicyIntrusionDetectionConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyIntrusionDetectionConfiguration(subject FirewallPolicyIntrusionDetectionConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyIntrusionDetectionConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyIntrusionDetectionConfiguration instances for property testing - lazily instantiated by
// FirewallPolicyIntrusionDetectionConfigurationGenerator()
var firewallPolicyIntrusionDetectionConfigurationGenerator gopter.Gen

// FirewallPolicyIntrusionDetectionConfigurationGenerator returns a generator of FirewallPolicyIntrusionDetectionConfiguration instances for property testing.
// We first initialize firewallPolicyIntrusionDetectionConfigurationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyIntrusionDetectionConfigurationGenerator() gopter.Gen {
	if firewallPolicyIntrusionDetectionConfigurationGenerator != nil {
		return firewallPolicyIntrusionDetectionConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration(generators)
	firewallPolicyIntrusionDetectionConfigurationGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetectionConfiguration{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration(generators)
	firewallPolicyIntrusionDetectionConfigurationGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetectionConfiguration{}), generators)

	return firewallPolicyIntrusionDetectionConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration(gens map[string]gopter.Gen) {
	gens["PrivateRanges"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration(gens map[string]gopter.Gen) {
	gens["BypassTrafficSettings"] = gen.SliceOf(FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator())
	gens["SignatureOverrides"] = gen.SliceOf(FirewallPolicyIntrusionDetectionSignatureSpecificationGenerator())
}

func Test_FirewallPolicyIntrusionDetectionConfiguration_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyIntrusionDetectionConfiguration_STATUS to FirewallPolicyIntrusionDetectionConfiguration_STATUS via AssignProperties_To_FirewallPolicyIntrusionDetectionConfiguration_STATUS & AssignProperties_From_FirewallPolicyIntrusionDetectionConfiguration_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyIntrusionDetectionConfiguration_STATUS, FirewallPolicyIntrusionDetectionConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyIntrusionDetectionConfiguration_STATUS tests if a specific instance of FirewallPolicyIntrusionDetectionConfiguration_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyIntrusionDetectionConfiguration_STATUS(subject FirewallPolicyIntrusionDetectionConfiguration_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyIntrusionDetectionConfiguration_STATUS
	err := copied.AssignProperties_To_FirewallPolicyIntrusionDetectionConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyIntrusionDetectionConfiguration_STATUS
	err = actual.AssignProperties_From_FirewallPolicyIntrusionDetectionConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyIntrusionDetectionConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyIntrusionDetectionConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyIntrusionDetectionConfiguration_STATUS, FirewallPolicyIntrusionDetectionConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyIntrusionDetectionConfiguration_STATUS runs a test to see if a specific instance of FirewallPolicyIntrusionDetectionConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyIntrusionDetectionConfiguration_STATUS(subject FirewallPolicyIntrusionDetectionConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyIntrusionDetectionConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyIntrusionDetectionConfiguration_STATUS instances for property testing - lazily
// instantiated by FirewallPolicyIntrusionDetectionConfiguration_STATUSGenerator()
var firewallPolicyIntrusionDetectionConfiguration_STATUSGenerator gopter.Gen

// FirewallPolicyIntrusionDetectionConfiguration_STATUSGenerator returns a generator of FirewallPolicyIntrusionDetectionConfiguration_STATUS instances for property testing.
// We first initialize firewallPolicyIntrusionDetectionConfiguration_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyIntrusionDetectionConfiguration_STATUSGenerator() gopter.Gen {
	if firewallPolicyIntrusionDetectionConfiguration_STATUSGenerator != nil {
		return firewallPolicyIntrusionDetectionConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration_STATUS(generators)
	firewallPolicyIntrusionDetectionConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetectionConfiguration_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration_STATUS(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration_STATUS(generators)
	firewallPolicyIntrusionDetectionConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetectionConfiguration_STATUS{}), generators)

	return firewallPolicyIntrusionDetectionConfiguration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["PrivateRanges"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["BypassTrafficSettings"] = gen.SliceOf(FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator())
	gens["SignatureOverrides"] = gen.SliceOf(FirewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator())
}

func Test_FirewallPolicyIntrusionDetectionSignatureSpecification_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyIntrusionDetectionSignatureSpecification to FirewallPolicyIntrusionDetectionSignatureSpecification via AssignProperties_To_FirewallPolicyIntrusionDetectionSignatureSpecification & AssignProperties_From_FirewallPolicyIntrusionDetectionSignatureSpecification returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyIntrusionDetectionSignatureSpecification, FirewallPolicyIntrusionDetectionSignatureSpecificationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyIntrusionDetectionSignatureSpecification tests if a specific instance of FirewallPolicyIntrusionDetectionSignatureSpecification can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyIntrusionDetectionSignatureSpecification(subject FirewallPolicyIntrusionDetectionSignatureSpecification) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyIntrusionDetectionSignatureSpecification
	err := copied.AssignProperties_To_FirewallPolicyIntrusionDetectionSignatureSpecification(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyIntrusionDetectionSignatureSpecification
	err = actual.AssignProperties_From_FirewallPolicyIntrusionDetectionSignatureSpecification(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyIntrusionDetectionSignatureSpecification_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyIntrusionDetectionSignatureSpecification via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyIntrusionDetectionSignatureSpecification, FirewallPolicyIntrusionDetectionSignatureSpecificationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyIntrusionDetectionSignatureSpecification runs a test to see if a specific instance of FirewallPolicyIntrusionDetectionSignatureSpecification round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyIntrusionDetectionSignatureSpecification(subject FirewallPolicyIntrusionDetectionSignatureSpecification) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyIntrusionDetectionSignatureSpecification
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyIntrusionDetectionSignatureSpecification instances for property testing - lazily
// instantiated by FirewallPolicyIntrusionDetectionSignatureSpecificationGenerator()
var firewallPolicyIntrusionDetectionSignatureSpecificationGenerator gopter.Gen

// FirewallPolicyIntrusionDetectionSignatureSpecificationGenerator returns a generator of FirewallPolicyIntrusionDetectionSignatureSpecification instances for property testing.
func FirewallPolicyIntrusionDetectionSignatureSpecificationGenerator() gopter.Gen {
	if firewallPolicyIntrusionDetectionSignatureSpecificationGenerator != nil {
		return firewallPolicyIntrusionDetectionSignatureSpecificationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionSignatureSpecification(generators)
	firewallPolicyIntrusionDetectionSignatureSpecificationGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetectionSignatureSpecification{}), generators)

	return firewallPolicyIntrusionDetectionSignatureSpecificationGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionSignatureSpecification is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionSignatureSpecification(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Mode"] = gen.PtrOf(gen.OneConstOf(FirewallPolicyIntrusionDetectionStateOptions_Alert, FirewallPolicyIntrusionDetectionStateOptions_Deny, FirewallPolicyIntrusionDetectionStateOptions_Off))
}

func Test_FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS to FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS via AssignProperties_To_FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS & AssignProperties_From_FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyIntrusionDetectionSignatureSpecification_STATUS, FirewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyIntrusionDetectionSignatureSpecification_STATUS tests if a specific instance of FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyIntrusionDetectionSignatureSpecification_STATUS(subject FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS
	err := copied.AssignProperties_To_FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS
	err = actual.AssignProperties_From_FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyIntrusionDetectionSignatureSpecification_STATUS, FirewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyIntrusionDetectionSignatureSpecification_STATUS runs a test to see if a specific instance of FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyIntrusionDetectionSignatureSpecification_STATUS(subject FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS instances for property testing - lazily
// instantiated by FirewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator()
var firewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator gopter.Gen

// FirewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator returns a generator of FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS instances for property testing.
func FirewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator() gopter.Gen {
	if firewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator != nil {
		return firewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionSignatureSpecification_STATUS(generators)
	firewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS{}), generators)

	return firewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionSignatureSpecification_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionSignatureSpecification_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Mode"] = gen.PtrOf(gen.OneConstOf(FirewallPolicyIntrusionDetectionStateOptions_STATUS_Alert, FirewallPolicyIntrusionDetectionStateOptions_STATUS_Deny, FirewallPolicyIntrusionDetectionStateOptions_STATUS_Off))
}

func Test_FirewallPolicyIntrusionDetection_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyIntrusionDetection_STATUS to FirewallPolicyIntrusionDetection_STATUS via AssignProperties_To_FirewallPolicyIntrusionDetection_STATUS & AssignProperties_From_FirewallPolicyIntrusionDetection_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyIntrusionDetection_STATUS, FirewallPolicyIntrusionDetection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyIntrusionDetection_STATUS tests if a specific instance of FirewallPolicyIntrusionDetection_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyIntrusionDetection_STATUS(subject FirewallPolicyIntrusionDetection_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyIntrusionDetection_STATUS
	err := copied.AssignProperties_To_FirewallPolicyIntrusionDetection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyIntrusionDetection_STATUS
	err = actual.AssignProperties_From_FirewallPolicyIntrusionDetection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyIntrusionDetection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyIntrusionDetection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyIntrusionDetection_STATUS, FirewallPolicyIntrusionDetection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyIntrusionDetection_STATUS runs a test to see if a specific instance of FirewallPolicyIntrusionDetection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyIntrusionDetection_STATUS(subject FirewallPolicyIntrusionDetection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyIntrusionDetection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyIntrusionDetection_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyIntrusionDetection_STATUSGenerator()
var firewallPolicyIntrusionDetection_STATUSGenerator gopter.Gen

// FirewallPolicyIntrusionDetection_STATUSGenerator returns a generator of FirewallPolicyIntrusionDetection_STATUS instances for property testing.
// We first initialize firewallPolicyIntrusionDetection_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyIntrusionDetection_STATUSGenerator() gopter.Gen {
	if firewallPolicyIntrusionDetection_STATUSGenerator != nil {
		return firewallPolicyIntrusionDetection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetection_STATUS(generators)
	firewallPolicyIntrusionDetection_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetection_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetection_STATUS(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetection_STATUS(generators)
	firewallPolicyIntrusionDetection_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetection_STATUS{}), generators)

	return firewallPolicyIntrusionDetection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetection_STATUS(gens map[string]gopter.Gen) {
	gens["Mode"] = gen.PtrOf(gen.OneConstOf(FirewallPolicyIntrusionDetectionStateOptions_STATUS_Alert, FirewallPolicyIntrusionDetectionStateOptions_STATUS_Deny, FirewallPolicyIntrusionDetectionStateOptions_STATUS_Off))
	gens["Profile"] = gen.PtrOf(gen.OneConstOf(
		FirewallPolicyIntrusionDetectionProfileOptions_STATUS_Advanced,
		FirewallPolicyIntrusionDetectionProfileOptions_STATUS_Basic,
		FirewallPolicyIntrusionDetectionProfileOptions_STATUS_Extended,
		FirewallPolicyIntrusionDetectionProfileOptions_STATUS_Standard))
}

// AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetection_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetection_STATUS(gens map[string]gopter.Gen) {
	gens["Configuration"] = gen.PtrOf(FirewallPolicyIntrusionDetectionConfiguration_STATUSGenerator())
}

func Test_FirewallPolicyLogAnalyticsResources_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyLogAnalyticsResources to FirewallPolicyLogAnalyticsResources via AssignProperties_To_FirewallPolicyLogAnalyticsResources & AssignProperties_From_FirewallPolicyLogAnalyticsResources returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyLogAnalyticsResources, FirewallPolicyLogAnalyticsResourcesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyLogAnalyticsResources tests if a specific instance of FirewallPolicyLogAnalyticsResources can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyLogAnalyticsResources(subject FirewallPolicyLogAnalyticsResources) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyLogAnalyticsResources
	err := copied.AssignProperties_To_FirewallPolicyLogAnalyticsResources(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyLogAnalyticsResources
	err = actual.AssignProperties_From_FirewallPolicyLogAnalyticsResources(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyLogAnalyticsResources_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyLogAnalyticsResources via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyLogAnalyticsResources, FirewallPolicyLogAnalyticsResourcesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyLogAnalyticsResources runs a test to see if a specific instance of FirewallPolicyLogAnalyticsResources round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyLogAnalyticsResources(subject FirewallPolicyLogAnalyticsResources) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyLogAnalyticsResources
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyLogAnalyticsResources instances for property testing - lazily instantiated by
// FirewallPolicyLogAnalyticsResourcesGenerator()
var firewallPolicyLogAnalyticsResourcesGenerator gopter.Gen

// FirewallPolicyLogAnalyticsResourcesGenerator returns a generator of FirewallPolicyLogAnalyticsResources instances for property testing.
func FirewallPolicyLogAnalyticsResourcesGenerator() gopter.Gen {
	if firewallPolicyLogAnalyticsResourcesGenerator != nil {
		return firewallPolicyLogAnalyticsResourcesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsResources(generators)
	firewallPolicyLogAnalyticsResourcesGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyLogAnalyticsResources{}), generators)

	return firewallPolicyLogAnalyticsResourcesGenerator
}

// AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsResources is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsResources(gens map[string]gopter.Gen) {
	gens["DefaultWorkspaceId"] = gen.PtrOf(SubResourceGenerator())
	gens["Workspaces"] = gen.SliceOf(FirewallPolicyLogAnalyticsWorkspaceGenerator())
}

func Test_FirewallPolicyLogAnalyticsResources_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyLogAnalyticsResources_STATUS to FirewallPolicyLogAnalyticsResources_STATUS via AssignProperties_To_FirewallPolicyLogAnalyticsResources_STATUS & AssignProperties_From_FirewallPolicyLogAnalyticsResources_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyLogAnalyticsResources_STATUS, FirewallPolicyLogAnalyticsResources_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyLogAnalyticsResources_STATUS tests if a specific instance of FirewallPolicyLogAnalyticsResources_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyLogAnalyticsResources_STATUS(subject FirewallPolicyLogAnalyticsResources_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyLogAnalyticsResources_STATUS
	err := copied.AssignProperties_To_FirewallPolicyLogAnalyticsResources_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyLogAnalyticsResources_STATUS
	err = actual.AssignProperties_From_FirewallPolicyLogAnalyticsResources_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyLogAnalyticsResources_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyLogAnalyticsResources_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyLogAnalyticsResources_STATUS, FirewallPolicyLogAnalyticsResources_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyLogAnalyticsResources_STATUS runs a test to see if a specific instance of FirewallPolicyLogAnalyticsResources_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyLogAnalyticsResources_STATUS(subject FirewallPolicyLogAnalyticsResources_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyLogAnalyticsResources_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyLogAnalyticsResources_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyLogAnalyticsResources_STATUSGenerator()
var firewallPolicyLogAnalyticsResources_STATUSGenerator gopter.Gen

// FirewallPolicyLogAnalyticsResources_STATUSGenerator returns a generator of FirewallPolicyLogAnalyticsResources_STATUS instances for property testing.
func FirewallPolicyLogAnalyticsResources_STATUSGenerator() gopter.Gen {
	if firewallPolicyLogAnalyticsResources_STATUSGenerator != nil {
		return firewallPolicyLogAnalyticsResources_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsResources_STATUS(generators)
	firewallPolicyLogAnalyticsResources_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyLogAnalyticsResources_STATUS{}), generators)

	return firewallPolicyLogAnalyticsResources_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsResources_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsResources_STATUS(gens map[string]gopter.Gen) {
	gens["DefaultWorkspaceId"] = gen.PtrOf(SubResource_STATUSGenerator())
	gens["Workspaces"] = gen.SliceOf(FirewallPolicyLogAnalyticsWorkspace_STATUSGenerator())
}

func Test_FirewallPolicyLogAnalyticsWorkspace_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyLogAnalyticsWorkspace to FirewallPolicyLogAnalyticsWorkspace via AssignProperties_To_FirewallPolicyLogAnalyticsWorkspace & AssignProperties_From_FirewallPolicyLogAnalyticsWorkspace returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyLogAnalyticsWorkspace, FirewallPolicyLogAnalyticsWorkspaceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyLogAnalyticsWorkspace tests if a specific instance of FirewallPolicyLogAnalyticsWorkspace can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyLogAnalyticsWorkspace(subject FirewallPolicyLogAnalyticsWorkspace) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyLogAnalyticsWorkspace
	err := copied.AssignProperties_To_FirewallPolicyLogAnalyticsWorkspace(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyLogAnalyticsWorkspace
	err = actual.AssignProperties_From_FirewallPolicyLogAnalyticsWorkspace(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyLogAnalyticsWorkspace_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyLogAnalyticsWorkspace via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyLogAnalyticsWorkspace, FirewallPolicyLogAnalyticsWorkspaceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyLogAnalyticsWorkspace runs a test to see if a specific instance of FirewallPolicyLogAnalyticsWorkspace round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyLogAnalyticsWorkspace(subject FirewallPolicyLogAnalyticsWorkspace) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyLogAnalyticsWorkspace
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyLogAnalyticsWorkspace instances for property testing - lazily instantiated by
// FirewallPolicyLogAnalyticsWorkspaceGenerator()
var firewallPolicyLogAnalyticsWorkspaceGenerator gopter.Gen

// FirewallPolicyLogAnalyticsWorkspaceGenerator returns a generator of FirewallPolicyLogAnalyticsWorkspace instances for property testing.
// We first initialize firewallPolicyLogAnalyticsWorkspaceGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyLogAnalyticsWorkspaceGenerator() gopter.Gen {
	if firewallPolicyLogAnalyticsWorkspaceGenerator != nil {
		return firewallPolicyLogAnalyticsWorkspaceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace(generators)
	firewallPolicyLogAnalyticsWorkspaceGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyLogAnalyticsWorkspace{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace(generators)
	firewallPolicyLogAnalyticsWorkspaceGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyLogAnalyticsWorkspace{}), generators)

	return firewallPolicyLogAnalyticsWorkspaceGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace(gens map[string]gopter.Gen) {
	gens["Region"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace(gens map[string]gopter.Gen) {
	gens["WorkspaceId"] = gen.PtrOf(SubResourceGenerator())
}

func Test_FirewallPolicyLogAnalyticsWorkspace_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyLogAnalyticsWorkspace_STATUS to FirewallPolicyLogAnalyticsWorkspace_STATUS via AssignProperties_To_FirewallPolicyLogAnalyticsWorkspace_STATUS & AssignProperties_From_FirewallPolicyLogAnalyticsWorkspace_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyLogAnalyticsWorkspace_STATUS, FirewallPolicyLogAnalyticsWorkspace_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyLogAnalyticsWorkspace_STATUS tests if a specific instance of FirewallPolicyLogAnalyticsWorkspace_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyLogAnalyticsWorkspace_STATUS(subject FirewallPolicyLogAnalyticsWorkspace_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyLogAnalyticsWorkspace_STATUS
	err := copied.AssignProperties_To_FirewallPolicyLogAnalyticsWorkspace_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyLogAnalyticsWorkspace_STATUS
	err = actual.AssignProperties_From_FirewallPolicyLogAnalyticsWorkspace_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyLogAnalyticsWorkspace_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyLogAnalyticsWorkspace_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyLogAnalyticsWorkspace_STATUS, FirewallPolicyLogAnalyticsWorkspace_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyLogAnalyticsWorkspace_STATUS runs a test to see if a specific instance of FirewallPolicyLogAnalyticsWorkspace_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyLogAnalyticsWorkspace_STATUS(subject FirewallPolicyLogAnalyticsWorkspace_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyLogAnalyticsWorkspace_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyLogAnalyticsWorkspace_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyLogAnalyticsWorkspace_STATUSGenerator()
var firewallPolicyLogAnalyticsWorkspace_STATUSGenerator gopter.Gen

// FirewallPolicyLogAnalyticsWorkspace_STATUSGenerator returns a generator of FirewallPolicyLogAnalyticsWorkspace_STATUS instances for property testing.
// We first initialize firewallPolicyLogAnalyticsWorkspace_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyLogAnalyticsWorkspace_STATUSGenerator() gopter.Gen {
	if firewallPolicyLogAnalyticsWorkspace_STATUSGenerator != nil {
		return firewallPolicyLogAnalyticsWorkspace_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace_STATUS(generators)
	firewallPolicyLogAnalyticsWorkspace_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyLogAnalyticsWorkspace_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace_STATUS(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace_STATUS(generators)
	firewallPolicyLogAnalyticsWorkspace_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyLogAnalyticsWorkspace_STATUS{}), generators)

	return firewallPolicyLogAnalyticsWorkspace_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace_STATUS(gens map[string]gopter.Gen) {
	gens["Region"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace_STATUS(gens map[string]gopter.Gen) {
	gens["WorkspaceId"] = gen.PtrOf(SubResource_STATUSGenerator())
}

func Test_FirewallPolicyOperatorSpec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyOperatorSpec to FirewallPolicyOperatorSpec via AssignProperties_To_FirewallPolicyOperatorSpec & AssignProperties_From_FirewallPolicyOperatorSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyOperatorSpec, FirewallPolicyOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyOperatorSpec tests if a specific instance of FirewallPolicyOperatorSpec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyOperatorSpec(subject FirewallPolicyOperatorSpec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyOperatorSpec
	err := copied.AssignProperties_To_FirewallPolicyOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyOperatorSpec
	err = actual.AssignProperties_From_FirewallPolicyOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyOperatorSpec, FirewallPolicyOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyOperatorSpec runs a test to see if a specific instance of FirewallPolicyOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyOperatorSpec(subject FirewallPolicyOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyOperatorSpec instances for property testing - lazily instantiated by
// FirewallPolicyOperatorSpecGenerator()
var firewallPolicyOperatorSpecGenerator gopter.Gen

// FirewallPolicyOperatorSpecGenerator returns a generator of FirewallPolicyOperatorSpec instances for property testing.
func FirewallPolicyOperatorSpecGenerator() gopter.Gen {
	if firewallPolicyOperatorSpecGenerator != nil {
		return firewallPolicyOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	firewallPolicyOperatorSpecGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyOperatorSpec{}), generators)

	return firewallPolicyOperatorSpecGenerator
}

func Test_FirewallPolicySNAT_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicySNAT to FirewallPolicySNAT via AssignProperties_To_FirewallPolicySNAT & AssignProperties_From_FirewallPolicySNAT returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicySNAT, FirewallPolicySNATGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicySNAT tests if a specific instance of FirewallPolicySNAT can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicySNAT(subject FirewallPolicySNAT) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicySNAT
	err := copied.AssignProperties_To_FirewallPolicySNAT(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicySNAT
	err = actual.AssignProperties_From_FirewallPolicySNAT(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicySNAT_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicySNAT via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicySNAT, FirewallPolicySNATGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicySNAT runs a test to see if a specific instance of FirewallPolicySNAT round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicySNAT(subject FirewallPolicySNAT) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicySNAT
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicySNAT instances for property testing - lazily instantiated by FirewallPolicySNATGenerator()
var firewallPolicySNATGenerator gopter.Gen

// FirewallPolicySNATGenerator returns a generator of FirewallPolicySNAT instances for property testing.
func FirewallPolicySNATGenerator() gopter.Gen {
	if firewallPolicySNATGenerator != nil {
		return firewallPolicySNATGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicySNAT(generators)
	firewallPolicySNATGenerator = gen.Struct(reflect.TypeOf(FirewallPolicySNAT{}), generators)

	return firewallPolicySNATGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicySNAT is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicySNAT(gens map[string]gopter.Gen) {
	gens["AutoLearnPrivateRanges"] = gen.PtrOf(gen.OneConstOf(FirewallPolicySNAT_AutoLearnPrivateRanges_Disabled, FirewallPolicySNAT_AutoLearnPrivateRanges_Enabled))
	gens["PrivateRanges"] = gen.SliceOf(gen.AlphaString())
}

func Test_FirewallPolicySNAT_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicySNAT_STATUS to FirewallPolicySNAT_STATUS via AssignProperties_To_FirewallPolicySNAT_STATUS & AssignProperties_From_FirewallPolicySNAT_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicySNAT_STATUS, FirewallPolicySNAT_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicySNAT_STATUS tests if a specific instance of FirewallPolicySNAT_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicySNAT_STATUS(subject FirewallPolicySNAT_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicySNAT_STATUS
	err := copied.AssignProperties_To_FirewallPolicySNAT_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicySNAT_STATUS
	err = actual.AssignProperties_From_FirewallPolicySNAT_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicySNAT_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicySNAT_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicySNAT_STATUS, FirewallPolicySNAT_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicySNAT_STATUS runs a test to see if a specific instance of FirewallPolicySNAT_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicySNAT_STATUS(subject FirewallPolicySNAT_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicySNAT_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicySNAT_STATUS instances for property testing - lazily instantiated by
// FirewallPolicySNAT_STATUSGenerator()
var firewallPolicySNAT_STATUSGenerator gopter.Gen

// FirewallPolicySNAT_STATUSGenerator returns a generator of FirewallPolicySNAT_STATUS instances for property testing.
func FirewallPolicySNAT_STATUSGenerator() gopter.Gen {
	if firewallPolicySNAT_STATUSGenerator != nil {
		return firewallPolicySNAT_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicySNAT_STATUS(generators)
	firewallPolicySNAT_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicySNAT_STATUS{}), generators)

	return firewallPolicySNAT_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicySNAT_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicySNAT_STATUS(gens map[string]gopter.Gen) {
	gens["AutoLearnPrivateRanges"] = gen.PtrOf(gen.OneConstOf(FirewallPolicySNAT_AutoLearnPrivateRanges_STATUS_Disabled, FirewallPolicySNAT_AutoLearnPrivateRanges_STATUS_Enabled))
	gens["PrivateRanges"] = gen.SliceOf(gen.AlphaString())
}

func Test_FirewallPolicySQL_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicySQL to FirewallPolicySQL via AssignProperties_To_FirewallPolicySQL & AssignProperties_From_FirewallPolicySQL returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicySQL, FirewallPolicySQLGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicySQL tests if a specific instance of FirewallPolicySQL can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicySQL(subject FirewallPolicySQL) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicySQL
	err := copied.AssignProperties_To_FirewallPolicySQL(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicySQL
	err = actual.AssignProperties_From_FirewallPolicySQL(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicySQL_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicySQL via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicySQL, FirewallPolicySQLGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicySQL runs a test to see if a specific instance of FirewallPolicySQL round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicySQL(subject FirewallPolicySQL) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicySQL
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicySQL instances for property testing - lazily instantiated by FirewallPolicySQLGenerator()
var firewallPolicySQLGenerator gopter.Gen

// FirewallPolicySQLGenerator returns a generator of FirewallPolicySQL instances for property testing.
func FirewallPolicySQLGenerator() gopter.Gen {
	if firewallPolicySQLGenerator != nil {
		return firewallPolicySQLGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicySQL(generators)
	firewallPolicySQLGenerator = gen.Struct(reflect.TypeOf(FirewallPolicySQL{}), generators)

	return firewallPolicySQLGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicySQL is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicySQL(gens map[string]gopter.Gen) {
	gens["AllowSqlRedirect"] = gen.PtrOf(gen.Bool())
}

func Test_FirewallPolicySQL_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicySQL_STATUS to FirewallPolicySQL_STATUS via AssignProperties_To_FirewallPolicySQL_STATUS & AssignProperties_From_FirewallPolicySQL_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicySQL_STATUS, FirewallPolicySQL_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicySQL_STATUS tests if a specific instance of FirewallPolicySQL_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicySQL_STATUS(subject FirewallPolicySQL_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicySQL_STATUS
	err := copied.AssignProperties_To_FirewallPolicySQL_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicySQL_STATUS
	err = actual.AssignProperties_From_FirewallPolicySQL_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicySQL_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicySQL_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicySQL_STATUS, FirewallPolicySQL_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicySQL_STATUS runs a test to see if a specific instance of FirewallPolicySQL_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicySQL_STATUS(subject FirewallPolicySQL_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicySQL_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicySQL_STATUS instances for property testing - lazily instantiated by
// FirewallPolicySQL_STATUSGenerator()
var firewallPolicySQL_STATUSGenerator gopter.Gen

// FirewallPolicySQL_STATUSGenerator returns a generator of FirewallPolicySQL_STATUS instances for property testing.
func FirewallPolicySQL_STATUSGenerator() gopter.Gen {
	if firewallPolicySQL_STATUSGenerator != nil {
		return firewallPolicySQL_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicySQL_STATUS(generators)
	firewallPolicySQL_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicySQL_STATUS{}), generators)

	return firewallPolicySQL_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicySQL_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicySQL_STATUS(gens map[string]gopter.Gen) {
	gens["AllowSqlRedirect"] = gen.PtrOf(gen.Bool())
}

func Test_FirewallPolicySku_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicySku to FirewallPolicySku via AssignProperties_To_FirewallPolicySku & AssignProperties_From_FirewallPolicySku returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicySku, FirewallPolicySkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicySku tests if a specific instance of FirewallPolicySku can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicySku(subject FirewallPolicySku) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicySku
	err := copied.AssignProperties_To_FirewallPolicySku(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicySku
	err = actual.AssignProperties_From_FirewallPolicySku(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicySku_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicySku via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicySku, FirewallPolicySkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicySku runs a test to see if a specific instance of FirewallPolicySku round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicySku(subject FirewallPolicySku) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicySku
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicySku instances for property testing - lazily instantiated by FirewallPolicySkuGenerator()
var firewallPolicySkuGenerator gopter.Gen

// FirewallPolicySkuGenerator returns a generator of FirewallPolicySku instances for property testing.
func FirewallPolicySkuGenerator() gopter.Gen {
	if firewallPolicySkuGenerator != nil {
		return firewallPolicySkuGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicySku(generators)
	firewallPolicySkuGenerator = gen.Struct(reflect.TypeOf(FirewallPolicySku{}), generators)

	return firewallPolicySkuGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicySku is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicySku(gens map[string]gopter.Gen) {
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(FirewallPolicySku_Tier_Basic, FirewallPolicySku_Tier_Premium, FirewallPolicySku_Tier_Standard))
}

func Test_FirewallPolicySku_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicySku_STATUS to FirewallPolicySku_STATUS via AssignProperties_To_FirewallPolicySku_STATUS & AssignProperties_From_FirewallPolicySku_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicySku_STATUS, FirewallPolicySku_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicySku_STATUS tests if a specific instance of FirewallPolicySku_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicySku_STATUS(subject FirewallPolicySku_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicySku_STATUS
	err := copied.AssignProperties_To_FirewallPolicySku_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicySku_STATUS
	err = actual.AssignProperties_From_FirewallPolicySku_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicySku_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicySku_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicySku_STATUS, FirewallPolicySku_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicySku_STATUS runs a test to see if a specific instance of FirewallPolicySku_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicySku_STATUS(subject FirewallPolicySku_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicySku_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicySku_STATUS instances for property testing - lazily instantiated by
// FirewallPolicySku_STATUSGenerator()
var firewallPolicySku_STATUSGenerator gopter.Gen

// FirewallPolicySku_STATUSGenerator returns a generator of FirewallPolicySku_STATUS instances for property testing.
func FirewallPolicySku_STATUSGenerator() gopter.Gen {
	if firewallPolicySku_STATUSGenerator != nil {
		return firewallPolicySku_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicySku_STATUS(generators)
	firewallPolicySku_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicySku_STATUS{}), generators)

	return firewallPolicySku_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicySku_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicySku_STATUS(gens map[string]gopter.Gen) {
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(FirewallPolicySku_Tier_STATUS_Basic, FirewallPolicySku_Tier_STATUS_Premium, FirewallPolicySku_Tier_STATUS_Standard))
}

func Test_FirewallPolicyThreatIntelWhitelist_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyThreatIntelWhitelist to FirewallPolicyThreatIntelWhitelist via AssignProperties_To_FirewallPolicyThreatIntelWhitelist & AssignProperties_From_FirewallPolicyThreatIntelWhitelist returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyThreatIntelWhitelist, FirewallPolicyThreatIntelWhitelistGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyThreatIntelWhitelist tests if a specific instance of FirewallPolicyThreatIntelWhitelist can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyThreatIntelWhitelist(subject FirewallPolicyThreatIntelWhitelist) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyThreatIntelWhitelist
	err := copied.AssignProperties_To_FirewallPolicyThreatIntelWhitelist(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyThreatIntelWhitelist
	err = actual.AssignProperties_From_FirewallPolicyThreatIntelWhitelist(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyThreatIntelWhitelist_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyThreatIntelWhitelist via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyThreatIntelWhitelist, FirewallPolicyThreatIntelWhitelistGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyThreatIntelWhitelist runs a test to see if a specific instance of FirewallPolicyThreatIntelWhitelist round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyThreatIntelWhitelist(subject FirewallPolicyThreatIntelWhitelist) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyThreatIntelWhitelist
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyThreatIntelWhitelist instances for property testing - lazily instantiated by
// FirewallPolicyThreatIntelWhitelistGenerator()
var firewallPolicyThreatIntelWhitelistGenerator gopter.Gen

// FirewallPolicyThreatIntelWhitelistGenerator returns a generator of FirewallPolicyThreatIntelWhitelist instances for property testing.
func FirewallPolicyThreatIntelWhitelistGenerator() gopter.Gen {
	if firewallPolicyThreatIntelWhitelistGenerator != nil {
		return firewallPolicyThreatIntelWhitelistGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyThreatIntelWhitelist(generators)
	firewallPolicyThreatIntelWhitelistGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyThreatIntelWhitelist{}), generators)

	return firewallPolicyThreatIntelWhitelistGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyThreatIntelWhitelist is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyThreatIntelWhitelist(gens map[string]gopter.Gen) {
	gens["Fqdns"] = gen.SliceOf(gen.AlphaString())
	gens["IpAddresses"] = gen.SliceOf(gen.AlphaString())
}

func Test_FirewallPolicyThreatIntelWhitelist_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyThreatIntelWhitelist_STATUS to FirewallPolicyThreatIntelWhitelist_STATUS via AssignProperties_To_FirewallPolicyThreatIntelWhitelist_STATUS & AssignProperties_From_FirewallPolicyThreatIntelWhitelist_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyThreatIntelWhitelist_STATUS, FirewallPolicyThreatIntelWhitelist_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyThreatIntelWhitelist_STATUS tests if a specific instance of FirewallPolicyThreatIntelWhitelist_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyThreatIntelWhitelist_STATUS(subject FirewallPolicyThreatIntelWhitelist_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyThreatIntelWhitelist_STATUS
	err := copied.AssignProperties_To_FirewallPolicyThreatIntelWhitelist_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyThreatIntelWhitelist_STATUS
	err = actual.AssignProperties_From_FirewallPolicyThreatIntelWhitelist_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyThreatIntelWhitelist_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyThreatIntelWhitelist_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyThreatIntelWhitelist_STATUS, FirewallPolicyThreatIntelWhitelist_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyThreatIntelWhitelist_STATUS runs a test to see if a specific instance of FirewallPolicyThreatIntelWhitelist_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyThreatIntelWhitelist_STATUS(subject FirewallPolicyThreatIntelWhitelist_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyThreatIntelWhitelist_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyThreatIntelWhitelist_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyThreatIntelWhitelist_STATUSGenerator()
var firewallPolicyThreatIntelWhitelist_STATUSGenerator gopter.Gen

// FirewallPolicyThreatIntelWhitelist_STATUSGenerator returns a generator of FirewallPolicyThreatIntelWhitelist_STATUS instances for property testing.
func FirewallPolicyThreatIntelWhitelist_STATUSGenerator() gopter.Gen {
	if firewallPolicyThreatIntelWhitelist_STATUSGenerator != nil {
		return firewallPolicyThreatIntelWhitelist_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyThreatIntelWhitelist_STATUS(generators)
	firewallPolicyThreatIntelWhitelist_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyThreatIntelWhitelist_STATUS{}), generators)

	return firewallPolicyThreatIntelWhitelist_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyThreatIntelWhitelist_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyThreatIntelWhitelist_STATUS(gens map[string]gopter.Gen) {
	gens["Fqdns"] = gen.SliceOf(gen.AlphaString())
	gens["IpAddresses"] = gen.SliceOf(gen.AlphaString())
}

func Test_FirewallPolicyTransportSecurity_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyTransportSecurity to FirewallPolicyTransportSecurity via AssignProperties_To_FirewallPolicyTransportSecurity & AssignProperties_From_FirewallPolicyTransportSecurity returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyTransportSecurity, FirewallPolicyTransportSecurityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyTransportSecurity tests if a specific instance of FirewallPolicyTransportSecurity can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyTransportSecurity(subject FirewallPolicyTransportSecurity) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyTransportSecurity
	err := copied.AssignProperties_To_FirewallPolicyTransportSecurity(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyTransportSecurity
	err = actual.AssignProperties_From_FirewallPolicyTransportSecurity(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyTransportSecurity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyTransportSecurity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyTransportSecurity, FirewallPolicyTransportSecurityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyTransportSecurity runs a test to see if a specific instance of FirewallPolicyTransportSecurity round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyTransportSecurity(subject FirewallPolicyTransportSecurity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyTransportSecurity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyTransportSecurity instances for property testing - lazily instantiated by
// FirewallPolicyTransportSecurityGenerator()
var firewallPolicyTransportSecurityGenerator gopter.Gen

// FirewallPolicyTransportSecurityGenerator returns a generator of FirewallPolicyTransportSecurity instances for property testing.
func FirewallPolicyTransportSecurityGenerator() gopter.Gen {
	if firewallPolicyTransportSecurityGenerator != nil {
		return firewallPolicyTransportSecurityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForFirewallPolicyTransportSecurity(generators)
	firewallPolicyTransportSecurityGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyTransportSecurity{}), generators)

	return firewallPolicyTransportSecurityGenerator
}

// AddRelatedPropertyGeneratorsForFirewallPolicyTransportSecurity is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyTransportSecurity(gens map[string]gopter.Gen) {
	gens["CertificateAuthority"] = gen.PtrOf(FirewallPolicyCertificateAuthorityGenerator())
}

func Test_FirewallPolicyTransportSecurity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicyTransportSecurity_STATUS to FirewallPolicyTransportSecurity_STATUS via AssignProperties_To_FirewallPolicyTransportSecurity_STATUS & AssignProperties_From_FirewallPolicyTransportSecurity_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicyTransportSecurity_STATUS, FirewallPolicyTransportSecurity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicyTransportSecurity_STATUS tests if a specific instance of FirewallPolicyTransportSecurity_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicyTransportSecurity_STATUS(subject FirewallPolicyTransportSecurity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicyTransportSecurity_STATUS
	err := copied.AssignProperties_To_FirewallPolicyTransportSecurity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicyTransportSecurity_STATUS
	err = actual.AssignProperties_From_FirewallPolicyTransportSecurity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicyTransportSecurity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyTransportSecurity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyTransportSecurity_STATUS, FirewallPolicyTransportSecurity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyTransportSecurity_STATUS runs a test to see if a specific instance of FirewallPolicyTransportSecurity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyTransportSecurity_STATUS(subject FirewallPolicyTransportSecurity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyTransportSecurity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyTransportSecurity_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyTransportSecurity_STATUSGenerator()
var firewallPolicyTransportSecurity_STATUSGenerator gopter.Gen

// FirewallPolicyTransportSecurity_STATUSGenerator returns a generator of FirewallPolicyTransportSecurity_STATUS instances for property testing.
func FirewallPolicyTransportSecurity_STATUSGenerator() gopter.Gen {
	if firewallPolicyTransportSecurity_STATUSGenerator != nil {
		return firewallPolicyTransportSecurity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForFirewallPolicyTransportSecurity_STATUS(generators)
	firewallPolicyTransportSecurity_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyTransportSecurity_STATUS{}), generators)

	return firewallPolicyTransportSecurity_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForFirewallPolicyTransportSecurity_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyTransportSecurity_STATUS(gens map[string]gopter.Gen) {
	gens["CertificateAuthority"] = gen.PtrOf(FirewallPolicyCertificateAuthority_STATUSGenerator())
}

func Test_FirewallPolicy_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicy_STATUS to FirewallPolicy_STATUS via AssignProperties_To_FirewallPolicy_STATUS & AssignProperties_From_FirewallPolicy_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicy_STATUS, FirewallPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicy_STATUS tests if a specific instance of FirewallPolicy_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicy_STATUS(subject FirewallPolicy_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicy_STATUS
	err := copied.AssignProperties_To_FirewallPolicy_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicy_STATUS
	err = actual.AssignProperties_From_FirewallPolicy_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicy_STATUS, FirewallPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicy_STATUS runs a test to see if a specific instance of FirewallPolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicy_STATUS(subject FirewallPolicy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicy_STATUS instances for property testing - lazily instantiated by
// FirewallPolicy_STATUSGenerator()
var firewallPolicy_STATUSGenerator gopter.Gen

// FirewallPolicy_STATUSGenerator returns a generator of FirewallPolicy_STATUS instances for property testing.
// We first initialize firewallPolicy_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicy_STATUSGenerator() gopter.Gen {
	if firewallPolicy_STATUSGenerator != nil {
		return firewallPolicy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicy_STATUS(generators)
	firewallPolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicy_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicy_STATUS(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicy_STATUS(generators)
	firewallPolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicy_STATUS{}), generators)

	return firewallPolicy_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicy_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicy_STATUS(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Updating))
	gens["Size"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["ThreatIntelMode"] = gen.PtrOf(gen.OneConstOf(AzureFirewallThreatIntelMode_STATUS_Alert, AzureFirewallThreatIntelMode_STATUS_Deny, AzureFirewallThreatIntelMode_STATUS_Off))
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFirewallPolicy_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicy_STATUS(gens map[string]gopter.Gen) {
	gens["BasePolicy"] = gen.PtrOf(SubResource_STATUSGenerator())
	gens["ChildPolicies"] = gen.SliceOf(SubResource_STATUSGenerator())
	gens["DnsSettings"] = gen.PtrOf(DnsSettings_STATUSGenerator())
	gens["ExplicitProxy"] = gen.PtrOf(ExplicitProxy_STATUSGenerator())
	gens["Firewalls"] = gen.SliceOf(SubResource_STATUSGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentity_STATUSGenerator())
	gens["Insights"] = gen.PtrOf(FirewallPolicyInsights_STATUSGenerator())
	gens["IntrusionDetection"] = gen.PtrOf(FirewallPolicyIntrusionDetection_STATUSGenerator())
	gens["RuleCollectionGroups"] = gen.SliceOf(SubResource_STATUSGenerator())
	gens["Sku"] = gen.PtrOf(FirewallPolicySku_STATUSGenerator())
	gens["Snat"] = gen.PtrOf(FirewallPolicySNAT_STATUSGenerator())
	gens["Sql"] = gen.PtrOf(FirewallPolicySQL_STATUSGenerator())
	gens["ThreatIntelWhitelist"] = gen.PtrOf(FirewallPolicyThreatIntelWhitelist_STATUSGenerator())
	gens["TransportSecurity"] = gen.PtrOf(FirewallPolicyTransportSecurity_STATUSGenerator())
}

func Test_FirewallPolicy_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FirewallPolicy_Spec to FirewallPolicy_Spec via AssignProperties_To_FirewallPolicy_Spec & AssignProperties_From_FirewallPolicy_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForFirewallPolicy_Spec, FirewallPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFirewallPolicy_Spec tests if a specific instance of FirewallPolicy_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFirewallPolicy_Spec(subject FirewallPolicy_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FirewallPolicy_Spec
	err := copied.AssignProperties_To_FirewallPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FirewallPolicy_Spec
	err = actual.AssignProperties_From_FirewallPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FirewallPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicy_Spec, FirewallPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicy_Spec runs a test to see if a specific instance of FirewallPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicy_Spec(subject FirewallPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicy_Spec instances for property testing - lazily instantiated by
// FirewallPolicy_SpecGenerator()
var firewallPolicy_SpecGenerator gopter.Gen

// FirewallPolicy_SpecGenerator returns a generator of FirewallPolicy_Spec instances for property testing.
// We first initialize firewallPolicy_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicy_SpecGenerator() gopter.Gen {
	if firewallPolicy_SpecGenerator != nil {
		return firewallPolicy_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicy_Spec(generators)
	firewallPolicy_SpecGenerator = gen.Struct(reflect.TypeOf(FirewallPolicy_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicy_Spec(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicy_Spec(generators)
	firewallPolicy_SpecGenerator = gen.Struct(reflect.TypeOf(FirewallPolicy_Spec{}), generators)

	return firewallPolicy_SpecGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicy_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicy_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["ThreatIntelMode"] = gen.PtrOf(gen.OneConstOf(AzureFirewallThreatIntelMode_Alert, AzureFirewallThreatIntelMode_Deny, AzureFirewallThreatIntelMode_Off))
}

// AddRelatedPropertyGeneratorsForFirewallPolicy_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicy_Spec(gens map[string]gopter.Gen) {
	gens["BasePolicy"] = gen.PtrOf(SubResourceGenerator())
	gens["DnsSettings"] = gen.PtrOf(DnsSettingsGenerator())
	gens["ExplicitProxy"] = gen.PtrOf(ExplicitProxyGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentityGenerator())
	gens["Insights"] = gen.PtrOf(FirewallPolicyInsightsGenerator())
	gens["IntrusionDetection"] = gen.PtrOf(FirewallPolicyIntrusionDetectionGenerator())
	gens["OperatorSpec"] = gen.PtrOf(FirewallPolicyOperatorSpecGenerator())
	gens["Sku"] = gen.PtrOf(FirewallPolicySkuGenerator())
	gens["Snat"] = gen.PtrOf(FirewallPolicySNATGenerator())
	gens["Sql"] = gen.PtrOf(FirewallPolicySQLGenerator())
	gens["ThreatIntelWhitelist"] = gen.PtrOf(FirewallPolicyThreatIntelWhitelistGenerator())
	gens["TransportSecurity"] = gen.PtrOf(FirewallPolicyTransportSecurityGenerator())
}

func Test_ManagedServiceIdentity_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedServiceIdentity to ManagedServiceIdentity via AssignProperties_To_ManagedServiceIdentity & AssignProperties_From_ManagedServiceIdentity returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedServiceIdentity, ManagedServiceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedServiceIdentity tests if a specific instance of ManagedServiceIdentity can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedServiceIdentity(subject ManagedServiceIdentity) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedServiceIdentity
	err := copied.AssignProperties_To_ManagedServiceIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedServiceIdentity
	err = actual.AssignProperties_From_ManagedServiceIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedServiceIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity, ManagedServiceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity runs a test to see if a specific instance of ManagedServiceIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity(subject ManagedServiceIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity instances for property testing - lazily instantiated by
// ManagedServiceIdentityGenerator()
var managedServiceIdentityGenerator gopter.Gen

// ManagedServiceIdentityGenerator returns a generator of ManagedServiceIdentity instances for property testing.
// We first initialize managedServiceIdentityGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentityGenerator() gopter.Gen {
	if managedServiceIdentityGenerator != nil {
		return managedServiceIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity(generators)
	managedServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentity(generators)
	managedServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity{}), generators)

	return managedServiceIdentityGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentity_Type_None,
		ManagedServiceIdentity_Type_SystemAssigned,
		ManagedServiceIdentity_Type_SystemAssignedUserAssigned,
		ManagedServiceIdentity_Type_UserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentity is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentity(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.SliceOf(UserAssignedIdentityDetailsGenerator())
}

func Test_ManagedServiceIdentity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedServiceIdentity_STATUS to ManagedServiceIdentity_STATUS via AssignProperties_To_ManagedServiceIdentity_STATUS & AssignProperties_From_ManagedServiceIdentity_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedServiceIdentity_STATUS, ManagedServiceIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedServiceIdentity_STATUS tests if a specific instance of ManagedServiceIdentity_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedServiceIdentity_STATUS(subject ManagedServiceIdentity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedServiceIdentity_STATUS
	err := copied.AssignProperties_To_ManagedServiceIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedServiceIdentity_STATUS
	err = actual.AssignProperties_From_ManagedServiceIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedServiceIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity_STATUS, ManagedServiceIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity_STATUS runs a test to see if a specific instance of ManagedServiceIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity_STATUS(subject ManagedServiceIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_STATUS instances for property testing - lazily instantiated by
// ManagedServiceIdentity_STATUSGenerator()
var managedServiceIdentity_STATUSGenerator gopter.Gen

// ManagedServiceIdentity_STATUSGenerator returns a generator of ManagedServiceIdentity_STATUS instances for property testing.
// We first initialize managedServiceIdentity_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentity_STATUSGenerator() gopter.Gen {
	if managedServiceIdentity_STATUSGenerator != nil {
		return managedServiceIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS(generators)
	managedServiceIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUS(generators)
	managedServiceIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_STATUS{}), generators)

	return managedServiceIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentity_Type_STATUS_None,
		ManagedServiceIdentity_Type_STATUS_SystemAssigned,
		ManagedServiceIdentity_Type_STATUS_SystemAssignedUserAssigned,
		ManagedServiceIdentity_Type_STATUS_UserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(
		gen.AlphaString(),
		ManagedServiceIdentity_UserAssignedIdentities_STATUSGenerator())
}

func Test_ManagedServiceIdentity_UserAssignedIdentities_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedServiceIdentity_UserAssignedIdentities_STATUS to ManagedServiceIdentity_UserAssignedIdentities_STATUS via AssignProperties_To_ManagedServiceIdentity_UserAssignedIdentities_STATUS & AssignProperties_From_ManagedServiceIdentity_UserAssignedIdentities_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedServiceIdentity_UserAssignedIdentities_STATUS, ManagedServiceIdentity_UserAssignedIdentities_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedServiceIdentity_UserAssignedIdentities_STATUS tests if a specific instance of ManagedServiceIdentity_UserAssignedIdentities_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedServiceIdentity_UserAssignedIdentities_STATUS(subject ManagedServiceIdentity_UserAssignedIdentities_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedServiceIdentity_UserAssignedIdentities_STATUS
	err := copied.AssignProperties_To_ManagedServiceIdentity_UserAssignedIdentities_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedServiceIdentity_UserAssignedIdentities_STATUS
	err = actual.AssignProperties_From_ManagedServiceIdentity_UserAssignedIdentities_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedServiceIdentity_UserAssignedIdentities_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_UserAssignedIdentities_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity_UserAssignedIdentities_STATUS, ManagedServiceIdentity_UserAssignedIdentities_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity_UserAssignedIdentities_STATUS runs a test to see if a specific instance of ManagedServiceIdentity_UserAssignedIdentities_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity_UserAssignedIdentities_STATUS(subject ManagedServiceIdentity_UserAssignedIdentities_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_UserAssignedIdentities_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_UserAssignedIdentities_STATUS instances for property testing - lazily
// instantiated by ManagedServiceIdentity_UserAssignedIdentities_STATUSGenerator()
var managedServiceIdentity_UserAssignedIdentities_STATUSGenerator gopter.Gen

// ManagedServiceIdentity_UserAssignedIdentities_STATUSGenerator returns a generator of ManagedServiceIdentity_UserAssignedIdentities_STATUS instances for property testing.
func ManagedServiceIdentity_UserAssignedIdentities_STATUSGenerator() gopter.Gen {
	if managedServiceIdentity_UserAssignedIdentities_STATUSGenerator != nil {
		return managedServiceIdentity_UserAssignedIdentities_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_UserAssignedIdentities_STATUS(generators)
	managedServiceIdentity_UserAssignedIdentities_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_UserAssignedIdentities_STATUS{}), generators)

	return managedServiceIdentity_UserAssignedIdentities_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity_UserAssignedIdentities_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity_UserAssignedIdentities_STATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserAssignedIdentityDetails_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserAssignedIdentityDetails to UserAssignedIdentityDetails via AssignProperties_To_UserAssignedIdentityDetails & AssignProperties_From_UserAssignedIdentityDetails returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserAssignedIdentityDetails tests if a specific instance of UserAssignedIdentityDetails can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.UserAssignedIdentityDetails
	err := copied.AssignProperties_To_UserAssignedIdentityDetails(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserAssignedIdentityDetails
	err = actual.AssignProperties_From_UserAssignedIdentityDetails(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserAssignedIdentityDetails_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails runs a test to see if a specific instance of UserAssignedIdentityDetails round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails instances for property testing - lazily instantiated by
// UserAssignedIdentityDetailsGenerator()
var userAssignedIdentityDetailsGenerator gopter.Gen

// UserAssignedIdentityDetailsGenerator returns a generator of UserAssignedIdentityDetails instances for property testing.
func UserAssignedIdentityDetailsGenerator() gopter.Gen {
	if userAssignedIdentityDetailsGenerator != nil {
		return userAssignedIdentityDetailsGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetailsGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails{}), generators)

	return userAssignedIdentityDetailsGenerator
}
