// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ApplicationRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationRule, ApplicationRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationRule runs a test to see if a specific instance of ApplicationRule round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationRule(subject ApplicationRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationRule instances for property testing - lazily instantiated by ApplicationRuleGenerator()
var applicationRuleGenerator gopter.Gen

// ApplicationRuleGenerator returns a generator of ApplicationRule instances for property testing.
// We first initialize applicationRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApplicationRuleGenerator() gopter.Gen {
	if applicationRuleGenerator != nil {
		return applicationRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationRule(generators)
	applicationRuleGenerator = gen.Struct(reflect.TypeOf(ApplicationRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationRule(generators)
	AddRelatedPropertyGeneratorsForApplicationRule(generators)
	applicationRuleGenerator = gen.Struct(reflect.TypeOf(ApplicationRule{}), generators)

	return applicationRuleGenerator
}

// AddIndependentPropertyGeneratorsForApplicationRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApplicationRule(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DestinationAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["FqdnTags"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["RuleType"] = gen.OneConstOf(ApplicationRule_RuleType_ApplicationRule)
	gens["SourceAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["SourceIpGroups"] = gen.SliceOf(gen.AlphaString())
	gens["TargetFqdns"] = gen.SliceOf(gen.AlphaString())
	gens["TargetUrls"] = gen.SliceOf(gen.AlphaString())
	gens["TerminateTLS"] = gen.PtrOf(gen.Bool())
	gens["WebCategories"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForApplicationRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApplicationRule(gens map[string]gopter.Gen) {
	gens["HttpHeadersToInsert"] = gen.SliceOf(FirewallPolicyHttpHeaderToInsertGenerator())
	gens["Protocols"] = gen.SliceOf(FirewallPolicyRuleApplicationProtocolGenerator())
}

func Test_FirewallPoliciesRuleCollectionGroup_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPoliciesRuleCollectionGroup_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPoliciesRuleCollectionGroup_Spec, FirewallPoliciesRuleCollectionGroup_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPoliciesRuleCollectionGroup_Spec runs a test to see if a specific instance of FirewallPoliciesRuleCollectionGroup_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPoliciesRuleCollectionGroup_Spec(subject FirewallPoliciesRuleCollectionGroup_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPoliciesRuleCollectionGroup_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPoliciesRuleCollectionGroup_Spec instances for property testing - lazily instantiated by
// FirewallPoliciesRuleCollectionGroup_SpecGenerator()
var firewallPoliciesRuleCollectionGroup_SpecGenerator gopter.Gen

// FirewallPoliciesRuleCollectionGroup_SpecGenerator returns a generator of FirewallPoliciesRuleCollectionGroup_Spec instances for property testing.
// We first initialize firewallPoliciesRuleCollectionGroup_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPoliciesRuleCollectionGroup_SpecGenerator() gopter.Gen {
	if firewallPoliciesRuleCollectionGroup_SpecGenerator != nil {
		return firewallPoliciesRuleCollectionGroup_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup_Spec(generators)
	firewallPoliciesRuleCollectionGroup_SpecGenerator = gen.Struct(reflect.TypeOf(FirewallPoliciesRuleCollectionGroup_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup_Spec(generators)
	AddRelatedPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup_Spec(generators)
	firewallPoliciesRuleCollectionGroup_SpecGenerator = gen.Struct(reflect.TypeOf(FirewallPoliciesRuleCollectionGroup_Spec{}), generators)

	return firewallPoliciesRuleCollectionGroup_SpecGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup_Spec(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(FirewallPolicyRuleCollectionGroupPropertiesGenerator())
}

func Test_FirewallPolicyFilterRuleCollection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyFilterRuleCollection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyFilterRuleCollection, FirewallPolicyFilterRuleCollectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyFilterRuleCollection runs a test to see if a specific instance of FirewallPolicyFilterRuleCollection round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyFilterRuleCollection(subject FirewallPolicyFilterRuleCollection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyFilterRuleCollection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyFilterRuleCollection instances for property testing - lazily instantiated by
// FirewallPolicyFilterRuleCollectionGenerator()
var firewallPolicyFilterRuleCollectionGenerator gopter.Gen

// FirewallPolicyFilterRuleCollectionGenerator returns a generator of FirewallPolicyFilterRuleCollection instances for property testing.
// We first initialize firewallPolicyFilterRuleCollectionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyFilterRuleCollectionGenerator() gopter.Gen {
	if firewallPolicyFilterRuleCollectionGenerator != nil {
		return firewallPolicyFilterRuleCollectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyFilterRuleCollection(generators)
	firewallPolicyFilterRuleCollectionGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyFilterRuleCollection{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyFilterRuleCollection(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyFilterRuleCollection(generators)
	firewallPolicyFilterRuleCollectionGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyFilterRuleCollection{}), generators)

	return firewallPolicyFilterRuleCollectionGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyFilterRuleCollection is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyFilterRuleCollection(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["RuleCollectionType"] = gen.OneConstOf(FirewallPolicyFilterRuleCollection_RuleCollectionType_FirewallPolicyFilterRuleCollection)
}

// AddRelatedPropertyGeneratorsForFirewallPolicyFilterRuleCollection is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyFilterRuleCollection(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(FirewallPolicyFilterRuleCollectionActionGenerator())
	gens["Rules"] = gen.SliceOf(FirewallPolicyRuleGenerator())
}

func Test_FirewallPolicyFilterRuleCollectionAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyFilterRuleCollectionAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyFilterRuleCollectionAction, FirewallPolicyFilterRuleCollectionActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyFilterRuleCollectionAction runs a test to see if a specific instance of FirewallPolicyFilterRuleCollectionAction round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyFilterRuleCollectionAction(subject FirewallPolicyFilterRuleCollectionAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyFilterRuleCollectionAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyFilterRuleCollectionAction instances for property testing - lazily instantiated by
// FirewallPolicyFilterRuleCollectionActionGenerator()
var firewallPolicyFilterRuleCollectionActionGenerator gopter.Gen

// FirewallPolicyFilterRuleCollectionActionGenerator returns a generator of FirewallPolicyFilterRuleCollectionAction instances for property testing.
func FirewallPolicyFilterRuleCollectionActionGenerator() gopter.Gen {
	if firewallPolicyFilterRuleCollectionActionGenerator != nil {
		return firewallPolicyFilterRuleCollectionActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyFilterRuleCollectionAction(generators)
	firewallPolicyFilterRuleCollectionActionGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyFilterRuleCollectionAction{}), generators)

	return firewallPolicyFilterRuleCollectionActionGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyFilterRuleCollectionAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyFilterRuleCollectionAction(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(FirewallPolicyFilterRuleCollectionActionType_Allow, FirewallPolicyFilterRuleCollectionActionType_Deny))
}

func Test_FirewallPolicyHttpHeaderToInsert_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyHttpHeaderToInsert via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyHttpHeaderToInsert, FirewallPolicyHttpHeaderToInsertGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyHttpHeaderToInsert runs a test to see if a specific instance of FirewallPolicyHttpHeaderToInsert round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyHttpHeaderToInsert(subject FirewallPolicyHttpHeaderToInsert) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyHttpHeaderToInsert
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyHttpHeaderToInsert instances for property testing - lazily instantiated by
// FirewallPolicyHttpHeaderToInsertGenerator()
var firewallPolicyHttpHeaderToInsertGenerator gopter.Gen

// FirewallPolicyHttpHeaderToInsertGenerator returns a generator of FirewallPolicyHttpHeaderToInsert instances for property testing.
func FirewallPolicyHttpHeaderToInsertGenerator() gopter.Gen {
	if firewallPolicyHttpHeaderToInsertGenerator != nil {
		return firewallPolicyHttpHeaderToInsertGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyHttpHeaderToInsert(generators)
	firewallPolicyHttpHeaderToInsertGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyHttpHeaderToInsert{}), generators)

	return firewallPolicyHttpHeaderToInsertGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyHttpHeaderToInsert is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyHttpHeaderToInsert(gens map[string]gopter.Gen) {
	gens["HeaderName"] = gen.PtrOf(gen.AlphaString())
	gens["HeaderValue"] = gen.PtrOf(gen.AlphaString())
}

func Test_FirewallPolicyNatRuleCollection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyNatRuleCollection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyNatRuleCollection, FirewallPolicyNatRuleCollectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyNatRuleCollection runs a test to see if a specific instance of FirewallPolicyNatRuleCollection round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyNatRuleCollection(subject FirewallPolicyNatRuleCollection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyNatRuleCollection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyNatRuleCollection instances for property testing - lazily instantiated by
// FirewallPolicyNatRuleCollectionGenerator()
var firewallPolicyNatRuleCollectionGenerator gopter.Gen

// FirewallPolicyNatRuleCollectionGenerator returns a generator of FirewallPolicyNatRuleCollection instances for property testing.
// We first initialize firewallPolicyNatRuleCollectionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyNatRuleCollectionGenerator() gopter.Gen {
	if firewallPolicyNatRuleCollectionGenerator != nil {
		return firewallPolicyNatRuleCollectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyNatRuleCollection(generators)
	firewallPolicyNatRuleCollectionGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyNatRuleCollection{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyNatRuleCollection(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyNatRuleCollection(generators)
	firewallPolicyNatRuleCollectionGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyNatRuleCollection{}), generators)

	return firewallPolicyNatRuleCollectionGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyNatRuleCollection is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyNatRuleCollection(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["RuleCollectionType"] = gen.OneConstOf(FirewallPolicyNatRuleCollection_RuleCollectionType_FirewallPolicyNatRuleCollection)
}

// AddRelatedPropertyGeneratorsForFirewallPolicyNatRuleCollection is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyNatRuleCollection(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(FirewallPolicyNatRuleCollectionActionGenerator())
	gens["Rules"] = gen.SliceOf(FirewallPolicyRuleGenerator())
}

func Test_FirewallPolicyNatRuleCollectionAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyNatRuleCollectionAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyNatRuleCollectionAction, FirewallPolicyNatRuleCollectionActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyNatRuleCollectionAction runs a test to see if a specific instance of FirewallPolicyNatRuleCollectionAction round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyNatRuleCollectionAction(subject FirewallPolicyNatRuleCollectionAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyNatRuleCollectionAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyNatRuleCollectionAction instances for property testing - lazily instantiated by
// FirewallPolicyNatRuleCollectionActionGenerator()
var firewallPolicyNatRuleCollectionActionGenerator gopter.Gen

// FirewallPolicyNatRuleCollectionActionGenerator returns a generator of FirewallPolicyNatRuleCollectionAction instances for property testing.
func FirewallPolicyNatRuleCollectionActionGenerator() gopter.Gen {
	if firewallPolicyNatRuleCollectionActionGenerator != nil {
		return firewallPolicyNatRuleCollectionActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyNatRuleCollectionAction(generators)
	firewallPolicyNatRuleCollectionActionGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyNatRuleCollectionAction{}), generators)

	return firewallPolicyNatRuleCollectionActionGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyNatRuleCollectionAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyNatRuleCollectionAction(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(FirewallPolicyNatRuleCollectionActionType_DNAT))
}

func Test_FirewallPolicyRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyRule, FirewallPolicyRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyRule runs a test to see if a specific instance of FirewallPolicyRule round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyRule(subject FirewallPolicyRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyRule instances for property testing - lazily instantiated by FirewallPolicyRuleGenerator()
var firewallPolicyRuleGenerator gopter.Gen

// FirewallPolicyRuleGenerator returns a generator of FirewallPolicyRule instances for property testing.
func FirewallPolicyRuleGenerator() gopter.Gen {
	if firewallPolicyRuleGenerator != nil {
		return firewallPolicyRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForFirewallPolicyRule(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		props := map[string]gopter.Gen{propName: propGen}
		gens = append(gens, gen.Struct(reflect.TypeOf(FirewallPolicyRule{}), props))
	}
	firewallPolicyRuleGenerator = gen.OneGenOf(gens...)

	return firewallPolicyRuleGenerator
}

// AddRelatedPropertyGeneratorsForFirewallPolicyRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyRule(gens map[string]gopter.Gen) {
	gens["Application"] = ApplicationRuleGenerator().Map(func(it ApplicationRule) *ApplicationRule {
		return &it
	}) // generate one case for OneOf type
	gens["Nat"] = NatRuleGenerator().Map(func(it NatRule) *NatRule {
		return &it
	}) // generate one case for OneOf type
	gens["Network"] = NetworkRuleGenerator().Map(func(it NetworkRule) *NetworkRule {
		return &it
	}) // generate one case for OneOf type
}

func Test_FirewallPolicyRuleApplicationProtocol_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyRuleApplicationProtocol via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyRuleApplicationProtocol, FirewallPolicyRuleApplicationProtocolGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyRuleApplicationProtocol runs a test to see if a specific instance of FirewallPolicyRuleApplicationProtocol round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyRuleApplicationProtocol(subject FirewallPolicyRuleApplicationProtocol) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyRuleApplicationProtocol
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyRuleApplicationProtocol instances for property testing - lazily instantiated by
// FirewallPolicyRuleApplicationProtocolGenerator()
var firewallPolicyRuleApplicationProtocolGenerator gopter.Gen

// FirewallPolicyRuleApplicationProtocolGenerator returns a generator of FirewallPolicyRuleApplicationProtocol instances for property testing.
func FirewallPolicyRuleApplicationProtocolGenerator() gopter.Gen {
	if firewallPolicyRuleApplicationProtocolGenerator != nil {
		return firewallPolicyRuleApplicationProtocolGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyRuleApplicationProtocol(generators)
	firewallPolicyRuleApplicationProtocolGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyRuleApplicationProtocol{}), generators)

	return firewallPolicyRuleApplicationProtocolGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyRuleApplicationProtocol is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyRuleApplicationProtocol(gens map[string]gopter.Gen) {
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["ProtocolType"] = gen.PtrOf(gen.OneConstOf(FirewallPolicyRuleApplicationProtocolType_Http, FirewallPolicyRuleApplicationProtocolType_Https))
}

func Test_FirewallPolicyRuleCollection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyRuleCollection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyRuleCollection, FirewallPolicyRuleCollectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyRuleCollection runs a test to see if a specific instance of FirewallPolicyRuleCollection round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyRuleCollection(subject FirewallPolicyRuleCollection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyRuleCollection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyRuleCollection instances for property testing - lazily instantiated by
// FirewallPolicyRuleCollectionGenerator()
var firewallPolicyRuleCollectionGenerator gopter.Gen

// FirewallPolicyRuleCollectionGenerator returns a generator of FirewallPolicyRuleCollection instances for property testing.
func FirewallPolicyRuleCollectionGenerator() gopter.Gen {
	if firewallPolicyRuleCollectionGenerator != nil {
		return firewallPolicyRuleCollectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForFirewallPolicyRuleCollection(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		props := map[string]gopter.Gen{propName: propGen}
		gens = append(gens, gen.Struct(reflect.TypeOf(FirewallPolicyRuleCollection{}), props))
	}
	firewallPolicyRuleCollectionGenerator = gen.OneGenOf(gens...)

	return firewallPolicyRuleCollectionGenerator
}

// AddRelatedPropertyGeneratorsForFirewallPolicyRuleCollection is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyRuleCollection(gens map[string]gopter.Gen) {
	gens["FirewallPolicyFilter"] = FirewallPolicyFilterRuleCollectionGenerator().Map(func(it FirewallPolicyFilterRuleCollection) *FirewallPolicyFilterRuleCollection {
		return &it
	}) // generate one case for OneOf type
	gens["FirewallPolicyNat"] = FirewallPolicyNatRuleCollectionGenerator().Map(func(it FirewallPolicyNatRuleCollection) *FirewallPolicyNatRuleCollection {
		return &it
	}) // generate one case for OneOf type
}

func Test_FirewallPolicyRuleCollectionGroupProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyRuleCollectionGroupProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyRuleCollectionGroupProperties, FirewallPolicyRuleCollectionGroupPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyRuleCollectionGroupProperties runs a test to see if a specific instance of FirewallPolicyRuleCollectionGroupProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyRuleCollectionGroupProperties(subject FirewallPolicyRuleCollectionGroupProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyRuleCollectionGroupProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyRuleCollectionGroupProperties instances for property testing - lazily instantiated by
// FirewallPolicyRuleCollectionGroupPropertiesGenerator()
var firewallPolicyRuleCollectionGroupPropertiesGenerator gopter.Gen

// FirewallPolicyRuleCollectionGroupPropertiesGenerator returns a generator of FirewallPolicyRuleCollectionGroupProperties instances for property testing.
// We first initialize firewallPolicyRuleCollectionGroupPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyRuleCollectionGroupPropertiesGenerator() gopter.Gen {
	if firewallPolicyRuleCollectionGroupPropertiesGenerator != nil {
		return firewallPolicyRuleCollectionGroupPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyRuleCollectionGroupProperties(generators)
	firewallPolicyRuleCollectionGroupPropertiesGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyRuleCollectionGroupProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyRuleCollectionGroupProperties(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyRuleCollectionGroupProperties(generators)
	firewallPolicyRuleCollectionGroupPropertiesGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyRuleCollectionGroupProperties{}), generators)

	return firewallPolicyRuleCollectionGroupPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyRuleCollectionGroupProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyRuleCollectionGroupProperties(gens map[string]gopter.Gen) {
	gens["Priority"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForFirewallPolicyRuleCollectionGroupProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyRuleCollectionGroupProperties(gens map[string]gopter.Gen) {
	gens["RuleCollections"] = gen.SliceOf(FirewallPolicyRuleCollectionGenerator())
}

func Test_NatRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NatRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNatRule, NatRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNatRule runs a test to see if a specific instance of NatRule round trips to JSON and back losslessly
func RunJSONSerializationTestForNatRule(subject NatRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NatRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NatRule instances for property testing - lazily instantiated by NatRuleGenerator()
var natRuleGenerator gopter.Gen

// NatRuleGenerator returns a generator of NatRule instances for property testing.
func NatRuleGenerator() gopter.Gen {
	if natRuleGenerator != nil {
		return natRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatRule(generators)
	natRuleGenerator = gen.Struct(reflect.TypeOf(NatRule{}), generators)

	return natRuleGenerator
}

// AddIndependentPropertyGeneratorsForNatRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNatRule(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DestinationAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationPorts"] = gen.SliceOf(gen.AlphaString())
	gens["IpProtocols"] = gen.SliceOf(gen.OneConstOf(
		FirewallPolicyRuleNetworkProtocol_Any,
		FirewallPolicyRuleNetworkProtocol_ICMP,
		FirewallPolicyRuleNetworkProtocol_TCP,
		FirewallPolicyRuleNetworkProtocol_UDP))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["RuleType"] = gen.OneConstOf(NatRule_RuleType_NatRule)
	gens["SourceAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["SourceIpGroups"] = gen.SliceOf(gen.AlphaString())
	gens["TranslatedAddress"] = gen.PtrOf(gen.AlphaString())
	gens["TranslatedFqdn"] = gen.PtrOf(gen.AlphaString())
	gens["TranslatedPort"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRule, NetworkRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRule runs a test to see if a specific instance of NetworkRule round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRule(subject NetworkRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRule instances for property testing - lazily instantiated by NetworkRuleGenerator()
var networkRuleGenerator gopter.Gen

// NetworkRuleGenerator returns a generator of NetworkRule instances for property testing.
func NetworkRuleGenerator() gopter.Gen {
	if networkRuleGenerator != nil {
		return networkRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRule(generators)
	networkRuleGenerator = gen.Struct(reflect.TypeOf(NetworkRule{}), generators)

	return networkRuleGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRule(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DestinationAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationFqdns"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationIpGroups"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationPorts"] = gen.SliceOf(gen.AlphaString())
	gens["IpProtocols"] = gen.SliceOf(gen.OneConstOf(
		FirewallPolicyRuleNetworkProtocol_Any,
		FirewallPolicyRuleNetworkProtocol_ICMP,
		FirewallPolicyRuleNetworkProtocol_TCP,
		FirewallPolicyRuleNetworkProtocol_UDP))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["RuleType"] = gen.OneConstOf(NetworkRule_RuleType_NetworkRule)
	gens["SourceAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["SourceIpGroups"] = gen.SliceOf(gen.AlphaString())
}
