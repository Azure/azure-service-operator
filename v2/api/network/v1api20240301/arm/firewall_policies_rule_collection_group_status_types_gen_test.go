// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ApplicationRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationRule_STATUS, ApplicationRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationRule_STATUS runs a test to see if a specific instance of ApplicationRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationRule_STATUS(subject ApplicationRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationRule_STATUS instances for property testing - lazily instantiated by
// ApplicationRule_STATUSGenerator()
var applicationRule_STATUSGenerator gopter.Gen

// ApplicationRule_STATUSGenerator returns a generator of ApplicationRule_STATUS instances for property testing.
// We first initialize applicationRule_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApplicationRule_STATUSGenerator() gopter.Gen {
	if applicationRule_STATUSGenerator != nil {
		return applicationRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationRule_STATUS(generators)
	applicationRule_STATUSGenerator = gen.Struct(reflect.TypeOf(ApplicationRule_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationRule_STATUS(generators)
	AddRelatedPropertyGeneratorsForApplicationRule_STATUS(generators)
	applicationRule_STATUSGenerator = gen.Struct(reflect.TypeOf(ApplicationRule_STATUS{}), generators)

	return applicationRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForApplicationRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApplicationRule_STATUS(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DestinationAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["FqdnTags"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["RuleType"] = gen.OneConstOf(ApplicationRule_RuleType_STATUS_ApplicationRule)
	gens["SourceAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["SourceIpGroups"] = gen.SliceOf(gen.AlphaString())
	gens["TargetFqdns"] = gen.SliceOf(gen.AlphaString())
	gens["TargetUrls"] = gen.SliceOf(gen.AlphaString())
	gens["TerminateTLS"] = gen.PtrOf(gen.Bool())
	gens["WebCategories"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForApplicationRule_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApplicationRule_STATUS(gens map[string]gopter.Gen) {
	gens["HttpHeadersToInsert"] = gen.SliceOf(FirewallPolicyHttpHeaderToInsert_STATUSGenerator())
	gens["Protocols"] = gen.SliceOf(FirewallPolicyRuleApplicationProtocol_STATUSGenerator())
}

func Test_FirewallPoliciesRuleCollectionGroup_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPoliciesRuleCollectionGroup_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPoliciesRuleCollectionGroup_STATUS, FirewallPoliciesRuleCollectionGroup_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPoliciesRuleCollectionGroup_STATUS runs a test to see if a specific instance of FirewallPoliciesRuleCollectionGroup_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPoliciesRuleCollectionGroup_STATUS(subject FirewallPoliciesRuleCollectionGroup_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPoliciesRuleCollectionGroup_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPoliciesRuleCollectionGroup_STATUS instances for property testing - lazily instantiated by
// FirewallPoliciesRuleCollectionGroup_STATUSGenerator()
var firewallPoliciesRuleCollectionGroup_STATUSGenerator gopter.Gen

// FirewallPoliciesRuleCollectionGroup_STATUSGenerator returns a generator of FirewallPoliciesRuleCollectionGroup_STATUS instances for property testing.
// We first initialize firewallPoliciesRuleCollectionGroup_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPoliciesRuleCollectionGroup_STATUSGenerator() gopter.Gen {
	if firewallPoliciesRuleCollectionGroup_STATUSGenerator != nil {
		return firewallPoliciesRuleCollectionGroup_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup_STATUS(generators)
	firewallPoliciesRuleCollectionGroup_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPoliciesRuleCollectionGroup_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup_STATUS(generators)
	AddRelatedPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup_STATUS(generators)
	firewallPoliciesRuleCollectionGroup_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPoliciesRuleCollectionGroup_STATUS{}), generators)

	return firewallPoliciesRuleCollectionGroup_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup_STATUS(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPoliciesRuleCollectionGroup_STATUS(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(FirewallPolicyRuleCollectionGroupProperties_STATUSGenerator())
}

func Test_FirewallPolicyFilterRuleCollectionAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyFilterRuleCollectionAction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyFilterRuleCollectionAction_STATUS, FirewallPolicyFilterRuleCollectionAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyFilterRuleCollectionAction_STATUS runs a test to see if a specific instance of FirewallPolicyFilterRuleCollectionAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyFilterRuleCollectionAction_STATUS(subject FirewallPolicyFilterRuleCollectionAction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyFilterRuleCollectionAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyFilterRuleCollectionAction_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyFilterRuleCollectionAction_STATUSGenerator()
var firewallPolicyFilterRuleCollectionAction_STATUSGenerator gopter.Gen

// FirewallPolicyFilterRuleCollectionAction_STATUSGenerator returns a generator of FirewallPolicyFilterRuleCollectionAction_STATUS instances for property testing.
func FirewallPolicyFilterRuleCollectionAction_STATUSGenerator() gopter.Gen {
	if firewallPolicyFilterRuleCollectionAction_STATUSGenerator != nil {
		return firewallPolicyFilterRuleCollectionAction_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyFilterRuleCollectionAction_STATUS(generators)
	firewallPolicyFilterRuleCollectionAction_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyFilterRuleCollectionAction_STATUS{}), generators)

	return firewallPolicyFilterRuleCollectionAction_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyFilterRuleCollectionAction_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyFilterRuleCollectionAction_STATUS(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(FirewallPolicyFilterRuleCollectionActionType_STATUS_Allow, FirewallPolicyFilterRuleCollectionActionType_STATUS_Deny))
}

func Test_FirewallPolicyFilterRuleCollection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyFilterRuleCollection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyFilterRuleCollection_STATUS, FirewallPolicyFilterRuleCollection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyFilterRuleCollection_STATUS runs a test to see if a specific instance of FirewallPolicyFilterRuleCollection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyFilterRuleCollection_STATUS(subject FirewallPolicyFilterRuleCollection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyFilterRuleCollection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyFilterRuleCollection_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyFilterRuleCollection_STATUSGenerator()
var firewallPolicyFilterRuleCollection_STATUSGenerator gopter.Gen

// FirewallPolicyFilterRuleCollection_STATUSGenerator returns a generator of FirewallPolicyFilterRuleCollection_STATUS instances for property testing.
// We first initialize firewallPolicyFilterRuleCollection_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyFilterRuleCollection_STATUSGenerator() gopter.Gen {
	if firewallPolicyFilterRuleCollection_STATUSGenerator != nil {
		return firewallPolicyFilterRuleCollection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyFilterRuleCollection_STATUS(generators)
	firewallPolicyFilterRuleCollection_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyFilterRuleCollection_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyFilterRuleCollection_STATUS(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyFilterRuleCollection_STATUS(generators)
	firewallPolicyFilterRuleCollection_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyFilterRuleCollection_STATUS{}), generators)

	return firewallPolicyFilterRuleCollection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyFilterRuleCollection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyFilterRuleCollection_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["RuleCollectionType"] = gen.OneConstOf(FirewallPolicyFilterRuleCollection_RuleCollectionType_STATUS_FirewallPolicyFilterRuleCollection)
}

// AddRelatedPropertyGeneratorsForFirewallPolicyFilterRuleCollection_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyFilterRuleCollection_STATUS(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(FirewallPolicyFilterRuleCollectionAction_STATUSGenerator())
	gens["Rules"] = gen.SliceOf(FirewallPolicyRule_STATUSGenerator())
}

func Test_FirewallPolicyHttpHeaderToInsert_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyHttpHeaderToInsert_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyHttpHeaderToInsert_STATUS, FirewallPolicyHttpHeaderToInsert_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyHttpHeaderToInsert_STATUS runs a test to see if a specific instance of FirewallPolicyHttpHeaderToInsert_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyHttpHeaderToInsert_STATUS(subject FirewallPolicyHttpHeaderToInsert_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyHttpHeaderToInsert_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyHttpHeaderToInsert_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyHttpHeaderToInsert_STATUSGenerator()
var firewallPolicyHttpHeaderToInsert_STATUSGenerator gopter.Gen

// FirewallPolicyHttpHeaderToInsert_STATUSGenerator returns a generator of FirewallPolicyHttpHeaderToInsert_STATUS instances for property testing.
func FirewallPolicyHttpHeaderToInsert_STATUSGenerator() gopter.Gen {
	if firewallPolicyHttpHeaderToInsert_STATUSGenerator != nil {
		return firewallPolicyHttpHeaderToInsert_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyHttpHeaderToInsert_STATUS(generators)
	firewallPolicyHttpHeaderToInsert_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyHttpHeaderToInsert_STATUS{}), generators)

	return firewallPolicyHttpHeaderToInsert_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyHttpHeaderToInsert_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyHttpHeaderToInsert_STATUS(gens map[string]gopter.Gen) {
	gens["HeaderName"] = gen.PtrOf(gen.AlphaString())
	gens["HeaderValue"] = gen.PtrOf(gen.AlphaString())
}

func Test_FirewallPolicyNatRuleCollectionAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyNatRuleCollectionAction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyNatRuleCollectionAction_STATUS, FirewallPolicyNatRuleCollectionAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyNatRuleCollectionAction_STATUS runs a test to see if a specific instance of FirewallPolicyNatRuleCollectionAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyNatRuleCollectionAction_STATUS(subject FirewallPolicyNatRuleCollectionAction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyNatRuleCollectionAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyNatRuleCollectionAction_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyNatRuleCollectionAction_STATUSGenerator()
var firewallPolicyNatRuleCollectionAction_STATUSGenerator gopter.Gen

// FirewallPolicyNatRuleCollectionAction_STATUSGenerator returns a generator of FirewallPolicyNatRuleCollectionAction_STATUS instances for property testing.
func FirewallPolicyNatRuleCollectionAction_STATUSGenerator() gopter.Gen {
	if firewallPolicyNatRuleCollectionAction_STATUSGenerator != nil {
		return firewallPolicyNatRuleCollectionAction_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyNatRuleCollectionAction_STATUS(generators)
	firewallPolicyNatRuleCollectionAction_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyNatRuleCollectionAction_STATUS{}), generators)

	return firewallPolicyNatRuleCollectionAction_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyNatRuleCollectionAction_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyNatRuleCollectionAction_STATUS(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(FirewallPolicyNatRuleCollectionActionType_STATUS_DNAT))
}

func Test_FirewallPolicyNatRuleCollection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyNatRuleCollection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyNatRuleCollection_STATUS, FirewallPolicyNatRuleCollection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyNatRuleCollection_STATUS runs a test to see if a specific instance of FirewallPolicyNatRuleCollection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyNatRuleCollection_STATUS(subject FirewallPolicyNatRuleCollection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyNatRuleCollection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyNatRuleCollection_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyNatRuleCollection_STATUSGenerator()
var firewallPolicyNatRuleCollection_STATUSGenerator gopter.Gen

// FirewallPolicyNatRuleCollection_STATUSGenerator returns a generator of FirewallPolicyNatRuleCollection_STATUS instances for property testing.
// We first initialize firewallPolicyNatRuleCollection_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyNatRuleCollection_STATUSGenerator() gopter.Gen {
	if firewallPolicyNatRuleCollection_STATUSGenerator != nil {
		return firewallPolicyNatRuleCollection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyNatRuleCollection_STATUS(generators)
	firewallPolicyNatRuleCollection_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyNatRuleCollection_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyNatRuleCollection_STATUS(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyNatRuleCollection_STATUS(generators)
	firewallPolicyNatRuleCollection_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyNatRuleCollection_STATUS{}), generators)

	return firewallPolicyNatRuleCollection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyNatRuleCollection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyNatRuleCollection_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["RuleCollectionType"] = gen.OneConstOf(FirewallPolicyNatRuleCollection_RuleCollectionType_STATUS_FirewallPolicyNatRuleCollection)
}

// AddRelatedPropertyGeneratorsForFirewallPolicyNatRuleCollection_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyNatRuleCollection_STATUS(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(FirewallPolicyNatRuleCollectionAction_STATUSGenerator())
	gens["Rules"] = gen.SliceOf(FirewallPolicyRule_STATUSGenerator())
}

func Test_FirewallPolicyRuleApplicationProtocol_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyRuleApplicationProtocol_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyRuleApplicationProtocol_STATUS, FirewallPolicyRuleApplicationProtocol_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyRuleApplicationProtocol_STATUS runs a test to see if a specific instance of FirewallPolicyRuleApplicationProtocol_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyRuleApplicationProtocol_STATUS(subject FirewallPolicyRuleApplicationProtocol_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyRuleApplicationProtocol_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyRuleApplicationProtocol_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyRuleApplicationProtocol_STATUSGenerator()
var firewallPolicyRuleApplicationProtocol_STATUSGenerator gopter.Gen

// FirewallPolicyRuleApplicationProtocol_STATUSGenerator returns a generator of FirewallPolicyRuleApplicationProtocol_STATUS instances for property testing.
func FirewallPolicyRuleApplicationProtocol_STATUSGenerator() gopter.Gen {
	if firewallPolicyRuleApplicationProtocol_STATUSGenerator != nil {
		return firewallPolicyRuleApplicationProtocol_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyRuleApplicationProtocol_STATUS(generators)
	firewallPolicyRuleApplicationProtocol_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyRuleApplicationProtocol_STATUS{}), generators)

	return firewallPolicyRuleApplicationProtocol_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyRuleApplicationProtocol_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyRuleApplicationProtocol_STATUS(gens map[string]gopter.Gen) {
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["ProtocolType"] = gen.PtrOf(gen.OneConstOf(FirewallPolicyRuleApplicationProtocolType_STATUS_Http, FirewallPolicyRuleApplicationProtocolType_STATUS_Https))
}

func Test_FirewallPolicyRuleCollectionGroupProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyRuleCollectionGroupProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyRuleCollectionGroupProperties_STATUS, FirewallPolicyRuleCollectionGroupProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyRuleCollectionGroupProperties_STATUS runs a test to see if a specific instance of FirewallPolicyRuleCollectionGroupProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyRuleCollectionGroupProperties_STATUS(subject FirewallPolicyRuleCollectionGroupProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyRuleCollectionGroupProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyRuleCollectionGroupProperties_STATUS instances for property testing - lazily instantiated
// by FirewallPolicyRuleCollectionGroupProperties_STATUSGenerator()
var firewallPolicyRuleCollectionGroupProperties_STATUSGenerator gopter.Gen

// FirewallPolicyRuleCollectionGroupProperties_STATUSGenerator returns a generator of FirewallPolicyRuleCollectionGroupProperties_STATUS instances for property testing.
// We first initialize firewallPolicyRuleCollectionGroupProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyRuleCollectionGroupProperties_STATUSGenerator() gopter.Gen {
	if firewallPolicyRuleCollectionGroupProperties_STATUSGenerator != nil {
		return firewallPolicyRuleCollectionGroupProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyRuleCollectionGroupProperties_STATUS(generators)
	firewallPolicyRuleCollectionGroupProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyRuleCollectionGroupProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyRuleCollectionGroupProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyRuleCollectionGroupProperties_STATUS(generators)
	firewallPolicyRuleCollectionGroupProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyRuleCollectionGroupProperties_STATUS{}), generators)

	return firewallPolicyRuleCollectionGroupProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyRuleCollectionGroupProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyRuleCollectionGroupProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Updating))
	gens["Size"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFirewallPolicyRuleCollectionGroupProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyRuleCollectionGroupProperties_STATUS(gens map[string]gopter.Gen) {
	gens["RuleCollections"] = gen.SliceOf(FirewallPolicyRuleCollection_STATUSGenerator())
}

func Test_FirewallPolicyRuleCollection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyRuleCollection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyRuleCollection_STATUS, FirewallPolicyRuleCollection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyRuleCollection_STATUS runs a test to see if a specific instance of FirewallPolicyRuleCollection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyRuleCollection_STATUS(subject FirewallPolicyRuleCollection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyRuleCollection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyRuleCollection_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyRuleCollection_STATUSGenerator()
var firewallPolicyRuleCollection_STATUSGenerator gopter.Gen

// FirewallPolicyRuleCollection_STATUSGenerator returns a generator of FirewallPolicyRuleCollection_STATUS instances for property testing.
func FirewallPolicyRuleCollection_STATUSGenerator() gopter.Gen {
	if firewallPolicyRuleCollection_STATUSGenerator != nil {
		return firewallPolicyRuleCollection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForFirewallPolicyRuleCollection_STATUS(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		props := map[string]gopter.Gen{propName: propGen}
		gens = append(gens, gen.Struct(reflect.TypeOf(FirewallPolicyRuleCollection_STATUS{}), props))
	}
	firewallPolicyRuleCollection_STATUSGenerator = gen.OneGenOf(gens...)

	return firewallPolicyRuleCollection_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForFirewallPolicyRuleCollection_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyRuleCollection_STATUS(gens map[string]gopter.Gen) {
	gens["FirewallPolicyFilter"] = FirewallPolicyFilterRuleCollection_STATUSGenerator().Map(func(it FirewallPolicyFilterRuleCollection_STATUS) *FirewallPolicyFilterRuleCollection_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["FirewallPolicyNat"] = FirewallPolicyNatRuleCollection_STATUSGenerator().Map(func(it FirewallPolicyNatRuleCollection_STATUS) *FirewallPolicyNatRuleCollection_STATUS {
		return &it
	}) // generate one case for OneOf type
}

func Test_FirewallPolicyRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyRule_STATUS, FirewallPolicyRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyRule_STATUS runs a test to see if a specific instance of FirewallPolicyRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyRule_STATUS(subject FirewallPolicyRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyRule_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyRule_STATUSGenerator()
var firewallPolicyRule_STATUSGenerator gopter.Gen

// FirewallPolicyRule_STATUSGenerator returns a generator of FirewallPolicyRule_STATUS instances for property testing.
func FirewallPolicyRule_STATUSGenerator() gopter.Gen {
	if firewallPolicyRule_STATUSGenerator != nil {
		return firewallPolicyRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForFirewallPolicyRule_STATUS(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		props := map[string]gopter.Gen{propName: propGen}
		gens = append(gens, gen.Struct(reflect.TypeOf(FirewallPolicyRule_STATUS{}), props))
	}
	firewallPolicyRule_STATUSGenerator = gen.OneGenOf(gens...)

	return firewallPolicyRule_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForFirewallPolicyRule_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyRule_STATUS(gens map[string]gopter.Gen) {
	gens["Application"] = ApplicationRule_STATUSGenerator().Map(func(it ApplicationRule_STATUS) *ApplicationRule_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["Nat"] = NatRule_STATUSGenerator().Map(func(it NatRule_STATUS) *NatRule_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["Network"] = NetworkRule_STATUSGenerator().Map(func(it NetworkRule_STATUS) *NetworkRule_STATUS {
		return &it
	}) // generate one case for OneOf type
}

func Test_NatRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NatRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNatRule_STATUS, NatRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNatRule_STATUS runs a test to see if a specific instance of NatRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNatRule_STATUS(subject NatRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NatRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NatRule_STATUS instances for property testing - lazily instantiated by NatRule_STATUSGenerator()
var natRule_STATUSGenerator gopter.Gen

// NatRule_STATUSGenerator returns a generator of NatRule_STATUS instances for property testing.
func NatRule_STATUSGenerator() gopter.Gen {
	if natRule_STATUSGenerator != nil {
		return natRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNatRule_STATUS(generators)
	natRule_STATUSGenerator = gen.Struct(reflect.TypeOf(NatRule_STATUS{}), generators)

	return natRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNatRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNatRule_STATUS(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DestinationAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationPorts"] = gen.SliceOf(gen.AlphaString())
	gens["IpProtocols"] = gen.SliceOf(gen.OneConstOf(
		FirewallPolicyRuleNetworkProtocol_STATUS_Any,
		FirewallPolicyRuleNetworkProtocol_STATUS_ICMP,
		FirewallPolicyRuleNetworkProtocol_STATUS_TCP,
		FirewallPolicyRuleNetworkProtocol_STATUS_UDP))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["RuleType"] = gen.OneConstOf(NatRule_RuleType_STATUS_NatRule)
	gens["SourceAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["SourceIpGroups"] = gen.SliceOf(gen.AlphaString())
	gens["TranslatedAddress"] = gen.PtrOf(gen.AlphaString())
	gens["TranslatedFqdn"] = gen.PtrOf(gen.AlphaString())
	gens["TranslatedPort"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRule_STATUS, NetworkRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRule_STATUS runs a test to see if a specific instance of NetworkRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRule_STATUS(subject NetworkRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRule_STATUS instances for property testing - lazily instantiated by NetworkRule_STATUSGenerator()
var networkRule_STATUSGenerator gopter.Gen

// NetworkRule_STATUSGenerator returns a generator of NetworkRule_STATUS instances for property testing.
func NetworkRule_STATUSGenerator() gopter.Gen {
	if networkRule_STATUSGenerator != nil {
		return networkRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRule_STATUS(generators)
	networkRule_STATUSGenerator = gen.Struct(reflect.TypeOf(NetworkRule_STATUS{}), generators)

	return networkRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRule_STATUS(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DestinationAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationFqdns"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationIpGroups"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationPorts"] = gen.SliceOf(gen.AlphaString())
	gens["IpProtocols"] = gen.SliceOf(gen.OneConstOf(
		FirewallPolicyRuleNetworkProtocol_STATUS_Any,
		FirewallPolicyRuleNetworkProtocol_STATUS_ICMP,
		FirewallPolicyRuleNetworkProtocol_STATUS_TCP,
		FirewallPolicyRuleNetworkProtocol_STATUS_UDP))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["RuleType"] = gen.OneConstOf(NetworkRule_RuleType_STATUS_NetworkRule)
	gens["SourceAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["SourceIpGroups"] = gen.SliceOf(gen.AlphaString())
}
