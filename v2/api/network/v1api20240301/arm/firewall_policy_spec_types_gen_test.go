// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_DnsSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DnsSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDnsSettings, DnsSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDnsSettings runs a test to see if a specific instance of DnsSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForDnsSettings(subject DnsSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DnsSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DnsSettings instances for property testing - lazily instantiated by DnsSettingsGenerator()
var dnsSettingsGenerator gopter.Gen

// DnsSettingsGenerator returns a generator of DnsSettings instances for property testing.
func DnsSettingsGenerator() gopter.Gen {
	if dnsSettingsGenerator != nil {
		return dnsSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDnsSettings(generators)
	dnsSettingsGenerator = gen.Struct(reflect.TypeOf(DnsSettings{}), generators)

	return dnsSettingsGenerator
}

// AddIndependentPropertyGeneratorsForDnsSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDnsSettings(gens map[string]gopter.Gen) {
	gens["EnableProxy"] = gen.PtrOf(gen.Bool())
	gens["RequireProxyForNetworkRules"] = gen.PtrOf(gen.Bool())
	gens["Servers"] = gen.SliceOf(gen.AlphaString())
}

func Test_ExplicitProxy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExplicitProxy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExplicitProxy, ExplicitProxyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExplicitProxy runs a test to see if a specific instance of ExplicitProxy round trips to JSON and back losslessly
func RunJSONSerializationTestForExplicitProxy(subject ExplicitProxy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExplicitProxy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExplicitProxy instances for property testing - lazily instantiated by ExplicitProxyGenerator()
var explicitProxyGenerator gopter.Gen

// ExplicitProxyGenerator returns a generator of ExplicitProxy instances for property testing.
func ExplicitProxyGenerator() gopter.Gen {
	if explicitProxyGenerator != nil {
		return explicitProxyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExplicitProxy(generators)
	explicitProxyGenerator = gen.Struct(reflect.TypeOf(ExplicitProxy{}), generators)

	return explicitProxyGenerator
}

// AddIndependentPropertyGeneratorsForExplicitProxy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExplicitProxy(gens map[string]gopter.Gen) {
	gens["EnableExplicitProxy"] = gen.PtrOf(gen.Bool())
	gens["EnablePacFile"] = gen.PtrOf(gen.Bool())
	gens["HttpPort"] = gen.PtrOf(gen.Int())
	gens["HttpsPort"] = gen.PtrOf(gen.Int())
	gens["PacFile"] = gen.PtrOf(gen.AlphaString())
	gens["PacFilePort"] = gen.PtrOf(gen.Int())
}

func Test_FirewallPolicyCertificateAuthority_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyCertificateAuthority via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyCertificateAuthority, FirewallPolicyCertificateAuthorityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyCertificateAuthority runs a test to see if a specific instance of FirewallPolicyCertificateAuthority round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyCertificateAuthority(subject FirewallPolicyCertificateAuthority) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyCertificateAuthority
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyCertificateAuthority instances for property testing - lazily instantiated by
// FirewallPolicyCertificateAuthorityGenerator()
var firewallPolicyCertificateAuthorityGenerator gopter.Gen

// FirewallPolicyCertificateAuthorityGenerator returns a generator of FirewallPolicyCertificateAuthority instances for property testing.
func FirewallPolicyCertificateAuthorityGenerator() gopter.Gen {
	if firewallPolicyCertificateAuthorityGenerator != nil {
		return firewallPolicyCertificateAuthorityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyCertificateAuthority(generators)
	firewallPolicyCertificateAuthorityGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyCertificateAuthority{}), generators)

	return firewallPolicyCertificateAuthorityGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyCertificateAuthority is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyCertificateAuthority(gens map[string]gopter.Gen) {
	gens["KeyVaultSecretId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_FirewallPolicyInsights_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyInsights via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyInsights, FirewallPolicyInsightsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyInsights runs a test to see if a specific instance of FirewallPolicyInsights round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyInsights(subject FirewallPolicyInsights) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyInsights
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyInsights instances for property testing - lazily instantiated by
// FirewallPolicyInsightsGenerator()
var firewallPolicyInsightsGenerator gopter.Gen

// FirewallPolicyInsightsGenerator returns a generator of FirewallPolicyInsights instances for property testing.
// We first initialize firewallPolicyInsightsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyInsightsGenerator() gopter.Gen {
	if firewallPolicyInsightsGenerator != nil {
		return firewallPolicyInsightsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyInsights(generators)
	firewallPolicyInsightsGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyInsights{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyInsights(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyInsights(generators)
	firewallPolicyInsightsGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyInsights{}), generators)

	return firewallPolicyInsightsGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyInsights is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyInsights(gens map[string]gopter.Gen) {
	gens["IsEnabled"] = gen.PtrOf(gen.Bool())
	gens["RetentionDays"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForFirewallPolicyInsights is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyInsights(gens map[string]gopter.Gen) {
	gens["LogAnalyticsResources"] = gen.PtrOf(FirewallPolicyLogAnalyticsResourcesGenerator())
}

func Test_FirewallPolicyIntrusionDetection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyIntrusionDetection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyIntrusionDetection, FirewallPolicyIntrusionDetectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyIntrusionDetection runs a test to see if a specific instance of FirewallPolicyIntrusionDetection round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyIntrusionDetection(subject FirewallPolicyIntrusionDetection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyIntrusionDetection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyIntrusionDetection instances for property testing - lazily instantiated by
// FirewallPolicyIntrusionDetectionGenerator()
var firewallPolicyIntrusionDetectionGenerator gopter.Gen

// FirewallPolicyIntrusionDetectionGenerator returns a generator of FirewallPolicyIntrusionDetection instances for property testing.
// We first initialize firewallPolicyIntrusionDetectionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyIntrusionDetectionGenerator() gopter.Gen {
	if firewallPolicyIntrusionDetectionGenerator != nil {
		return firewallPolicyIntrusionDetectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetection(generators)
	firewallPolicyIntrusionDetectionGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetection{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetection(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetection(generators)
	firewallPolicyIntrusionDetectionGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetection{}), generators)

	return firewallPolicyIntrusionDetectionGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetection is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetection(gens map[string]gopter.Gen) {
	gens["Mode"] = gen.PtrOf(gen.OneConstOf(FirewallPolicyIntrusionDetectionStateOptions_Alert, FirewallPolicyIntrusionDetectionStateOptions_Deny, FirewallPolicyIntrusionDetectionStateOptions_Off))
	gens["Profile"] = gen.PtrOf(gen.OneConstOf(
		FirewallPolicyIntrusionDetectionProfileOptions_Advanced,
		FirewallPolicyIntrusionDetectionProfileOptions_Basic,
		FirewallPolicyIntrusionDetectionProfileOptions_Extended,
		FirewallPolicyIntrusionDetectionProfileOptions_Standard))
}

// AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetection is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetection(gens map[string]gopter.Gen) {
	gens["Configuration"] = gen.PtrOf(FirewallPolicyIntrusionDetectionConfigurationGenerator())
}

func Test_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyIntrusionDetectionBypassTrafficSpecifications via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications, FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications runs a test to see if a specific instance of FirewallPolicyIntrusionDetectionBypassTrafficSpecifications round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications(subject FirewallPolicyIntrusionDetectionBypassTrafficSpecifications) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyIntrusionDetectionBypassTrafficSpecifications
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyIntrusionDetectionBypassTrafficSpecifications instances for property testing - lazily
// instantiated by FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator()
var firewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator gopter.Gen

// FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator returns a generator of FirewallPolicyIntrusionDetectionBypassTrafficSpecifications instances for property testing.
func FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator() gopter.Gen {
	if firewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator != nil {
		return firewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications(generators)
	firewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetectionBypassTrafficSpecifications{}), generators)

	return firewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DestinationAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationIpGroups"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationPorts"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(
		FirewallPolicyIntrusionDetectionBypassTrafficProtocol_ANY,
		FirewallPolicyIntrusionDetectionBypassTrafficProtocol_ICMP,
		FirewallPolicyIntrusionDetectionBypassTrafficProtocol_TCP,
		FirewallPolicyIntrusionDetectionBypassTrafficProtocol_UDP))
	gens["SourceAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["SourceIpGroups"] = gen.SliceOf(gen.AlphaString())
}

func Test_FirewallPolicyIntrusionDetectionConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyIntrusionDetectionConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyIntrusionDetectionConfiguration, FirewallPolicyIntrusionDetectionConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyIntrusionDetectionConfiguration runs a test to see if a specific instance of FirewallPolicyIntrusionDetectionConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyIntrusionDetectionConfiguration(subject FirewallPolicyIntrusionDetectionConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyIntrusionDetectionConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyIntrusionDetectionConfiguration instances for property testing - lazily instantiated by
// FirewallPolicyIntrusionDetectionConfigurationGenerator()
var firewallPolicyIntrusionDetectionConfigurationGenerator gopter.Gen

// FirewallPolicyIntrusionDetectionConfigurationGenerator returns a generator of FirewallPolicyIntrusionDetectionConfiguration instances for property testing.
// We first initialize firewallPolicyIntrusionDetectionConfigurationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyIntrusionDetectionConfigurationGenerator() gopter.Gen {
	if firewallPolicyIntrusionDetectionConfigurationGenerator != nil {
		return firewallPolicyIntrusionDetectionConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration(generators)
	firewallPolicyIntrusionDetectionConfigurationGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetectionConfiguration{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration(generators)
	firewallPolicyIntrusionDetectionConfigurationGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetectionConfiguration{}), generators)

	return firewallPolicyIntrusionDetectionConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration(gens map[string]gopter.Gen) {
	gens["PrivateRanges"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration(gens map[string]gopter.Gen) {
	gens["BypassTrafficSettings"] = gen.SliceOf(FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator())
	gens["SignatureOverrides"] = gen.SliceOf(FirewallPolicyIntrusionDetectionSignatureSpecificationGenerator())
}

func Test_FirewallPolicyIntrusionDetectionSignatureSpecification_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyIntrusionDetectionSignatureSpecification via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyIntrusionDetectionSignatureSpecification, FirewallPolicyIntrusionDetectionSignatureSpecificationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyIntrusionDetectionSignatureSpecification runs a test to see if a specific instance of FirewallPolicyIntrusionDetectionSignatureSpecification round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyIntrusionDetectionSignatureSpecification(subject FirewallPolicyIntrusionDetectionSignatureSpecification) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyIntrusionDetectionSignatureSpecification
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyIntrusionDetectionSignatureSpecification instances for property testing - lazily
// instantiated by FirewallPolicyIntrusionDetectionSignatureSpecificationGenerator()
var firewallPolicyIntrusionDetectionSignatureSpecificationGenerator gopter.Gen

// FirewallPolicyIntrusionDetectionSignatureSpecificationGenerator returns a generator of FirewallPolicyIntrusionDetectionSignatureSpecification instances for property testing.
func FirewallPolicyIntrusionDetectionSignatureSpecificationGenerator() gopter.Gen {
	if firewallPolicyIntrusionDetectionSignatureSpecificationGenerator != nil {
		return firewallPolicyIntrusionDetectionSignatureSpecificationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionSignatureSpecification(generators)
	firewallPolicyIntrusionDetectionSignatureSpecificationGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetectionSignatureSpecification{}), generators)

	return firewallPolicyIntrusionDetectionSignatureSpecificationGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionSignatureSpecification is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionSignatureSpecification(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Mode"] = gen.PtrOf(gen.OneConstOf(FirewallPolicyIntrusionDetectionStateOptions_Alert, FirewallPolicyIntrusionDetectionStateOptions_Deny, FirewallPolicyIntrusionDetectionStateOptions_Off))
}

func Test_FirewallPolicyLogAnalyticsResources_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyLogAnalyticsResources via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyLogAnalyticsResources, FirewallPolicyLogAnalyticsResourcesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyLogAnalyticsResources runs a test to see if a specific instance of FirewallPolicyLogAnalyticsResources round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyLogAnalyticsResources(subject FirewallPolicyLogAnalyticsResources) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyLogAnalyticsResources
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyLogAnalyticsResources instances for property testing - lazily instantiated by
// FirewallPolicyLogAnalyticsResourcesGenerator()
var firewallPolicyLogAnalyticsResourcesGenerator gopter.Gen

// FirewallPolicyLogAnalyticsResourcesGenerator returns a generator of FirewallPolicyLogAnalyticsResources instances for property testing.
func FirewallPolicyLogAnalyticsResourcesGenerator() gopter.Gen {
	if firewallPolicyLogAnalyticsResourcesGenerator != nil {
		return firewallPolicyLogAnalyticsResourcesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsResources(generators)
	firewallPolicyLogAnalyticsResourcesGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyLogAnalyticsResources{}), generators)

	return firewallPolicyLogAnalyticsResourcesGenerator
}

// AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsResources is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsResources(gens map[string]gopter.Gen) {
	gens["DefaultWorkspaceId"] = gen.PtrOf(SubResourceGenerator())
	gens["Workspaces"] = gen.SliceOf(FirewallPolicyLogAnalyticsWorkspaceGenerator())
}

func Test_FirewallPolicyLogAnalyticsWorkspace_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyLogAnalyticsWorkspace via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyLogAnalyticsWorkspace, FirewallPolicyLogAnalyticsWorkspaceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyLogAnalyticsWorkspace runs a test to see if a specific instance of FirewallPolicyLogAnalyticsWorkspace round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyLogAnalyticsWorkspace(subject FirewallPolicyLogAnalyticsWorkspace) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyLogAnalyticsWorkspace
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyLogAnalyticsWorkspace instances for property testing - lazily instantiated by
// FirewallPolicyLogAnalyticsWorkspaceGenerator()
var firewallPolicyLogAnalyticsWorkspaceGenerator gopter.Gen

// FirewallPolicyLogAnalyticsWorkspaceGenerator returns a generator of FirewallPolicyLogAnalyticsWorkspace instances for property testing.
// We first initialize firewallPolicyLogAnalyticsWorkspaceGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyLogAnalyticsWorkspaceGenerator() gopter.Gen {
	if firewallPolicyLogAnalyticsWorkspaceGenerator != nil {
		return firewallPolicyLogAnalyticsWorkspaceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace(generators)
	firewallPolicyLogAnalyticsWorkspaceGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyLogAnalyticsWorkspace{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace(generators)
	firewallPolicyLogAnalyticsWorkspaceGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyLogAnalyticsWorkspace{}), generators)

	return firewallPolicyLogAnalyticsWorkspaceGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace(gens map[string]gopter.Gen) {
	gens["Region"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace(gens map[string]gopter.Gen) {
	gens["WorkspaceId"] = gen.PtrOf(SubResourceGenerator())
}

func Test_FirewallPolicyPropertiesFormat_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyPropertiesFormat via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyPropertiesFormat, FirewallPolicyPropertiesFormatGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyPropertiesFormat runs a test to see if a specific instance of FirewallPolicyPropertiesFormat round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyPropertiesFormat(subject FirewallPolicyPropertiesFormat) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyPropertiesFormat
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyPropertiesFormat instances for property testing - lazily instantiated by
// FirewallPolicyPropertiesFormatGenerator()
var firewallPolicyPropertiesFormatGenerator gopter.Gen

// FirewallPolicyPropertiesFormatGenerator returns a generator of FirewallPolicyPropertiesFormat instances for property testing.
// We first initialize firewallPolicyPropertiesFormatGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyPropertiesFormatGenerator() gopter.Gen {
	if firewallPolicyPropertiesFormatGenerator != nil {
		return firewallPolicyPropertiesFormatGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyPropertiesFormat(generators)
	firewallPolicyPropertiesFormatGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyPropertiesFormat{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyPropertiesFormat(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyPropertiesFormat(generators)
	firewallPolicyPropertiesFormatGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyPropertiesFormat{}), generators)

	return firewallPolicyPropertiesFormatGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyPropertiesFormat is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyPropertiesFormat(gens map[string]gopter.Gen) {
	gens["ThreatIntelMode"] = gen.PtrOf(gen.OneConstOf(AzureFirewallThreatIntelMode_Alert, AzureFirewallThreatIntelMode_Deny, AzureFirewallThreatIntelMode_Off))
}

// AddRelatedPropertyGeneratorsForFirewallPolicyPropertiesFormat is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyPropertiesFormat(gens map[string]gopter.Gen) {
	gens["BasePolicy"] = gen.PtrOf(SubResourceGenerator())
	gens["DnsSettings"] = gen.PtrOf(DnsSettingsGenerator())
	gens["ExplicitProxy"] = gen.PtrOf(ExplicitProxyGenerator())
	gens["Insights"] = gen.PtrOf(FirewallPolicyInsightsGenerator())
	gens["IntrusionDetection"] = gen.PtrOf(FirewallPolicyIntrusionDetectionGenerator())
	gens["Sku"] = gen.PtrOf(FirewallPolicySkuGenerator())
	gens["Snat"] = gen.PtrOf(FirewallPolicySNATGenerator())
	gens["Sql"] = gen.PtrOf(FirewallPolicySQLGenerator())
	gens["ThreatIntelWhitelist"] = gen.PtrOf(FirewallPolicyThreatIntelWhitelistGenerator())
	gens["TransportSecurity"] = gen.PtrOf(FirewallPolicyTransportSecurityGenerator())
}

func Test_FirewallPolicySNAT_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicySNAT via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicySNAT, FirewallPolicySNATGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicySNAT runs a test to see if a specific instance of FirewallPolicySNAT round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicySNAT(subject FirewallPolicySNAT) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicySNAT
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicySNAT instances for property testing - lazily instantiated by FirewallPolicySNATGenerator()
var firewallPolicySNATGenerator gopter.Gen

// FirewallPolicySNATGenerator returns a generator of FirewallPolicySNAT instances for property testing.
func FirewallPolicySNATGenerator() gopter.Gen {
	if firewallPolicySNATGenerator != nil {
		return firewallPolicySNATGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicySNAT(generators)
	firewallPolicySNATGenerator = gen.Struct(reflect.TypeOf(FirewallPolicySNAT{}), generators)

	return firewallPolicySNATGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicySNAT is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicySNAT(gens map[string]gopter.Gen) {
	gens["AutoLearnPrivateRanges"] = gen.PtrOf(gen.OneConstOf(FirewallPolicySNAT_AutoLearnPrivateRanges_Disabled, FirewallPolicySNAT_AutoLearnPrivateRanges_Enabled))
	gens["PrivateRanges"] = gen.SliceOf(gen.AlphaString())
}

func Test_FirewallPolicySQL_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicySQL via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicySQL, FirewallPolicySQLGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicySQL runs a test to see if a specific instance of FirewallPolicySQL round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicySQL(subject FirewallPolicySQL) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicySQL
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicySQL instances for property testing - lazily instantiated by FirewallPolicySQLGenerator()
var firewallPolicySQLGenerator gopter.Gen

// FirewallPolicySQLGenerator returns a generator of FirewallPolicySQL instances for property testing.
func FirewallPolicySQLGenerator() gopter.Gen {
	if firewallPolicySQLGenerator != nil {
		return firewallPolicySQLGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicySQL(generators)
	firewallPolicySQLGenerator = gen.Struct(reflect.TypeOf(FirewallPolicySQL{}), generators)

	return firewallPolicySQLGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicySQL is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicySQL(gens map[string]gopter.Gen) {
	gens["AllowSqlRedirect"] = gen.PtrOf(gen.Bool())
}

func Test_FirewallPolicySku_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicySku via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicySku, FirewallPolicySkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicySku runs a test to see if a specific instance of FirewallPolicySku round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicySku(subject FirewallPolicySku) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicySku
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicySku instances for property testing - lazily instantiated by FirewallPolicySkuGenerator()
var firewallPolicySkuGenerator gopter.Gen

// FirewallPolicySkuGenerator returns a generator of FirewallPolicySku instances for property testing.
func FirewallPolicySkuGenerator() gopter.Gen {
	if firewallPolicySkuGenerator != nil {
		return firewallPolicySkuGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicySku(generators)
	firewallPolicySkuGenerator = gen.Struct(reflect.TypeOf(FirewallPolicySku{}), generators)

	return firewallPolicySkuGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicySku is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicySku(gens map[string]gopter.Gen) {
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(FirewallPolicySku_Tier_Basic, FirewallPolicySku_Tier_Premium, FirewallPolicySku_Tier_Standard))
}

func Test_FirewallPolicyThreatIntelWhitelist_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyThreatIntelWhitelist via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyThreatIntelWhitelist, FirewallPolicyThreatIntelWhitelistGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyThreatIntelWhitelist runs a test to see if a specific instance of FirewallPolicyThreatIntelWhitelist round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyThreatIntelWhitelist(subject FirewallPolicyThreatIntelWhitelist) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyThreatIntelWhitelist
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyThreatIntelWhitelist instances for property testing - lazily instantiated by
// FirewallPolicyThreatIntelWhitelistGenerator()
var firewallPolicyThreatIntelWhitelistGenerator gopter.Gen

// FirewallPolicyThreatIntelWhitelistGenerator returns a generator of FirewallPolicyThreatIntelWhitelist instances for property testing.
func FirewallPolicyThreatIntelWhitelistGenerator() gopter.Gen {
	if firewallPolicyThreatIntelWhitelistGenerator != nil {
		return firewallPolicyThreatIntelWhitelistGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyThreatIntelWhitelist(generators)
	firewallPolicyThreatIntelWhitelistGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyThreatIntelWhitelist{}), generators)

	return firewallPolicyThreatIntelWhitelistGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyThreatIntelWhitelist is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyThreatIntelWhitelist(gens map[string]gopter.Gen) {
	gens["Fqdns"] = gen.SliceOf(gen.AlphaString())
	gens["IpAddresses"] = gen.SliceOf(gen.AlphaString())
}

func Test_FirewallPolicyTransportSecurity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyTransportSecurity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyTransportSecurity, FirewallPolicyTransportSecurityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyTransportSecurity runs a test to see if a specific instance of FirewallPolicyTransportSecurity round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyTransportSecurity(subject FirewallPolicyTransportSecurity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyTransportSecurity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyTransportSecurity instances for property testing - lazily instantiated by
// FirewallPolicyTransportSecurityGenerator()
var firewallPolicyTransportSecurityGenerator gopter.Gen

// FirewallPolicyTransportSecurityGenerator returns a generator of FirewallPolicyTransportSecurity instances for property testing.
func FirewallPolicyTransportSecurityGenerator() gopter.Gen {
	if firewallPolicyTransportSecurityGenerator != nil {
		return firewallPolicyTransportSecurityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForFirewallPolicyTransportSecurity(generators)
	firewallPolicyTransportSecurityGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyTransportSecurity{}), generators)

	return firewallPolicyTransportSecurityGenerator
}

// AddRelatedPropertyGeneratorsForFirewallPolicyTransportSecurity is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyTransportSecurity(gens map[string]gopter.Gen) {
	gens["CertificateAuthority"] = gen.PtrOf(FirewallPolicyCertificateAuthorityGenerator())
}

func Test_FirewallPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicy_Spec, FirewallPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicy_Spec runs a test to see if a specific instance of FirewallPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicy_Spec(subject FirewallPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicy_Spec instances for property testing - lazily instantiated by
// FirewallPolicy_SpecGenerator()
var firewallPolicy_SpecGenerator gopter.Gen

// FirewallPolicy_SpecGenerator returns a generator of FirewallPolicy_Spec instances for property testing.
// We first initialize firewallPolicy_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicy_SpecGenerator() gopter.Gen {
	if firewallPolicy_SpecGenerator != nil {
		return firewallPolicy_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicy_Spec(generators)
	firewallPolicy_SpecGenerator = gen.Struct(reflect.TypeOf(FirewallPolicy_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicy_Spec(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicy_Spec(generators)
	firewallPolicy_SpecGenerator = gen.Struct(reflect.TypeOf(FirewallPolicy_Spec{}), generators)

	return firewallPolicy_SpecGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicy_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicy_Spec(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFirewallPolicy_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicy_Spec(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentityGenerator())
	gens["Properties"] = gen.PtrOf(FirewallPolicyPropertiesFormatGenerator())
}

func Test_ManagedServiceIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity, ManagedServiceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity runs a test to see if a specific instance of ManagedServiceIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity(subject ManagedServiceIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity instances for property testing - lazily instantiated by
// ManagedServiceIdentityGenerator()
var managedServiceIdentityGenerator gopter.Gen

// ManagedServiceIdentityGenerator returns a generator of ManagedServiceIdentity instances for property testing.
// We first initialize managedServiceIdentityGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentityGenerator() gopter.Gen {
	if managedServiceIdentityGenerator != nil {
		return managedServiceIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity(generators)
	managedServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentity(generators)
	managedServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity{}), generators)

	return managedServiceIdentityGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentity_Type_None,
		ManagedServiceIdentity_Type_SystemAssigned,
		ManagedServiceIdentity_Type_SystemAssignedUserAssigned,
		ManagedServiceIdentity_Type_UserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentity is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentity(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(
		gen.AlphaString(),
		UserAssignedIdentityDetailsGenerator())
}

func Test_UserAssignedIdentityDetails_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails runs a test to see if a specific instance of UserAssignedIdentityDetails round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails instances for property testing - lazily instantiated by
// UserAssignedIdentityDetailsGenerator()
var userAssignedIdentityDetailsGenerator gopter.Gen

// UserAssignedIdentityDetailsGenerator returns a generator of UserAssignedIdentityDetails instances for property testing.
func UserAssignedIdentityDetailsGenerator() gopter.Gen {
	if userAssignedIdentityDetailsGenerator != nil {
		return userAssignedIdentityDetailsGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetailsGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails{}), generators)

	return userAssignedIdentityDetailsGenerator
}
