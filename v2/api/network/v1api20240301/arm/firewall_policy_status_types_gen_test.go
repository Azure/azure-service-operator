// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_DnsSettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DnsSettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDnsSettings_STATUS, DnsSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDnsSettings_STATUS runs a test to see if a specific instance of DnsSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDnsSettings_STATUS(subject DnsSettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DnsSettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DnsSettings_STATUS instances for property testing - lazily instantiated by DnsSettings_STATUSGenerator()
var dnsSettings_STATUSGenerator gopter.Gen

// DnsSettings_STATUSGenerator returns a generator of DnsSettings_STATUS instances for property testing.
func DnsSettings_STATUSGenerator() gopter.Gen {
	if dnsSettings_STATUSGenerator != nil {
		return dnsSettings_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDnsSettings_STATUS(generators)
	dnsSettings_STATUSGenerator = gen.Struct(reflect.TypeOf(DnsSettings_STATUS{}), generators)

	return dnsSettings_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDnsSettings_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDnsSettings_STATUS(gens map[string]gopter.Gen) {
	gens["EnableProxy"] = gen.PtrOf(gen.Bool())
	gens["RequireProxyForNetworkRules"] = gen.PtrOf(gen.Bool())
	gens["Servers"] = gen.SliceOf(gen.AlphaString())
}

func Test_ExplicitProxy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExplicitProxy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExplicitProxy_STATUS, ExplicitProxy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExplicitProxy_STATUS runs a test to see if a specific instance of ExplicitProxy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForExplicitProxy_STATUS(subject ExplicitProxy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExplicitProxy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExplicitProxy_STATUS instances for property testing - lazily instantiated by
// ExplicitProxy_STATUSGenerator()
var explicitProxy_STATUSGenerator gopter.Gen

// ExplicitProxy_STATUSGenerator returns a generator of ExplicitProxy_STATUS instances for property testing.
func ExplicitProxy_STATUSGenerator() gopter.Gen {
	if explicitProxy_STATUSGenerator != nil {
		return explicitProxy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExplicitProxy_STATUS(generators)
	explicitProxy_STATUSGenerator = gen.Struct(reflect.TypeOf(ExplicitProxy_STATUS{}), generators)

	return explicitProxy_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForExplicitProxy_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExplicitProxy_STATUS(gens map[string]gopter.Gen) {
	gens["EnableExplicitProxy"] = gen.PtrOf(gen.Bool())
	gens["EnablePacFile"] = gen.PtrOf(gen.Bool())
	gens["HttpPort"] = gen.PtrOf(gen.Int())
	gens["HttpsPort"] = gen.PtrOf(gen.Int())
	gens["PacFile"] = gen.PtrOf(gen.AlphaString())
	gens["PacFilePort"] = gen.PtrOf(gen.Int())
}

func Test_FirewallPolicyCertificateAuthority_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyCertificateAuthority_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyCertificateAuthority_STATUS, FirewallPolicyCertificateAuthority_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyCertificateAuthority_STATUS runs a test to see if a specific instance of FirewallPolicyCertificateAuthority_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyCertificateAuthority_STATUS(subject FirewallPolicyCertificateAuthority_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyCertificateAuthority_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyCertificateAuthority_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyCertificateAuthority_STATUSGenerator()
var firewallPolicyCertificateAuthority_STATUSGenerator gopter.Gen

// FirewallPolicyCertificateAuthority_STATUSGenerator returns a generator of FirewallPolicyCertificateAuthority_STATUS instances for property testing.
func FirewallPolicyCertificateAuthority_STATUSGenerator() gopter.Gen {
	if firewallPolicyCertificateAuthority_STATUSGenerator != nil {
		return firewallPolicyCertificateAuthority_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyCertificateAuthority_STATUS(generators)
	firewallPolicyCertificateAuthority_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyCertificateAuthority_STATUS{}), generators)

	return firewallPolicyCertificateAuthority_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyCertificateAuthority_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyCertificateAuthority_STATUS(gens map[string]gopter.Gen) {
	gens["KeyVaultSecretId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_FirewallPolicyInsights_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyInsights_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyInsights_STATUS, FirewallPolicyInsights_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyInsights_STATUS runs a test to see if a specific instance of FirewallPolicyInsights_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyInsights_STATUS(subject FirewallPolicyInsights_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyInsights_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyInsights_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyInsights_STATUSGenerator()
var firewallPolicyInsights_STATUSGenerator gopter.Gen

// FirewallPolicyInsights_STATUSGenerator returns a generator of FirewallPolicyInsights_STATUS instances for property testing.
// We first initialize firewallPolicyInsights_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyInsights_STATUSGenerator() gopter.Gen {
	if firewallPolicyInsights_STATUSGenerator != nil {
		return firewallPolicyInsights_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyInsights_STATUS(generators)
	firewallPolicyInsights_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyInsights_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyInsights_STATUS(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyInsights_STATUS(generators)
	firewallPolicyInsights_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyInsights_STATUS{}), generators)

	return firewallPolicyInsights_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyInsights_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyInsights_STATUS(gens map[string]gopter.Gen) {
	gens["IsEnabled"] = gen.PtrOf(gen.Bool())
	gens["RetentionDays"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForFirewallPolicyInsights_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyInsights_STATUS(gens map[string]gopter.Gen) {
	gens["LogAnalyticsResources"] = gen.PtrOf(FirewallPolicyLogAnalyticsResources_STATUSGenerator())
}

func Test_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS, FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS runs a test to see if a specific instance of FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS(subject FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS instances for property testing -
// lazily instantiated by FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator()
var firewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator gopter.Gen

// FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator returns a generator of FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS instances for property testing.
func FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator() gopter.Gen {
	if firewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator != nil {
		return firewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS(generators)
	firewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS{}), generators)

	return firewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DestinationAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationIpGroups"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationPorts"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(
		FirewallPolicyIntrusionDetectionBypassTrafficProtocol_STATUS_ANY,
		FirewallPolicyIntrusionDetectionBypassTrafficProtocol_STATUS_ICMP,
		FirewallPolicyIntrusionDetectionBypassTrafficProtocol_STATUS_TCP,
		FirewallPolicyIntrusionDetectionBypassTrafficProtocol_STATUS_UDP))
	gens["SourceAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["SourceIpGroups"] = gen.SliceOf(gen.AlphaString())
}

func Test_FirewallPolicyIntrusionDetectionConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyIntrusionDetectionConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyIntrusionDetectionConfiguration_STATUS, FirewallPolicyIntrusionDetectionConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyIntrusionDetectionConfiguration_STATUS runs a test to see if a specific instance of FirewallPolicyIntrusionDetectionConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyIntrusionDetectionConfiguration_STATUS(subject FirewallPolicyIntrusionDetectionConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyIntrusionDetectionConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyIntrusionDetectionConfiguration_STATUS instances for property testing - lazily
// instantiated by FirewallPolicyIntrusionDetectionConfiguration_STATUSGenerator()
var firewallPolicyIntrusionDetectionConfiguration_STATUSGenerator gopter.Gen

// FirewallPolicyIntrusionDetectionConfiguration_STATUSGenerator returns a generator of FirewallPolicyIntrusionDetectionConfiguration_STATUS instances for property testing.
// We first initialize firewallPolicyIntrusionDetectionConfiguration_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyIntrusionDetectionConfiguration_STATUSGenerator() gopter.Gen {
	if firewallPolicyIntrusionDetectionConfiguration_STATUSGenerator != nil {
		return firewallPolicyIntrusionDetectionConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration_STATUS(generators)
	firewallPolicyIntrusionDetectionConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetectionConfiguration_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration_STATUS(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration_STATUS(generators)
	firewallPolicyIntrusionDetectionConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetectionConfiguration_STATUS{}), generators)

	return firewallPolicyIntrusionDetectionConfiguration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["PrivateRanges"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["BypassTrafficSettings"] = gen.SliceOf(FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator())
	gens["SignatureOverrides"] = gen.SliceOf(FirewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator())
}

func Test_FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyIntrusionDetectionSignatureSpecification_STATUS, FirewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyIntrusionDetectionSignatureSpecification_STATUS runs a test to see if a specific instance of FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyIntrusionDetectionSignatureSpecification_STATUS(subject FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS instances for property testing - lazily
// instantiated by FirewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator()
var firewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator gopter.Gen

// FirewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator returns a generator of FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS instances for property testing.
func FirewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator() gopter.Gen {
	if firewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator != nil {
		return firewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionSignatureSpecification_STATUS(generators)
	firewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS{}), generators)

	return firewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionSignatureSpecification_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionSignatureSpecification_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Mode"] = gen.PtrOf(gen.OneConstOf(FirewallPolicyIntrusionDetectionStateOptions_STATUS_Alert, FirewallPolicyIntrusionDetectionStateOptions_STATUS_Deny, FirewallPolicyIntrusionDetectionStateOptions_STATUS_Off))
}

func Test_FirewallPolicyIntrusionDetection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyIntrusionDetection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyIntrusionDetection_STATUS, FirewallPolicyIntrusionDetection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyIntrusionDetection_STATUS runs a test to see if a specific instance of FirewallPolicyIntrusionDetection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyIntrusionDetection_STATUS(subject FirewallPolicyIntrusionDetection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyIntrusionDetection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyIntrusionDetection_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyIntrusionDetection_STATUSGenerator()
var firewallPolicyIntrusionDetection_STATUSGenerator gopter.Gen

// FirewallPolicyIntrusionDetection_STATUSGenerator returns a generator of FirewallPolicyIntrusionDetection_STATUS instances for property testing.
// We first initialize firewallPolicyIntrusionDetection_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyIntrusionDetection_STATUSGenerator() gopter.Gen {
	if firewallPolicyIntrusionDetection_STATUSGenerator != nil {
		return firewallPolicyIntrusionDetection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetection_STATUS(generators)
	firewallPolicyIntrusionDetection_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetection_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetection_STATUS(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetection_STATUS(generators)
	firewallPolicyIntrusionDetection_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetection_STATUS{}), generators)

	return firewallPolicyIntrusionDetection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetection_STATUS(gens map[string]gopter.Gen) {
	gens["Mode"] = gen.PtrOf(gen.OneConstOf(FirewallPolicyIntrusionDetectionStateOptions_STATUS_Alert, FirewallPolicyIntrusionDetectionStateOptions_STATUS_Deny, FirewallPolicyIntrusionDetectionStateOptions_STATUS_Off))
	gens["Profile"] = gen.PtrOf(gen.OneConstOf(
		FirewallPolicyIntrusionDetectionProfileOptions_STATUS_Advanced,
		FirewallPolicyIntrusionDetectionProfileOptions_STATUS_Basic,
		FirewallPolicyIntrusionDetectionProfileOptions_STATUS_Extended,
		FirewallPolicyIntrusionDetectionProfileOptions_STATUS_Standard))
}

// AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetection_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetection_STATUS(gens map[string]gopter.Gen) {
	gens["Configuration"] = gen.PtrOf(FirewallPolicyIntrusionDetectionConfiguration_STATUSGenerator())
}

func Test_FirewallPolicyLogAnalyticsResources_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyLogAnalyticsResources_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyLogAnalyticsResources_STATUS, FirewallPolicyLogAnalyticsResources_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyLogAnalyticsResources_STATUS runs a test to see if a specific instance of FirewallPolicyLogAnalyticsResources_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyLogAnalyticsResources_STATUS(subject FirewallPolicyLogAnalyticsResources_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyLogAnalyticsResources_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyLogAnalyticsResources_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyLogAnalyticsResources_STATUSGenerator()
var firewallPolicyLogAnalyticsResources_STATUSGenerator gopter.Gen

// FirewallPolicyLogAnalyticsResources_STATUSGenerator returns a generator of FirewallPolicyLogAnalyticsResources_STATUS instances for property testing.
func FirewallPolicyLogAnalyticsResources_STATUSGenerator() gopter.Gen {
	if firewallPolicyLogAnalyticsResources_STATUSGenerator != nil {
		return firewallPolicyLogAnalyticsResources_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsResources_STATUS(generators)
	firewallPolicyLogAnalyticsResources_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyLogAnalyticsResources_STATUS{}), generators)

	return firewallPolicyLogAnalyticsResources_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsResources_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsResources_STATUS(gens map[string]gopter.Gen) {
	gens["DefaultWorkspaceId"] = gen.PtrOf(SubResource_STATUSGenerator())
	gens["Workspaces"] = gen.SliceOf(FirewallPolicyLogAnalyticsWorkspace_STATUSGenerator())
}

func Test_FirewallPolicyLogAnalyticsWorkspace_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyLogAnalyticsWorkspace_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyLogAnalyticsWorkspace_STATUS, FirewallPolicyLogAnalyticsWorkspace_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyLogAnalyticsWorkspace_STATUS runs a test to see if a specific instance of FirewallPolicyLogAnalyticsWorkspace_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyLogAnalyticsWorkspace_STATUS(subject FirewallPolicyLogAnalyticsWorkspace_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyLogAnalyticsWorkspace_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyLogAnalyticsWorkspace_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyLogAnalyticsWorkspace_STATUSGenerator()
var firewallPolicyLogAnalyticsWorkspace_STATUSGenerator gopter.Gen

// FirewallPolicyLogAnalyticsWorkspace_STATUSGenerator returns a generator of FirewallPolicyLogAnalyticsWorkspace_STATUS instances for property testing.
// We first initialize firewallPolicyLogAnalyticsWorkspace_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyLogAnalyticsWorkspace_STATUSGenerator() gopter.Gen {
	if firewallPolicyLogAnalyticsWorkspace_STATUSGenerator != nil {
		return firewallPolicyLogAnalyticsWorkspace_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace_STATUS(generators)
	firewallPolicyLogAnalyticsWorkspace_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyLogAnalyticsWorkspace_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace_STATUS(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace_STATUS(generators)
	firewallPolicyLogAnalyticsWorkspace_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyLogAnalyticsWorkspace_STATUS{}), generators)

	return firewallPolicyLogAnalyticsWorkspace_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace_STATUS(gens map[string]gopter.Gen) {
	gens["Region"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace_STATUS(gens map[string]gopter.Gen) {
	gens["WorkspaceId"] = gen.PtrOf(SubResource_STATUSGenerator())
}

func Test_FirewallPolicyPropertiesFormat_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyPropertiesFormat_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyPropertiesFormat_STATUS, FirewallPolicyPropertiesFormat_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyPropertiesFormat_STATUS runs a test to see if a specific instance of FirewallPolicyPropertiesFormat_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyPropertiesFormat_STATUS(subject FirewallPolicyPropertiesFormat_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyPropertiesFormat_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyPropertiesFormat_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyPropertiesFormat_STATUSGenerator()
var firewallPolicyPropertiesFormat_STATUSGenerator gopter.Gen

// FirewallPolicyPropertiesFormat_STATUSGenerator returns a generator of FirewallPolicyPropertiesFormat_STATUS instances for property testing.
// We first initialize firewallPolicyPropertiesFormat_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyPropertiesFormat_STATUSGenerator() gopter.Gen {
	if firewallPolicyPropertiesFormat_STATUSGenerator != nil {
		return firewallPolicyPropertiesFormat_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyPropertiesFormat_STATUS(generators)
	firewallPolicyPropertiesFormat_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyPropertiesFormat_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyPropertiesFormat_STATUS(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyPropertiesFormat_STATUS(generators)
	firewallPolicyPropertiesFormat_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyPropertiesFormat_STATUS{}), generators)

	return firewallPolicyPropertiesFormat_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyPropertiesFormat_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyPropertiesFormat_STATUS(gens map[string]gopter.Gen) {
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Updating))
	gens["Size"] = gen.PtrOf(gen.AlphaString())
	gens["ThreatIntelMode"] = gen.PtrOf(gen.OneConstOf(AzureFirewallThreatIntelMode_STATUS_Alert, AzureFirewallThreatIntelMode_STATUS_Deny, AzureFirewallThreatIntelMode_STATUS_Off))
}

// AddRelatedPropertyGeneratorsForFirewallPolicyPropertiesFormat_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyPropertiesFormat_STATUS(gens map[string]gopter.Gen) {
	gens["BasePolicy"] = gen.PtrOf(SubResource_STATUSGenerator())
	gens["ChildPolicies"] = gen.SliceOf(SubResource_STATUSGenerator())
	gens["DnsSettings"] = gen.PtrOf(DnsSettings_STATUSGenerator())
	gens["ExplicitProxy"] = gen.PtrOf(ExplicitProxy_STATUSGenerator())
	gens["Firewalls"] = gen.SliceOf(SubResource_STATUSGenerator())
	gens["Insights"] = gen.PtrOf(FirewallPolicyInsights_STATUSGenerator())
	gens["IntrusionDetection"] = gen.PtrOf(FirewallPolicyIntrusionDetection_STATUSGenerator())
	gens["RuleCollectionGroups"] = gen.SliceOf(SubResource_STATUSGenerator())
	gens["Sku"] = gen.PtrOf(FirewallPolicySku_STATUSGenerator())
	gens["Snat"] = gen.PtrOf(FirewallPolicySNAT_STATUSGenerator())
	gens["Sql"] = gen.PtrOf(FirewallPolicySQL_STATUSGenerator())
	gens["ThreatIntelWhitelist"] = gen.PtrOf(FirewallPolicyThreatIntelWhitelist_STATUSGenerator())
	gens["TransportSecurity"] = gen.PtrOf(FirewallPolicyTransportSecurity_STATUSGenerator())
}

func Test_FirewallPolicySNAT_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicySNAT_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicySNAT_STATUS, FirewallPolicySNAT_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicySNAT_STATUS runs a test to see if a specific instance of FirewallPolicySNAT_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicySNAT_STATUS(subject FirewallPolicySNAT_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicySNAT_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicySNAT_STATUS instances for property testing - lazily instantiated by
// FirewallPolicySNAT_STATUSGenerator()
var firewallPolicySNAT_STATUSGenerator gopter.Gen

// FirewallPolicySNAT_STATUSGenerator returns a generator of FirewallPolicySNAT_STATUS instances for property testing.
func FirewallPolicySNAT_STATUSGenerator() gopter.Gen {
	if firewallPolicySNAT_STATUSGenerator != nil {
		return firewallPolicySNAT_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicySNAT_STATUS(generators)
	firewallPolicySNAT_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicySNAT_STATUS{}), generators)

	return firewallPolicySNAT_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicySNAT_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicySNAT_STATUS(gens map[string]gopter.Gen) {
	gens["AutoLearnPrivateRanges"] = gen.PtrOf(gen.OneConstOf(FirewallPolicySNAT_AutoLearnPrivateRanges_STATUS_Disabled, FirewallPolicySNAT_AutoLearnPrivateRanges_STATUS_Enabled))
	gens["PrivateRanges"] = gen.SliceOf(gen.AlphaString())
}

func Test_FirewallPolicySQL_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicySQL_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicySQL_STATUS, FirewallPolicySQL_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicySQL_STATUS runs a test to see if a specific instance of FirewallPolicySQL_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicySQL_STATUS(subject FirewallPolicySQL_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicySQL_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicySQL_STATUS instances for property testing - lazily instantiated by
// FirewallPolicySQL_STATUSGenerator()
var firewallPolicySQL_STATUSGenerator gopter.Gen

// FirewallPolicySQL_STATUSGenerator returns a generator of FirewallPolicySQL_STATUS instances for property testing.
func FirewallPolicySQL_STATUSGenerator() gopter.Gen {
	if firewallPolicySQL_STATUSGenerator != nil {
		return firewallPolicySQL_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicySQL_STATUS(generators)
	firewallPolicySQL_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicySQL_STATUS{}), generators)

	return firewallPolicySQL_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicySQL_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicySQL_STATUS(gens map[string]gopter.Gen) {
	gens["AllowSqlRedirect"] = gen.PtrOf(gen.Bool())
}

func Test_FirewallPolicySku_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicySku_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicySku_STATUS, FirewallPolicySku_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicySku_STATUS runs a test to see if a specific instance of FirewallPolicySku_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicySku_STATUS(subject FirewallPolicySku_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicySku_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicySku_STATUS instances for property testing - lazily instantiated by
// FirewallPolicySku_STATUSGenerator()
var firewallPolicySku_STATUSGenerator gopter.Gen

// FirewallPolicySku_STATUSGenerator returns a generator of FirewallPolicySku_STATUS instances for property testing.
func FirewallPolicySku_STATUSGenerator() gopter.Gen {
	if firewallPolicySku_STATUSGenerator != nil {
		return firewallPolicySku_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicySku_STATUS(generators)
	firewallPolicySku_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicySku_STATUS{}), generators)

	return firewallPolicySku_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicySku_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicySku_STATUS(gens map[string]gopter.Gen) {
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(FirewallPolicySku_Tier_STATUS_Basic, FirewallPolicySku_Tier_STATUS_Premium, FirewallPolicySku_Tier_STATUS_Standard))
}

func Test_FirewallPolicyThreatIntelWhitelist_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyThreatIntelWhitelist_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyThreatIntelWhitelist_STATUS, FirewallPolicyThreatIntelWhitelist_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyThreatIntelWhitelist_STATUS runs a test to see if a specific instance of FirewallPolicyThreatIntelWhitelist_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyThreatIntelWhitelist_STATUS(subject FirewallPolicyThreatIntelWhitelist_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyThreatIntelWhitelist_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyThreatIntelWhitelist_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyThreatIntelWhitelist_STATUSGenerator()
var firewallPolicyThreatIntelWhitelist_STATUSGenerator gopter.Gen

// FirewallPolicyThreatIntelWhitelist_STATUSGenerator returns a generator of FirewallPolicyThreatIntelWhitelist_STATUS instances for property testing.
func FirewallPolicyThreatIntelWhitelist_STATUSGenerator() gopter.Gen {
	if firewallPolicyThreatIntelWhitelist_STATUSGenerator != nil {
		return firewallPolicyThreatIntelWhitelist_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyThreatIntelWhitelist_STATUS(generators)
	firewallPolicyThreatIntelWhitelist_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyThreatIntelWhitelist_STATUS{}), generators)

	return firewallPolicyThreatIntelWhitelist_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyThreatIntelWhitelist_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyThreatIntelWhitelist_STATUS(gens map[string]gopter.Gen) {
	gens["Fqdns"] = gen.SliceOf(gen.AlphaString())
	gens["IpAddresses"] = gen.SliceOf(gen.AlphaString())
}

func Test_FirewallPolicyTransportSecurity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyTransportSecurity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyTransportSecurity_STATUS, FirewallPolicyTransportSecurity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyTransportSecurity_STATUS runs a test to see if a specific instance of FirewallPolicyTransportSecurity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyTransportSecurity_STATUS(subject FirewallPolicyTransportSecurity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyTransportSecurity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyTransportSecurity_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyTransportSecurity_STATUSGenerator()
var firewallPolicyTransportSecurity_STATUSGenerator gopter.Gen

// FirewallPolicyTransportSecurity_STATUSGenerator returns a generator of FirewallPolicyTransportSecurity_STATUS instances for property testing.
func FirewallPolicyTransportSecurity_STATUSGenerator() gopter.Gen {
	if firewallPolicyTransportSecurity_STATUSGenerator != nil {
		return firewallPolicyTransportSecurity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForFirewallPolicyTransportSecurity_STATUS(generators)
	firewallPolicyTransportSecurity_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyTransportSecurity_STATUS{}), generators)

	return firewallPolicyTransportSecurity_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForFirewallPolicyTransportSecurity_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyTransportSecurity_STATUS(gens map[string]gopter.Gen) {
	gens["CertificateAuthority"] = gen.PtrOf(FirewallPolicyCertificateAuthority_STATUSGenerator())
}

func Test_FirewallPolicy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicy_STATUS, FirewallPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicy_STATUS runs a test to see if a specific instance of FirewallPolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicy_STATUS(subject FirewallPolicy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicy_STATUS instances for property testing - lazily instantiated by
// FirewallPolicy_STATUSGenerator()
var firewallPolicy_STATUSGenerator gopter.Gen

// FirewallPolicy_STATUSGenerator returns a generator of FirewallPolicy_STATUS instances for property testing.
// We first initialize firewallPolicy_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicy_STATUSGenerator() gopter.Gen {
	if firewallPolicy_STATUSGenerator != nil {
		return firewallPolicy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicy_STATUS(generators)
	firewallPolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicy_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicy_STATUS(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicy_STATUS(generators)
	firewallPolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicy_STATUS{}), generators)

	return firewallPolicy_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicy_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicy_STATUS(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFirewallPolicy_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicy_STATUS(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentity_STATUSGenerator())
	gens["Properties"] = gen.PtrOf(FirewallPolicyPropertiesFormat_STATUSGenerator())
}

func Test_ManagedServiceIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity_STATUS, ManagedServiceIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity_STATUS runs a test to see if a specific instance of ManagedServiceIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity_STATUS(subject ManagedServiceIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_STATUS instances for property testing - lazily instantiated by
// ManagedServiceIdentity_STATUSGenerator()
var managedServiceIdentity_STATUSGenerator gopter.Gen

// ManagedServiceIdentity_STATUSGenerator returns a generator of ManagedServiceIdentity_STATUS instances for property testing.
// We first initialize managedServiceIdentity_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentity_STATUSGenerator() gopter.Gen {
	if managedServiceIdentity_STATUSGenerator != nil {
		return managedServiceIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS(generators)
	managedServiceIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUS(generators)
	managedServiceIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_STATUS{}), generators)

	return managedServiceIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentity_Type_STATUS_None,
		ManagedServiceIdentity_Type_STATUS_SystemAssigned,
		ManagedServiceIdentity_Type_STATUS_SystemAssignedUserAssigned,
		ManagedServiceIdentity_Type_STATUS_UserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(
		gen.AlphaString(),
		ManagedServiceIdentity_UserAssignedIdentities_STATUSGenerator())
}

func Test_ManagedServiceIdentity_UserAssignedIdentities_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_UserAssignedIdentities_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity_UserAssignedIdentities_STATUS, ManagedServiceIdentity_UserAssignedIdentities_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity_UserAssignedIdentities_STATUS runs a test to see if a specific instance of ManagedServiceIdentity_UserAssignedIdentities_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity_UserAssignedIdentities_STATUS(subject ManagedServiceIdentity_UserAssignedIdentities_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_UserAssignedIdentities_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_UserAssignedIdentities_STATUS instances for property testing - lazily
// instantiated by ManagedServiceIdentity_UserAssignedIdentities_STATUSGenerator()
var managedServiceIdentity_UserAssignedIdentities_STATUSGenerator gopter.Gen

// ManagedServiceIdentity_UserAssignedIdentities_STATUSGenerator returns a generator of ManagedServiceIdentity_UserAssignedIdentities_STATUS instances for property testing.
func ManagedServiceIdentity_UserAssignedIdentities_STATUSGenerator() gopter.Gen {
	if managedServiceIdentity_UserAssignedIdentities_STATUSGenerator != nil {
		return managedServiceIdentity_UserAssignedIdentities_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_UserAssignedIdentities_STATUS(generators)
	managedServiceIdentity_UserAssignedIdentities_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_UserAssignedIdentities_STATUS{}), generators)

	return managedServiceIdentity_UserAssignedIdentities_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity_UserAssignedIdentities_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity_UserAssignedIdentities_STATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}
