// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AzureFirewallApplicationRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallApplicationRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallApplicationRule, AzureFirewallApplicationRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallApplicationRule runs a test to see if a specific instance of AzureFirewallApplicationRule round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallApplicationRule(subject AzureFirewallApplicationRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallApplicationRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallApplicationRule instances for property testing - lazily instantiated by
// AzureFirewallApplicationRuleGenerator()
var azureFirewallApplicationRuleGenerator gopter.Gen

// AzureFirewallApplicationRuleGenerator returns a generator of AzureFirewallApplicationRule instances for property testing.
// We first initialize azureFirewallApplicationRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFirewallApplicationRuleGenerator() gopter.Gen {
	if azureFirewallApplicationRuleGenerator != nil {
		return azureFirewallApplicationRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallApplicationRule(generators)
	azureFirewallApplicationRuleGenerator = gen.Struct(reflect.TypeOf(AzureFirewallApplicationRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallApplicationRule(generators)
	AddRelatedPropertyGeneratorsForAzureFirewallApplicationRule(generators)
	azureFirewallApplicationRuleGenerator = gen.Struct(reflect.TypeOf(AzureFirewallApplicationRule{}), generators)

	return azureFirewallApplicationRuleGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallApplicationRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallApplicationRule(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["FqdnTags"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SourceAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["SourceIpGroups"] = gen.SliceOf(gen.AlphaString())
	gens["TargetFqdns"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAzureFirewallApplicationRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFirewallApplicationRule(gens map[string]gopter.Gen) {
	gens["Protocols"] = gen.SliceOf(AzureFirewallApplicationRuleProtocolGenerator())
}

func Test_AzureFirewallApplicationRuleCollection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallApplicationRuleCollection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallApplicationRuleCollection, AzureFirewallApplicationRuleCollectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallApplicationRuleCollection runs a test to see if a specific instance of AzureFirewallApplicationRuleCollection round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallApplicationRuleCollection(subject AzureFirewallApplicationRuleCollection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallApplicationRuleCollection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallApplicationRuleCollection instances for property testing - lazily instantiated by
// AzureFirewallApplicationRuleCollectionGenerator()
var azureFirewallApplicationRuleCollectionGenerator gopter.Gen

// AzureFirewallApplicationRuleCollectionGenerator returns a generator of AzureFirewallApplicationRuleCollection instances for property testing.
// We first initialize azureFirewallApplicationRuleCollectionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFirewallApplicationRuleCollectionGenerator() gopter.Gen {
	if azureFirewallApplicationRuleCollectionGenerator != nil {
		return azureFirewallApplicationRuleCollectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallApplicationRuleCollection(generators)
	azureFirewallApplicationRuleCollectionGenerator = gen.Struct(reflect.TypeOf(AzureFirewallApplicationRuleCollection{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallApplicationRuleCollection(generators)
	AddRelatedPropertyGeneratorsForAzureFirewallApplicationRuleCollection(generators)
	azureFirewallApplicationRuleCollectionGenerator = gen.Struct(reflect.TypeOf(AzureFirewallApplicationRuleCollection{}), generators)

	return azureFirewallApplicationRuleCollectionGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallApplicationRuleCollection is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallApplicationRuleCollection(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAzureFirewallApplicationRuleCollection is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFirewallApplicationRuleCollection(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(AzureFirewallApplicationRuleCollectionPropertiesFormatGenerator())
}

func Test_AzureFirewallApplicationRuleCollectionPropertiesFormat_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallApplicationRuleCollectionPropertiesFormat via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallApplicationRuleCollectionPropertiesFormat, AzureFirewallApplicationRuleCollectionPropertiesFormatGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallApplicationRuleCollectionPropertiesFormat runs a test to see if a specific instance of AzureFirewallApplicationRuleCollectionPropertiesFormat round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallApplicationRuleCollectionPropertiesFormat(subject AzureFirewallApplicationRuleCollectionPropertiesFormat) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallApplicationRuleCollectionPropertiesFormat
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallApplicationRuleCollectionPropertiesFormat instances for property testing - lazily
// instantiated by AzureFirewallApplicationRuleCollectionPropertiesFormatGenerator()
var azureFirewallApplicationRuleCollectionPropertiesFormatGenerator gopter.Gen

// AzureFirewallApplicationRuleCollectionPropertiesFormatGenerator returns a generator of AzureFirewallApplicationRuleCollectionPropertiesFormat instances for property testing.
// We first initialize azureFirewallApplicationRuleCollectionPropertiesFormatGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFirewallApplicationRuleCollectionPropertiesFormatGenerator() gopter.Gen {
	if azureFirewallApplicationRuleCollectionPropertiesFormatGenerator != nil {
		return azureFirewallApplicationRuleCollectionPropertiesFormatGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallApplicationRuleCollectionPropertiesFormat(generators)
	azureFirewallApplicationRuleCollectionPropertiesFormatGenerator = gen.Struct(reflect.TypeOf(AzureFirewallApplicationRuleCollectionPropertiesFormat{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallApplicationRuleCollectionPropertiesFormat(generators)
	AddRelatedPropertyGeneratorsForAzureFirewallApplicationRuleCollectionPropertiesFormat(generators)
	azureFirewallApplicationRuleCollectionPropertiesFormatGenerator = gen.Struct(reflect.TypeOf(AzureFirewallApplicationRuleCollectionPropertiesFormat{}), generators)

	return azureFirewallApplicationRuleCollectionPropertiesFormatGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallApplicationRuleCollectionPropertiesFormat is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallApplicationRuleCollectionPropertiesFormat(gens map[string]gopter.Gen) {
	gens["Priority"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForAzureFirewallApplicationRuleCollectionPropertiesFormat is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFirewallApplicationRuleCollectionPropertiesFormat(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(AzureFirewallRCActionGenerator())
	gens["Rules"] = gen.SliceOf(AzureFirewallApplicationRuleGenerator())
}

func Test_AzureFirewallApplicationRuleProtocol_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallApplicationRuleProtocol via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallApplicationRuleProtocol, AzureFirewallApplicationRuleProtocolGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallApplicationRuleProtocol runs a test to see if a specific instance of AzureFirewallApplicationRuleProtocol round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallApplicationRuleProtocol(subject AzureFirewallApplicationRuleProtocol) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallApplicationRuleProtocol
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallApplicationRuleProtocol instances for property testing - lazily instantiated by
// AzureFirewallApplicationRuleProtocolGenerator()
var azureFirewallApplicationRuleProtocolGenerator gopter.Gen

// AzureFirewallApplicationRuleProtocolGenerator returns a generator of AzureFirewallApplicationRuleProtocol instances for property testing.
func AzureFirewallApplicationRuleProtocolGenerator() gopter.Gen {
	if azureFirewallApplicationRuleProtocolGenerator != nil {
		return azureFirewallApplicationRuleProtocolGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallApplicationRuleProtocol(generators)
	azureFirewallApplicationRuleProtocolGenerator = gen.Struct(reflect.TypeOf(AzureFirewallApplicationRuleProtocol{}), generators)

	return azureFirewallApplicationRuleProtocolGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallApplicationRuleProtocol is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallApplicationRuleProtocol(gens map[string]gopter.Gen) {
	gens["Port"] = gen.PtrOf(gen.Int())
	gens["ProtocolType"] = gen.PtrOf(gen.OneConstOf(AzureFirewallApplicationRuleProtocolType_Http, AzureFirewallApplicationRuleProtocolType_Https, AzureFirewallApplicationRuleProtocolType_Mssql))
}

func Test_AzureFirewallAutoscaleConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallAutoscaleConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallAutoscaleConfiguration, AzureFirewallAutoscaleConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallAutoscaleConfiguration runs a test to see if a specific instance of AzureFirewallAutoscaleConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallAutoscaleConfiguration(subject AzureFirewallAutoscaleConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallAutoscaleConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallAutoscaleConfiguration instances for property testing - lazily instantiated by
// AzureFirewallAutoscaleConfigurationGenerator()
var azureFirewallAutoscaleConfigurationGenerator gopter.Gen

// AzureFirewallAutoscaleConfigurationGenerator returns a generator of AzureFirewallAutoscaleConfiguration instances for property testing.
func AzureFirewallAutoscaleConfigurationGenerator() gopter.Gen {
	if azureFirewallAutoscaleConfigurationGenerator != nil {
		return azureFirewallAutoscaleConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallAutoscaleConfiguration(generators)
	azureFirewallAutoscaleConfigurationGenerator = gen.Struct(reflect.TypeOf(AzureFirewallAutoscaleConfiguration{}), generators)

	return azureFirewallAutoscaleConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallAutoscaleConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallAutoscaleConfiguration(gens map[string]gopter.Gen) {
	gens["MaxCapacity"] = gen.PtrOf(gen.Int())
	gens["MinCapacity"] = gen.PtrOf(gen.Int())
}

func Test_AzureFirewallIPConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallIPConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallIPConfiguration, AzureFirewallIPConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallIPConfiguration runs a test to see if a specific instance of AzureFirewallIPConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallIPConfiguration(subject AzureFirewallIPConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallIPConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallIPConfiguration instances for property testing - lazily instantiated by
// AzureFirewallIPConfigurationGenerator()
var azureFirewallIPConfigurationGenerator gopter.Gen

// AzureFirewallIPConfigurationGenerator returns a generator of AzureFirewallIPConfiguration instances for property testing.
// We first initialize azureFirewallIPConfigurationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFirewallIPConfigurationGenerator() gopter.Gen {
	if azureFirewallIPConfigurationGenerator != nil {
		return azureFirewallIPConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallIPConfiguration(generators)
	azureFirewallIPConfigurationGenerator = gen.Struct(reflect.TypeOf(AzureFirewallIPConfiguration{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallIPConfiguration(generators)
	AddRelatedPropertyGeneratorsForAzureFirewallIPConfiguration(generators)
	azureFirewallIPConfigurationGenerator = gen.Struct(reflect.TypeOf(AzureFirewallIPConfiguration{}), generators)

	return azureFirewallIPConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallIPConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallIPConfiguration(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAzureFirewallIPConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFirewallIPConfiguration(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(AzureFirewallIPConfigurationPropertiesFormatGenerator())
}

func Test_AzureFirewallIPConfigurationPropertiesFormat_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallIPConfigurationPropertiesFormat via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallIPConfigurationPropertiesFormat, AzureFirewallIPConfigurationPropertiesFormatGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallIPConfigurationPropertiesFormat runs a test to see if a specific instance of AzureFirewallIPConfigurationPropertiesFormat round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallIPConfigurationPropertiesFormat(subject AzureFirewallIPConfigurationPropertiesFormat) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallIPConfigurationPropertiesFormat
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallIPConfigurationPropertiesFormat instances for property testing - lazily instantiated by
// AzureFirewallIPConfigurationPropertiesFormatGenerator()
var azureFirewallIPConfigurationPropertiesFormatGenerator gopter.Gen

// AzureFirewallIPConfigurationPropertiesFormatGenerator returns a generator of AzureFirewallIPConfigurationPropertiesFormat instances for property testing.
func AzureFirewallIPConfigurationPropertiesFormatGenerator() gopter.Gen {
	if azureFirewallIPConfigurationPropertiesFormatGenerator != nil {
		return azureFirewallIPConfigurationPropertiesFormatGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAzureFirewallIPConfigurationPropertiesFormat(generators)
	azureFirewallIPConfigurationPropertiesFormatGenerator = gen.Struct(reflect.TypeOf(AzureFirewallIPConfigurationPropertiesFormat{}), generators)

	return azureFirewallIPConfigurationPropertiesFormatGenerator
}

// AddRelatedPropertyGeneratorsForAzureFirewallIPConfigurationPropertiesFormat is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFirewallIPConfigurationPropertiesFormat(gens map[string]gopter.Gen) {
	gens["PublicIPAddress"] = gen.PtrOf(SubResourceGenerator())
	gens["Subnet"] = gen.PtrOf(SubResourceGenerator())
}

func Test_AzureFirewallNatRCAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallNatRCAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallNatRCAction, AzureFirewallNatRCActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallNatRCAction runs a test to see if a specific instance of AzureFirewallNatRCAction round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallNatRCAction(subject AzureFirewallNatRCAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallNatRCAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallNatRCAction instances for property testing - lazily instantiated by
// AzureFirewallNatRCActionGenerator()
var azureFirewallNatRCActionGenerator gopter.Gen

// AzureFirewallNatRCActionGenerator returns a generator of AzureFirewallNatRCAction instances for property testing.
func AzureFirewallNatRCActionGenerator() gopter.Gen {
	if azureFirewallNatRCActionGenerator != nil {
		return azureFirewallNatRCActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallNatRCAction(generators)
	azureFirewallNatRCActionGenerator = gen.Struct(reflect.TypeOf(AzureFirewallNatRCAction{}), generators)

	return azureFirewallNatRCActionGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallNatRCAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallNatRCAction(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(AzureFirewallNatRCActionType_Dnat, AzureFirewallNatRCActionType_Snat))
}

func Test_AzureFirewallNatRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallNatRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallNatRule, AzureFirewallNatRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallNatRule runs a test to see if a specific instance of AzureFirewallNatRule round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallNatRule(subject AzureFirewallNatRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallNatRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallNatRule instances for property testing - lazily instantiated by
// AzureFirewallNatRuleGenerator()
var azureFirewallNatRuleGenerator gopter.Gen

// AzureFirewallNatRuleGenerator returns a generator of AzureFirewallNatRule instances for property testing.
func AzureFirewallNatRuleGenerator() gopter.Gen {
	if azureFirewallNatRuleGenerator != nil {
		return azureFirewallNatRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallNatRule(generators)
	azureFirewallNatRuleGenerator = gen.Struct(reflect.TypeOf(AzureFirewallNatRule{}), generators)

	return azureFirewallNatRuleGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallNatRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallNatRule(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DestinationAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationPorts"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocols"] = gen.SliceOf(gen.OneConstOf(
		AzureFirewallNetworkRuleProtocol_Any,
		AzureFirewallNetworkRuleProtocol_ICMP,
		AzureFirewallNetworkRuleProtocol_TCP,
		AzureFirewallNetworkRuleProtocol_UDP))
	gens["SourceAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["SourceIpGroups"] = gen.SliceOf(gen.AlphaString())
	gens["TranslatedAddress"] = gen.PtrOf(gen.AlphaString())
	gens["TranslatedFqdn"] = gen.PtrOf(gen.AlphaString())
	gens["TranslatedPort"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureFirewallNatRuleCollection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallNatRuleCollection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallNatRuleCollection, AzureFirewallNatRuleCollectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallNatRuleCollection runs a test to see if a specific instance of AzureFirewallNatRuleCollection round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallNatRuleCollection(subject AzureFirewallNatRuleCollection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallNatRuleCollection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallNatRuleCollection instances for property testing - lazily instantiated by
// AzureFirewallNatRuleCollectionGenerator()
var azureFirewallNatRuleCollectionGenerator gopter.Gen

// AzureFirewallNatRuleCollectionGenerator returns a generator of AzureFirewallNatRuleCollection instances for property testing.
// We first initialize azureFirewallNatRuleCollectionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFirewallNatRuleCollectionGenerator() gopter.Gen {
	if azureFirewallNatRuleCollectionGenerator != nil {
		return azureFirewallNatRuleCollectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallNatRuleCollection(generators)
	azureFirewallNatRuleCollectionGenerator = gen.Struct(reflect.TypeOf(AzureFirewallNatRuleCollection{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallNatRuleCollection(generators)
	AddRelatedPropertyGeneratorsForAzureFirewallNatRuleCollection(generators)
	azureFirewallNatRuleCollectionGenerator = gen.Struct(reflect.TypeOf(AzureFirewallNatRuleCollection{}), generators)

	return azureFirewallNatRuleCollectionGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallNatRuleCollection is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallNatRuleCollection(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAzureFirewallNatRuleCollection is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFirewallNatRuleCollection(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(AzureFirewallNatRuleCollectionPropertiesGenerator())
}

func Test_AzureFirewallNatRuleCollectionProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallNatRuleCollectionProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallNatRuleCollectionProperties, AzureFirewallNatRuleCollectionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallNatRuleCollectionProperties runs a test to see if a specific instance of AzureFirewallNatRuleCollectionProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallNatRuleCollectionProperties(subject AzureFirewallNatRuleCollectionProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallNatRuleCollectionProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallNatRuleCollectionProperties instances for property testing - lazily instantiated by
// AzureFirewallNatRuleCollectionPropertiesGenerator()
var azureFirewallNatRuleCollectionPropertiesGenerator gopter.Gen

// AzureFirewallNatRuleCollectionPropertiesGenerator returns a generator of AzureFirewallNatRuleCollectionProperties instances for property testing.
// We first initialize azureFirewallNatRuleCollectionPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFirewallNatRuleCollectionPropertiesGenerator() gopter.Gen {
	if azureFirewallNatRuleCollectionPropertiesGenerator != nil {
		return azureFirewallNatRuleCollectionPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallNatRuleCollectionProperties(generators)
	azureFirewallNatRuleCollectionPropertiesGenerator = gen.Struct(reflect.TypeOf(AzureFirewallNatRuleCollectionProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallNatRuleCollectionProperties(generators)
	AddRelatedPropertyGeneratorsForAzureFirewallNatRuleCollectionProperties(generators)
	azureFirewallNatRuleCollectionPropertiesGenerator = gen.Struct(reflect.TypeOf(AzureFirewallNatRuleCollectionProperties{}), generators)

	return azureFirewallNatRuleCollectionPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallNatRuleCollectionProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallNatRuleCollectionProperties(gens map[string]gopter.Gen) {
	gens["Priority"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForAzureFirewallNatRuleCollectionProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFirewallNatRuleCollectionProperties(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(AzureFirewallNatRCActionGenerator())
	gens["Rules"] = gen.SliceOf(AzureFirewallNatRuleGenerator())
}

func Test_AzureFirewallNetworkRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallNetworkRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallNetworkRule, AzureFirewallNetworkRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallNetworkRule runs a test to see if a specific instance of AzureFirewallNetworkRule round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallNetworkRule(subject AzureFirewallNetworkRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallNetworkRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallNetworkRule instances for property testing - lazily instantiated by
// AzureFirewallNetworkRuleGenerator()
var azureFirewallNetworkRuleGenerator gopter.Gen

// AzureFirewallNetworkRuleGenerator returns a generator of AzureFirewallNetworkRule instances for property testing.
func AzureFirewallNetworkRuleGenerator() gopter.Gen {
	if azureFirewallNetworkRuleGenerator != nil {
		return azureFirewallNetworkRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallNetworkRule(generators)
	azureFirewallNetworkRuleGenerator = gen.Struct(reflect.TypeOf(AzureFirewallNetworkRule{}), generators)

	return azureFirewallNetworkRuleGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallNetworkRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallNetworkRule(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DestinationAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationFqdns"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationIpGroups"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationPorts"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocols"] = gen.SliceOf(gen.OneConstOf(
		AzureFirewallNetworkRuleProtocol_Any,
		AzureFirewallNetworkRuleProtocol_ICMP,
		AzureFirewallNetworkRuleProtocol_TCP,
		AzureFirewallNetworkRuleProtocol_UDP))
	gens["SourceAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["SourceIpGroups"] = gen.SliceOf(gen.AlphaString())
}

func Test_AzureFirewallNetworkRuleCollection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallNetworkRuleCollection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallNetworkRuleCollection, AzureFirewallNetworkRuleCollectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallNetworkRuleCollection runs a test to see if a specific instance of AzureFirewallNetworkRuleCollection round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallNetworkRuleCollection(subject AzureFirewallNetworkRuleCollection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallNetworkRuleCollection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallNetworkRuleCollection instances for property testing - lazily instantiated by
// AzureFirewallNetworkRuleCollectionGenerator()
var azureFirewallNetworkRuleCollectionGenerator gopter.Gen

// AzureFirewallNetworkRuleCollectionGenerator returns a generator of AzureFirewallNetworkRuleCollection instances for property testing.
// We first initialize azureFirewallNetworkRuleCollectionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFirewallNetworkRuleCollectionGenerator() gopter.Gen {
	if azureFirewallNetworkRuleCollectionGenerator != nil {
		return azureFirewallNetworkRuleCollectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallNetworkRuleCollection(generators)
	azureFirewallNetworkRuleCollectionGenerator = gen.Struct(reflect.TypeOf(AzureFirewallNetworkRuleCollection{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallNetworkRuleCollection(generators)
	AddRelatedPropertyGeneratorsForAzureFirewallNetworkRuleCollection(generators)
	azureFirewallNetworkRuleCollectionGenerator = gen.Struct(reflect.TypeOf(AzureFirewallNetworkRuleCollection{}), generators)

	return azureFirewallNetworkRuleCollectionGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallNetworkRuleCollection is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallNetworkRuleCollection(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAzureFirewallNetworkRuleCollection is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFirewallNetworkRuleCollection(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(AzureFirewallNetworkRuleCollectionPropertiesFormatGenerator())
}

func Test_AzureFirewallNetworkRuleCollectionPropertiesFormat_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallNetworkRuleCollectionPropertiesFormat via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallNetworkRuleCollectionPropertiesFormat, AzureFirewallNetworkRuleCollectionPropertiesFormatGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallNetworkRuleCollectionPropertiesFormat runs a test to see if a specific instance of AzureFirewallNetworkRuleCollectionPropertiesFormat round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallNetworkRuleCollectionPropertiesFormat(subject AzureFirewallNetworkRuleCollectionPropertiesFormat) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallNetworkRuleCollectionPropertiesFormat
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallNetworkRuleCollectionPropertiesFormat instances for property testing - lazily instantiated
// by AzureFirewallNetworkRuleCollectionPropertiesFormatGenerator()
var azureFirewallNetworkRuleCollectionPropertiesFormatGenerator gopter.Gen

// AzureFirewallNetworkRuleCollectionPropertiesFormatGenerator returns a generator of AzureFirewallNetworkRuleCollectionPropertiesFormat instances for property testing.
// We first initialize azureFirewallNetworkRuleCollectionPropertiesFormatGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFirewallNetworkRuleCollectionPropertiesFormatGenerator() gopter.Gen {
	if azureFirewallNetworkRuleCollectionPropertiesFormatGenerator != nil {
		return azureFirewallNetworkRuleCollectionPropertiesFormatGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallNetworkRuleCollectionPropertiesFormat(generators)
	azureFirewallNetworkRuleCollectionPropertiesFormatGenerator = gen.Struct(reflect.TypeOf(AzureFirewallNetworkRuleCollectionPropertiesFormat{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallNetworkRuleCollectionPropertiesFormat(generators)
	AddRelatedPropertyGeneratorsForAzureFirewallNetworkRuleCollectionPropertiesFormat(generators)
	azureFirewallNetworkRuleCollectionPropertiesFormatGenerator = gen.Struct(reflect.TypeOf(AzureFirewallNetworkRuleCollectionPropertiesFormat{}), generators)

	return azureFirewallNetworkRuleCollectionPropertiesFormatGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallNetworkRuleCollectionPropertiesFormat is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallNetworkRuleCollectionPropertiesFormat(gens map[string]gopter.Gen) {
	gens["Priority"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForAzureFirewallNetworkRuleCollectionPropertiesFormat is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFirewallNetworkRuleCollectionPropertiesFormat(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(AzureFirewallRCActionGenerator())
	gens["Rules"] = gen.SliceOf(AzureFirewallNetworkRuleGenerator())
}

func Test_AzureFirewallPropertiesFormat_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallPropertiesFormat via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallPropertiesFormat, AzureFirewallPropertiesFormatGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallPropertiesFormat runs a test to see if a specific instance of AzureFirewallPropertiesFormat round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallPropertiesFormat(subject AzureFirewallPropertiesFormat) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallPropertiesFormat
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallPropertiesFormat instances for property testing - lazily instantiated by
// AzureFirewallPropertiesFormatGenerator()
var azureFirewallPropertiesFormatGenerator gopter.Gen

// AzureFirewallPropertiesFormatGenerator returns a generator of AzureFirewallPropertiesFormat instances for property testing.
// We first initialize azureFirewallPropertiesFormatGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFirewallPropertiesFormatGenerator() gopter.Gen {
	if azureFirewallPropertiesFormatGenerator != nil {
		return azureFirewallPropertiesFormatGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallPropertiesFormat(generators)
	azureFirewallPropertiesFormatGenerator = gen.Struct(reflect.TypeOf(AzureFirewallPropertiesFormat{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallPropertiesFormat(generators)
	AddRelatedPropertyGeneratorsForAzureFirewallPropertiesFormat(generators)
	azureFirewallPropertiesFormatGenerator = gen.Struct(reflect.TypeOf(AzureFirewallPropertiesFormat{}), generators)

	return azureFirewallPropertiesFormatGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallPropertiesFormat is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallPropertiesFormat(gens map[string]gopter.Gen) {
	gens["AdditionalProperties"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["ThreatIntelMode"] = gen.PtrOf(gen.OneConstOf(AzureFirewallThreatIntelMode_Alert, AzureFirewallThreatIntelMode_Deny, AzureFirewallThreatIntelMode_Off))
}

// AddRelatedPropertyGeneratorsForAzureFirewallPropertiesFormat is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFirewallPropertiesFormat(gens map[string]gopter.Gen) {
	gens["ApplicationRuleCollections"] = gen.SliceOf(AzureFirewallApplicationRuleCollectionGenerator())
	gens["AutoscaleConfiguration"] = gen.PtrOf(AzureFirewallAutoscaleConfigurationGenerator())
	gens["FirewallPolicy"] = gen.PtrOf(SubResourceGenerator())
	gens["HubIPAddresses"] = gen.PtrOf(HubIPAddressesGenerator())
	gens["IpConfigurations"] = gen.SliceOf(AzureFirewallIPConfigurationGenerator())
	gens["ManagementIpConfiguration"] = gen.PtrOf(AzureFirewallIPConfigurationGenerator())
	gens["NatRuleCollections"] = gen.SliceOf(AzureFirewallNatRuleCollectionGenerator())
	gens["NetworkRuleCollections"] = gen.SliceOf(AzureFirewallNetworkRuleCollectionGenerator())
	gens["Sku"] = gen.PtrOf(AzureFirewallSkuGenerator())
	gens["VirtualHub"] = gen.PtrOf(SubResourceGenerator())
}

func Test_AzureFirewallPublicIPAddress_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallPublicIPAddress via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallPublicIPAddress, AzureFirewallPublicIPAddressGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallPublicIPAddress runs a test to see if a specific instance of AzureFirewallPublicIPAddress round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallPublicIPAddress(subject AzureFirewallPublicIPAddress) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallPublicIPAddress
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallPublicIPAddress instances for property testing - lazily instantiated by
// AzureFirewallPublicIPAddressGenerator()
var azureFirewallPublicIPAddressGenerator gopter.Gen

// AzureFirewallPublicIPAddressGenerator returns a generator of AzureFirewallPublicIPAddress instances for property testing.
func AzureFirewallPublicIPAddressGenerator() gopter.Gen {
	if azureFirewallPublicIPAddressGenerator != nil {
		return azureFirewallPublicIPAddressGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallPublicIPAddress(generators)
	azureFirewallPublicIPAddressGenerator = gen.Struct(reflect.TypeOf(AzureFirewallPublicIPAddress{}), generators)

	return azureFirewallPublicIPAddressGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallPublicIPAddress is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallPublicIPAddress(gens map[string]gopter.Gen) {
	gens["Address"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureFirewallRCAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallRCAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallRCAction, AzureFirewallRCActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallRCAction runs a test to see if a specific instance of AzureFirewallRCAction round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallRCAction(subject AzureFirewallRCAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallRCAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallRCAction instances for property testing - lazily instantiated by
// AzureFirewallRCActionGenerator()
var azureFirewallRCActionGenerator gopter.Gen

// AzureFirewallRCActionGenerator returns a generator of AzureFirewallRCAction instances for property testing.
func AzureFirewallRCActionGenerator() gopter.Gen {
	if azureFirewallRCActionGenerator != nil {
		return azureFirewallRCActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallRCAction(generators)
	azureFirewallRCActionGenerator = gen.Struct(reflect.TypeOf(AzureFirewallRCAction{}), generators)

	return azureFirewallRCActionGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallRCAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallRCAction(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(AzureFirewallRCActionType_Allow, AzureFirewallRCActionType_Deny))
}

func Test_AzureFirewallSku_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewallSku via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewallSku, AzureFirewallSkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewallSku runs a test to see if a specific instance of AzureFirewallSku round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewallSku(subject AzureFirewallSku) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewallSku
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewallSku instances for property testing - lazily instantiated by AzureFirewallSkuGenerator()
var azureFirewallSkuGenerator gopter.Gen

// AzureFirewallSkuGenerator returns a generator of AzureFirewallSku instances for property testing.
func AzureFirewallSkuGenerator() gopter.Gen {
	if azureFirewallSkuGenerator != nil {
		return azureFirewallSkuGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewallSku(generators)
	azureFirewallSkuGenerator = gen.Struct(reflect.TypeOf(AzureFirewallSku{}), generators)

	return azureFirewallSkuGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewallSku is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewallSku(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(AzureFirewallSku_Name_AZFW_Hub, AzureFirewallSku_Name_AZFW_VNet))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(AzureFirewallSku_Tier_Basic, AzureFirewallSku_Tier_Premium, AzureFirewallSku_Tier_Standard))
}

func Test_AzureFirewall_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirewall_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirewall_Spec, AzureFirewall_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirewall_Spec runs a test to see if a specific instance of AzureFirewall_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirewall_Spec(subject AzureFirewall_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirewall_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirewall_Spec instances for property testing - lazily instantiated by AzureFirewall_SpecGenerator()
var azureFirewall_SpecGenerator gopter.Gen

// AzureFirewall_SpecGenerator returns a generator of AzureFirewall_Spec instances for property testing.
// We first initialize azureFirewall_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFirewall_SpecGenerator() gopter.Gen {
	if azureFirewall_SpecGenerator != nil {
		return azureFirewall_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewall_Spec(generators)
	azureFirewall_SpecGenerator = gen.Struct(reflect.TypeOf(AzureFirewall_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirewall_Spec(generators)
	AddRelatedPropertyGeneratorsForAzureFirewall_Spec(generators)
	azureFirewall_SpecGenerator = gen.Struct(reflect.TypeOf(AzureFirewall_Spec{}), generators)

	return azureFirewall_SpecGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirewall_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirewall_Spec(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAzureFirewall_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFirewall_Spec(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(AzureFirewallPropertiesFormatGenerator())
}

func Test_HubIPAddresses_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HubIPAddresses via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHubIPAddresses, HubIPAddressesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHubIPAddresses runs a test to see if a specific instance of HubIPAddresses round trips to JSON and back losslessly
func RunJSONSerializationTestForHubIPAddresses(subject HubIPAddresses) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HubIPAddresses
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HubIPAddresses instances for property testing - lazily instantiated by HubIPAddressesGenerator()
var hubIPAddressesGenerator gopter.Gen

// HubIPAddressesGenerator returns a generator of HubIPAddresses instances for property testing.
// We first initialize hubIPAddressesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HubIPAddressesGenerator() gopter.Gen {
	if hubIPAddressesGenerator != nil {
		return hubIPAddressesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHubIPAddresses(generators)
	hubIPAddressesGenerator = gen.Struct(reflect.TypeOf(HubIPAddresses{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHubIPAddresses(generators)
	AddRelatedPropertyGeneratorsForHubIPAddresses(generators)
	hubIPAddressesGenerator = gen.Struct(reflect.TypeOf(HubIPAddresses{}), generators)

	return hubIPAddressesGenerator
}

// AddIndependentPropertyGeneratorsForHubIPAddresses is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHubIPAddresses(gens map[string]gopter.Gen) {
	gens["PrivateIPAddress"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForHubIPAddresses is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHubIPAddresses(gens map[string]gopter.Gen) {
	gens["PublicIPs"] = gen.PtrOf(HubPublicIPAddressesGenerator())
}

func Test_HubPublicIPAddresses_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HubPublicIPAddresses via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHubPublicIPAddresses, HubPublicIPAddressesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHubPublicIPAddresses runs a test to see if a specific instance of HubPublicIPAddresses round trips to JSON and back losslessly
func RunJSONSerializationTestForHubPublicIPAddresses(subject HubPublicIPAddresses) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HubPublicIPAddresses
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HubPublicIPAddresses instances for property testing - lazily instantiated by
// HubPublicIPAddressesGenerator()
var hubPublicIPAddressesGenerator gopter.Gen

// HubPublicIPAddressesGenerator returns a generator of HubPublicIPAddresses instances for property testing.
// We first initialize hubPublicIPAddressesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HubPublicIPAddressesGenerator() gopter.Gen {
	if hubPublicIPAddressesGenerator != nil {
		return hubPublicIPAddressesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHubPublicIPAddresses(generators)
	hubPublicIPAddressesGenerator = gen.Struct(reflect.TypeOf(HubPublicIPAddresses{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHubPublicIPAddresses(generators)
	AddRelatedPropertyGeneratorsForHubPublicIPAddresses(generators)
	hubPublicIPAddressesGenerator = gen.Struct(reflect.TypeOf(HubPublicIPAddresses{}), generators)

	return hubPublicIPAddressesGenerator
}

// AddIndependentPropertyGeneratorsForHubPublicIPAddresses is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHubPublicIPAddresses(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForHubPublicIPAddresses is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHubPublicIPAddresses(gens map[string]gopter.Gen) {
	gens["Addresses"] = gen.SliceOf(AzureFirewallPublicIPAddressGenerator())
}

func Test_SubResource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubResource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubResource, SubResourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubResource runs a test to see if a specific instance of SubResource round trips to JSON and back losslessly
func RunJSONSerializationTestForSubResource(subject SubResource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubResource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubResource instances for property testing - lazily instantiated by SubResourceGenerator()
var subResourceGenerator gopter.Gen

// SubResourceGenerator returns a generator of SubResource instances for property testing.
func SubResourceGenerator() gopter.Gen {
	if subResourceGenerator != nil {
		return subResourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubResource(generators)
	subResourceGenerator = gen.Struct(reflect.TypeOf(SubResource{}), generators)

	return subResourceGenerator
}

// AddIndependentPropertyGeneratorsForSubResource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubResource(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}
