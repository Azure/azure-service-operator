// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240301

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/network/v1api20240301/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/network/v1api20240301/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:resource:categories={azure,network}
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /network/resource-manager/Microsoft.Network/stable/2024-03-01/firewallPolicy.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}
type FirewallPolicy struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              FirewallPolicy_Spec   `json:"spec,omitempty"`
	Status            FirewallPolicy_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &FirewallPolicy{}

// GetConditions returns the conditions of the resource
func (policy *FirewallPolicy) GetConditions() conditions.Conditions {
	return policy.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (policy *FirewallPolicy) SetConditions(conditions conditions.Conditions) {
	policy.Status.Conditions = conditions
}

var _ conversion.Convertible = &FirewallPolicy{}

// ConvertFrom populates our FirewallPolicy from the provided hub FirewallPolicy
func (policy *FirewallPolicy) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.FirewallPolicy)
	if !ok {
		return fmt.Errorf("expected network/v1api20240301/storage/FirewallPolicy but received %T instead", hub)
	}

	return policy.AssignProperties_From_FirewallPolicy(source)
}

// ConvertTo populates the provided hub FirewallPolicy from our FirewallPolicy
func (policy *FirewallPolicy) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.FirewallPolicy)
	if !ok {
		return fmt.Errorf("expected network/v1api20240301/storage/FirewallPolicy but received %T instead", hub)
	}

	return policy.AssignProperties_To_FirewallPolicy(destination)
}

var _ configmaps.Exporter = &FirewallPolicy{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (policy *FirewallPolicy) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if policy.Spec.OperatorSpec == nil {
		return nil
	}
	return policy.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &FirewallPolicy{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (policy *FirewallPolicy) SecretDestinationExpressions() []*core.DestinationExpression {
	if policy.Spec.OperatorSpec == nil {
		return nil
	}
	return policy.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &FirewallPolicy{}

// InitializeSpec initializes the spec for this resource from the given status
func (policy *FirewallPolicy) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*FirewallPolicy_STATUS); ok {
		return policy.Spec.Initialize_From_FirewallPolicy_STATUS(s)
	}

	return fmt.Errorf("expected Status of type FirewallPolicy_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &FirewallPolicy{}

// AzureName returns the Azure name of the resource
func (policy *FirewallPolicy) AzureName() string {
	return policy.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2024-03-01"
func (policy FirewallPolicy) GetAPIVersion() string {
	return "2024-03-01"
}

// GetResourceScope returns the scope of the resource
func (policy *FirewallPolicy) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (policy *FirewallPolicy) GetSpec() genruntime.ConvertibleSpec {
	return &policy.Spec
}

// GetStatus returns the status of this resource
func (policy *FirewallPolicy) GetStatus() genruntime.ConvertibleStatus {
	return &policy.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (policy *FirewallPolicy) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Network/firewallPolicies"
func (policy *FirewallPolicy) GetType() string {
	return "Microsoft.Network/firewallPolicies"
}

// NewEmptyStatus returns a new empty (blank) status
func (policy *FirewallPolicy) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &FirewallPolicy_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (policy *FirewallPolicy) Owner() *genruntime.ResourceReference {
	if policy.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(policy.Spec)
	return policy.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (policy *FirewallPolicy) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*FirewallPolicy_STATUS); ok {
		policy.Status = *st
		return nil
	}

	// Convert status to required version
	var st FirewallPolicy_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	policy.Status = st
	return nil
}

// AssignProperties_From_FirewallPolicy populates our FirewallPolicy from the provided source FirewallPolicy
func (policy *FirewallPolicy) AssignProperties_From_FirewallPolicy(source *storage.FirewallPolicy) error {

	// ObjectMeta
	policy.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec FirewallPolicy_Spec
	err := spec.AssignProperties_From_FirewallPolicy_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_FirewallPolicy_Spec() to populate field Spec")
	}
	policy.Spec = spec

	// Status
	var status FirewallPolicy_STATUS
	err = status.AssignProperties_From_FirewallPolicy_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_FirewallPolicy_STATUS() to populate field Status")
	}
	policy.Status = status

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicy populates the provided destination FirewallPolicy from our FirewallPolicy
func (policy *FirewallPolicy) AssignProperties_To_FirewallPolicy(destination *storage.FirewallPolicy) error {

	// ObjectMeta
	destination.ObjectMeta = *policy.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.FirewallPolicy_Spec
	err := policy.Spec.AssignProperties_To_FirewallPolicy_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_FirewallPolicy_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.FirewallPolicy_STATUS
	err = policy.Status.AssignProperties_To_FirewallPolicy_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_FirewallPolicy_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (policy *FirewallPolicy) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: policy.Spec.OriginalVersion(),
		Kind:    "FirewallPolicy",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /network/resource-manager/Microsoft.Network/stable/2024-03-01/firewallPolicy.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}
type FirewallPolicyList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []FirewallPolicy `json:"items"`
}

type FirewallPolicy_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// BasePolicy: The parent firewall policy from which rules are inherited.
	BasePolicy *SubResource `json:"basePolicy,omitempty"`

	// DnsSettings: DNS Proxy Settings definition.
	DnsSettings *DnsSettings `json:"dnsSettings,omitempty"`

	// ExplicitProxy: Explicit Proxy Settings definition.
	ExplicitProxy *ExplicitProxy `json:"explicitProxy,omitempty"`

	// Identity: The identity of the firewall policy.
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`

	// Insights: Insights on Firewall Policy.
	Insights *FirewallPolicyInsights `json:"insights,omitempty"`

	// IntrusionDetection: The configuration for Intrusion detection.
	IntrusionDetection *FirewallPolicyIntrusionDetection `json:"intrusionDetection,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *FirewallPolicyOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// Sku: The Firewall Policy SKU.
	Sku *FirewallPolicySku `json:"sku,omitempty"`

	// Snat: The private IP addresses/IP ranges to which traffic will not be SNAT.
	Snat *FirewallPolicySNAT `json:"snat,omitempty"`

	// Sql: SQL Settings definition.
	Sql *FirewallPolicySQL `json:"sql,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// ThreatIntelMode: The operation mode for Threat Intelligence.
	ThreatIntelMode *AzureFirewallThreatIntelMode `json:"threatIntelMode,omitempty"`

	// ThreatIntelWhitelist: ThreatIntel Whitelist for Firewall Policy.
	ThreatIntelWhitelist *FirewallPolicyThreatIntelWhitelist `json:"threatIntelWhitelist,omitempty"`

	// TransportSecurity: TLS Configuration definition.
	TransportSecurity *FirewallPolicyTransportSecurity `json:"transportSecurity,omitempty"`
}

var _ genruntime.ARMTransformer = &FirewallPolicy_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *FirewallPolicy_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &arm.FirewallPolicy_Spec{}

	// Set property "Identity":
	if policy.Identity != nil {
		identity_ARM, err := (*policy.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.ManagedServiceIdentity)
		result.Identity = &identity
	}

	// Set property "Location":
	if policy.Location != nil {
		location := *policy.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if policy.BasePolicy != nil ||
		policy.DnsSettings != nil ||
		policy.ExplicitProxy != nil ||
		policy.Insights != nil ||
		policy.IntrusionDetection != nil ||
		policy.Sku != nil ||
		policy.Snat != nil ||
		policy.Sql != nil ||
		policy.ThreatIntelMode != nil ||
		policy.ThreatIntelWhitelist != nil ||
		policy.TransportSecurity != nil {
		result.Properties = &arm.FirewallPolicyPropertiesFormat{}
	}
	if policy.BasePolicy != nil {
		basePolicy_ARM, err := (*policy.BasePolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		basePolicy := *basePolicy_ARM.(*arm.SubResource)
		result.Properties.BasePolicy = &basePolicy
	}
	if policy.DnsSettings != nil {
		dnsSettings_ARM, err := (*policy.DnsSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dnsSettings := *dnsSettings_ARM.(*arm.DnsSettings)
		result.Properties.DnsSettings = &dnsSettings
	}
	if policy.ExplicitProxy != nil {
		explicitProxy_ARM, err := (*policy.ExplicitProxy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		explicitProxy := *explicitProxy_ARM.(*arm.ExplicitProxy)
		result.Properties.ExplicitProxy = &explicitProxy
	}
	if policy.Insights != nil {
		insights_ARM, err := (*policy.Insights).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		insights := *insights_ARM.(*arm.FirewallPolicyInsights)
		result.Properties.Insights = &insights
	}
	if policy.IntrusionDetection != nil {
		intrusionDetection_ARM, err := (*policy.IntrusionDetection).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		intrusionDetection := *intrusionDetection_ARM.(*arm.FirewallPolicyIntrusionDetection)
		result.Properties.IntrusionDetection = &intrusionDetection
	}
	if policy.Sku != nil {
		sku_ARM, err := (*policy.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *sku_ARM.(*arm.FirewallPolicySku)
		result.Properties.Sku = &sku
	}
	if policy.Snat != nil {
		snat_ARM, err := (*policy.Snat).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		snat := *snat_ARM.(*arm.FirewallPolicySNAT)
		result.Properties.Snat = &snat
	}
	if policy.Sql != nil {
		sql_ARM, err := (*policy.Sql).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sql := *sql_ARM.(*arm.FirewallPolicySQL)
		result.Properties.Sql = &sql
	}
	if policy.ThreatIntelMode != nil {
		var temp string
		temp = string(*policy.ThreatIntelMode)
		threatIntelMode := arm.AzureFirewallThreatIntelMode(temp)
		result.Properties.ThreatIntelMode = &threatIntelMode
	}
	if policy.ThreatIntelWhitelist != nil {
		threatIntelWhitelist_ARM, err := (*policy.ThreatIntelWhitelist).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		threatIntelWhitelist := *threatIntelWhitelist_ARM.(*arm.FirewallPolicyThreatIntelWhitelist)
		result.Properties.ThreatIntelWhitelist = &threatIntelWhitelist
	}
	if policy.TransportSecurity != nil {
		transportSecurity_ARM, err := (*policy.TransportSecurity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		transportSecurity := *transportSecurity_ARM.(*arm.FirewallPolicyTransportSecurity)
		result.Properties.TransportSecurity = &transportSecurity
	}

	// Set property "Tags":
	if policy.Tags != nil {
		result.Tags = make(map[string]string, len(policy.Tags))
		for key, value := range policy.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *FirewallPolicy_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FirewallPolicy_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *FirewallPolicy_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FirewallPolicy_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FirewallPolicy_Spec, got %T", armInput)
	}

	// Set property "AzureName":
	policy.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "BasePolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BasePolicy != nil {
			var basePolicy1 SubResource
			err := basePolicy1.PopulateFromARM(owner, *typedInput.Properties.BasePolicy)
			if err != nil {
				return err
			}
			basePolicy := basePolicy1
			policy.BasePolicy = &basePolicy
		}
	}

	// Set property "DnsSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
			var dnsSettings1 DnsSettings
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			policy.DnsSettings = &dnsSettings
		}
	}

	// Set property "ExplicitProxy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ExplicitProxy != nil {
			var explicitProxy1 ExplicitProxy
			err := explicitProxy1.PopulateFromARM(owner, *typedInput.Properties.ExplicitProxy)
			if err != nil {
				return err
			}
			explicitProxy := explicitProxy1
			policy.ExplicitProxy = &explicitProxy
		}
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		policy.Identity = &identity
	}

	// Set property "Insights":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Insights != nil {
			var insights1 FirewallPolicyInsights
			err := insights1.PopulateFromARM(owner, *typedInput.Properties.Insights)
			if err != nil {
				return err
			}
			insights := insights1
			policy.Insights = &insights
		}
	}

	// Set property "IntrusionDetection":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IntrusionDetection != nil {
			var intrusionDetection1 FirewallPolicyIntrusionDetection
			err := intrusionDetection1.PopulateFromARM(owner, *typedInput.Properties.IntrusionDetection)
			if err != nil {
				return err
			}
			intrusionDetection := intrusionDetection1
			policy.IntrusionDetection = &intrusionDetection
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		policy.Location = &location
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	policy.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Sku":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Sku != nil {
			var sku1 FirewallPolicySku
			err := sku1.PopulateFromARM(owner, *typedInput.Properties.Sku)
			if err != nil {
				return err
			}
			sku := sku1
			policy.Sku = &sku
		}
	}

	// Set property "Snat":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Snat != nil {
			var snat1 FirewallPolicySNAT
			err := snat1.PopulateFromARM(owner, *typedInput.Properties.Snat)
			if err != nil {
				return err
			}
			snat := snat1
			policy.Snat = &snat
		}
	}

	// Set property "Sql":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Sql != nil {
			var sql1 FirewallPolicySQL
			err := sql1.PopulateFromARM(owner, *typedInput.Properties.Sql)
			if err != nil {
				return err
			}
			sql := sql1
			policy.Sql = &sql
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		policy.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			policy.Tags[key] = value
		}
	}

	// Set property "ThreatIntelMode":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ThreatIntelMode != nil {
			var temp string
			temp = string(*typedInput.Properties.ThreatIntelMode)
			threatIntelMode := AzureFirewallThreatIntelMode(temp)
			policy.ThreatIntelMode = &threatIntelMode
		}
	}

	// Set property "ThreatIntelWhitelist":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ThreatIntelWhitelist != nil {
			var threatIntelWhitelist1 FirewallPolicyThreatIntelWhitelist
			err := threatIntelWhitelist1.PopulateFromARM(owner, *typedInput.Properties.ThreatIntelWhitelist)
			if err != nil {
				return err
			}
			threatIntelWhitelist := threatIntelWhitelist1
			policy.ThreatIntelWhitelist = &threatIntelWhitelist
		}
	}

	// Set property "TransportSecurity":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TransportSecurity != nil {
			var transportSecurity1 FirewallPolicyTransportSecurity
			err := transportSecurity1.PopulateFromARM(owner, *typedInput.Properties.TransportSecurity)
			if err != nil {
				return err
			}
			transportSecurity := transportSecurity1
			policy.TransportSecurity = &transportSecurity
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &FirewallPolicy_Spec{}

// ConvertSpecFrom populates our FirewallPolicy_Spec from the provided source
func (policy *FirewallPolicy_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.FirewallPolicy_Spec)
	if ok {
		// Populate our instance from source
		return policy.AssignProperties_From_FirewallPolicy_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.FirewallPolicy_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = policy.AssignProperties_From_FirewallPolicy_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our FirewallPolicy_Spec
func (policy *FirewallPolicy_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.FirewallPolicy_Spec)
	if ok {
		// Populate destination from our instance
		return policy.AssignProperties_To_FirewallPolicy_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.FirewallPolicy_Spec{}
	err := policy.AssignProperties_To_FirewallPolicy_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_FirewallPolicy_Spec populates our FirewallPolicy_Spec from the provided source FirewallPolicy_Spec
func (policy *FirewallPolicy_Spec) AssignProperties_From_FirewallPolicy_Spec(source *storage.FirewallPolicy_Spec) error {

	// AzureName
	policy.AzureName = source.AzureName

	// BasePolicy
	if source.BasePolicy != nil {
		var basePolicy SubResource
		err := basePolicy.AssignProperties_From_SubResource(source.BasePolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SubResource() to populate field BasePolicy")
		}
		policy.BasePolicy = &basePolicy
	} else {
		policy.BasePolicy = nil
	}

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting DnsSettings
		err := dnsSetting.AssignProperties_From_DnsSettings(source.DnsSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DnsSettings() to populate field DnsSettings")
		}
		policy.DnsSettings = &dnsSetting
	} else {
		policy.DnsSettings = nil
	}

	// ExplicitProxy
	if source.ExplicitProxy != nil {
		var explicitProxy ExplicitProxy
		err := explicitProxy.AssignProperties_From_ExplicitProxy(source.ExplicitProxy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ExplicitProxy() to populate field ExplicitProxy")
		}
		policy.ExplicitProxy = &explicitProxy
	} else {
		policy.ExplicitProxy = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.AssignProperties_From_ManagedServiceIdentity(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity() to populate field Identity")
		}
		policy.Identity = &identity
	} else {
		policy.Identity = nil
	}

	// Insights
	if source.Insights != nil {
		var insight FirewallPolicyInsights
		err := insight.AssignProperties_From_FirewallPolicyInsights(source.Insights)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_FirewallPolicyInsights() to populate field Insights")
		}
		policy.Insights = &insight
	} else {
		policy.Insights = nil
	}

	// IntrusionDetection
	if source.IntrusionDetection != nil {
		var intrusionDetection FirewallPolicyIntrusionDetection
		err := intrusionDetection.AssignProperties_From_FirewallPolicyIntrusionDetection(source.IntrusionDetection)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_FirewallPolicyIntrusionDetection() to populate field IntrusionDetection")
		}
		policy.IntrusionDetection = &intrusionDetection
	} else {
		policy.IntrusionDetection = nil
	}

	// Location
	policy.Location = genruntime.ClonePointerToString(source.Location)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec FirewallPolicyOperatorSpec
		err := operatorSpec.AssignProperties_From_FirewallPolicyOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_FirewallPolicyOperatorSpec() to populate field OperatorSpec")
		}
		policy.OperatorSpec = &operatorSpec
	} else {
		policy.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		policy.Owner = &owner
	} else {
		policy.Owner = nil
	}

	// Sku
	if source.Sku != nil {
		var sku FirewallPolicySku
		err := sku.AssignProperties_From_FirewallPolicySku(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_FirewallPolicySku() to populate field Sku")
		}
		policy.Sku = &sku
	} else {
		policy.Sku = nil
	}

	// Snat
	if source.Snat != nil {
		var snat FirewallPolicySNAT
		err := snat.AssignProperties_From_FirewallPolicySNAT(source.Snat)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_FirewallPolicySNAT() to populate field Snat")
		}
		policy.Snat = &snat
	} else {
		policy.Snat = nil
	}

	// Sql
	if source.Sql != nil {
		var sql FirewallPolicySQL
		err := sql.AssignProperties_From_FirewallPolicySQL(source.Sql)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_FirewallPolicySQL() to populate field Sql")
		}
		policy.Sql = &sql
	} else {
		policy.Sql = nil
	}

	// Tags
	policy.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// ThreatIntelMode
	if source.ThreatIntelMode != nil {
		threatIntelMode := *source.ThreatIntelMode
		threatIntelModeTemp := genruntime.ToEnum(threatIntelMode, azureFirewallThreatIntelMode_Values)
		policy.ThreatIntelMode = &threatIntelModeTemp
	} else {
		policy.ThreatIntelMode = nil
	}

	// ThreatIntelWhitelist
	if source.ThreatIntelWhitelist != nil {
		var threatIntelWhitelist FirewallPolicyThreatIntelWhitelist
		err := threatIntelWhitelist.AssignProperties_From_FirewallPolicyThreatIntelWhitelist(source.ThreatIntelWhitelist)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_FirewallPolicyThreatIntelWhitelist() to populate field ThreatIntelWhitelist")
		}
		policy.ThreatIntelWhitelist = &threatIntelWhitelist
	} else {
		policy.ThreatIntelWhitelist = nil
	}

	// TransportSecurity
	if source.TransportSecurity != nil {
		var transportSecurity FirewallPolicyTransportSecurity
		err := transportSecurity.AssignProperties_From_FirewallPolicyTransportSecurity(source.TransportSecurity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_FirewallPolicyTransportSecurity() to populate field TransportSecurity")
		}
		policy.TransportSecurity = &transportSecurity
	} else {
		policy.TransportSecurity = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicy_Spec populates the provided destination FirewallPolicy_Spec from our FirewallPolicy_Spec
func (policy *FirewallPolicy_Spec) AssignProperties_To_FirewallPolicy_Spec(destination *storage.FirewallPolicy_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = policy.AzureName

	// BasePolicy
	if policy.BasePolicy != nil {
		var basePolicy storage.SubResource
		err := policy.BasePolicy.AssignProperties_To_SubResource(&basePolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SubResource() to populate field BasePolicy")
		}
		destination.BasePolicy = &basePolicy
	} else {
		destination.BasePolicy = nil
	}

	// DnsSettings
	if policy.DnsSettings != nil {
		var dnsSetting storage.DnsSettings
		err := policy.DnsSettings.AssignProperties_To_DnsSettings(&dnsSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DnsSettings() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// ExplicitProxy
	if policy.ExplicitProxy != nil {
		var explicitProxy storage.ExplicitProxy
		err := policy.ExplicitProxy.AssignProperties_To_ExplicitProxy(&explicitProxy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ExplicitProxy() to populate field ExplicitProxy")
		}
		destination.ExplicitProxy = &explicitProxy
	} else {
		destination.ExplicitProxy = nil
	}

	// Identity
	if policy.Identity != nil {
		var identity storage.ManagedServiceIdentity
		err := policy.Identity.AssignProperties_To_ManagedServiceIdentity(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Insights
	if policy.Insights != nil {
		var insight storage.FirewallPolicyInsights
		err := policy.Insights.AssignProperties_To_FirewallPolicyInsights(&insight)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_FirewallPolicyInsights() to populate field Insights")
		}
		destination.Insights = &insight
	} else {
		destination.Insights = nil
	}

	// IntrusionDetection
	if policy.IntrusionDetection != nil {
		var intrusionDetection storage.FirewallPolicyIntrusionDetection
		err := policy.IntrusionDetection.AssignProperties_To_FirewallPolicyIntrusionDetection(&intrusionDetection)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_FirewallPolicyIntrusionDetection() to populate field IntrusionDetection")
		}
		destination.IntrusionDetection = &intrusionDetection
	} else {
		destination.IntrusionDetection = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(policy.Location)

	// OperatorSpec
	if policy.OperatorSpec != nil {
		var operatorSpec storage.FirewallPolicyOperatorSpec
		err := policy.OperatorSpec.AssignProperties_To_FirewallPolicyOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_FirewallPolicyOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = policy.OriginalVersion()

	// Owner
	if policy.Owner != nil {
		owner := policy.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Sku
	if policy.Sku != nil {
		var sku storage.FirewallPolicySku
		err := policy.Sku.AssignProperties_To_FirewallPolicySku(&sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_FirewallPolicySku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Snat
	if policy.Snat != nil {
		var snat storage.FirewallPolicySNAT
		err := policy.Snat.AssignProperties_To_FirewallPolicySNAT(&snat)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_FirewallPolicySNAT() to populate field Snat")
		}
		destination.Snat = &snat
	} else {
		destination.Snat = nil
	}

	// Sql
	if policy.Sql != nil {
		var sql storage.FirewallPolicySQL
		err := policy.Sql.AssignProperties_To_FirewallPolicySQL(&sql)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_FirewallPolicySQL() to populate field Sql")
		}
		destination.Sql = &sql
	} else {
		destination.Sql = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(policy.Tags)

	// ThreatIntelMode
	if policy.ThreatIntelMode != nil {
		threatIntelMode := string(*policy.ThreatIntelMode)
		destination.ThreatIntelMode = &threatIntelMode
	} else {
		destination.ThreatIntelMode = nil
	}

	// ThreatIntelWhitelist
	if policy.ThreatIntelWhitelist != nil {
		var threatIntelWhitelist storage.FirewallPolicyThreatIntelWhitelist
		err := policy.ThreatIntelWhitelist.AssignProperties_To_FirewallPolicyThreatIntelWhitelist(&threatIntelWhitelist)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_FirewallPolicyThreatIntelWhitelist() to populate field ThreatIntelWhitelist")
		}
		destination.ThreatIntelWhitelist = &threatIntelWhitelist
	} else {
		destination.ThreatIntelWhitelist = nil
	}

	// TransportSecurity
	if policy.TransportSecurity != nil {
		var transportSecurity storage.FirewallPolicyTransportSecurity
		err := policy.TransportSecurity.AssignProperties_To_FirewallPolicyTransportSecurity(&transportSecurity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_FirewallPolicyTransportSecurity() to populate field TransportSecurity")
		}
		destination.TransportSecurity = &transportSecurity
	} else {
		destination.TransportSecurity = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_FirewallPolicy_STATUS populates our FirewallPolicy_Spec from the provided source FirewallPolicy_STATUS
func (policy *FirewallPolicy_Spec) Initialize_From_FirewallPolicy_STATUS(source *FirewallPolicy_STATUS) error {

	// BasePolicy
	if source.BasePolicy != nil {
		var basePolicy SubResource
		err := basePolicy.Initialize_From_SubResource_STATUS(source.BasePolicy)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field BasePolicy")
		}
		policy.BasePolicy = &basePolicy
	} else {
		policy.BasePolicy = nil
	}

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting DnsSettings
		err := dnsSetting.Initialize_From_DnsSettings_STATUS(source.DnsSettings)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_DnsSettings_STATUS() to populate field DnsSettings")
		}
		policy.DnsSettings = &dnsSetting
	} else {
		policy.DnsSettings = nil
	}

	// ExplicitProxy
	if source.ExplicitProxy != nil {
		var explicitProxy ExplicitProxy
		err := explicitProxy.Initialize_From_ExplicitProxy_STATUS(source.ExplicitProxy)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ExplicitProxy_STATUS() to populate field ExplicitProxy")
		}
		policy.ExplicitProxy = &explicitProxy
	} else {
		policy.ExplicitProxy = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.Initialize_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		policy.Identity = &identity
	} else {
		policy.Identity = nil
	}

	// Insights
	if source.Insights != nil {
		var insight FirewallPolicyInsights
		err := insight.Initialize_From_FirewallPolicyInsights_STATUS(source.Insights)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_FirewallPolicyInsights_STATUS() to populate field Insights")
		}
		policy.Insights = &insight
	} else {
		policy.Insights = nil
	}

	// IntrusionDetection
	if source.IntrusionDetection != nil {
		var intrusionDetection FirewallPolicyIntrusionDetection
		err := intrusionDetection.Initialize_From_FirewallPolicyIntrusionDetection_STATUS(source.IntrusionDetection)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_FirewallPolicyIntrusionDetection_STATUS() to populate field IntrusionDetection")
		}
		policy.IntrusionDetection = &intrusionDetection
	} else {
		policy.IntrusionDetection = nil
	}

	// Location
	policy.Location = genruntime.ClonePointerToString(source.Location)

	// Sku
	if source.Sku != nil {
		var sku FirewallPolicySku
		err := sku.Initialize_From_FirewallPolicySku_STATUS(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_FirewallPolicySku_STATUS() to populate field Sku")
		}
		policy.Sku = &sku
	} else {
		policy.Sku = nil
	}

	// Snat
	if source.Snat != nil {
		var snat FirewallPolicySNAT
		err := snat.Initialize_From_FirewallPolicySNAT_STATUS(source.Snat)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_FirewallPolicySNAT_STATUS() to populate field Snat")
		}
		policy.Snat = &snat
	} else {
		policy.Snat = nil
	}

	// Sql
	if source.Sql != nil {
		var sql FirewallPolicySQL
		err := sql.Initialize_From_FirewallPolicySQL_STATUS(source.Sql)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_FirewallPolicySQL_STATUS() to populate field Sql")
		}
		policy.Sql = &sql
	} else {
		policy.Sql = nil
	}

	// Tags
	policy.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// ThreatIntelMode
	if source.ThreatIntelMode != nil {
		threatIntelMode := genruntime.ToEnum(string(*source.ThreatIntelMode), azureFirewallThreatIntelMode_Values)
		policy.ThreatIntelMode = &threatIntelMode
	} else {
		policy.ThreatIntelMode = nil
	}

	// ThreatIntelWhitelist
	if source.ThreatIntelWhitelist != nil {
		var threatIntelWhitelist FirewallPolicyThreatIntelWhitelist
		err := threatIntelWhitelist.Initialize_From_FirewallPolicyThreatIntelWhitelist_STATUS(source.ThreatIntelWhitelist)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_FirewallPolicyThreatIntelWhitelist_STATUS() to populate field ThreatIntelWhitelist")
		}
		policy.ThreatIntelWhitelist = &threatIntelWhitelist
	} else {
		policy.ThreatIntelWhitelist = nil
	}

	// TransportSecurity
	if source.TransportSecurity != nil {
		var transportSecurity FirewallPolicyTransportSecurity
		err := transportSecurity.Initialize_From_FirewallPolicyTransportSecurity_STATUS(source.TransportSecurity)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_FirewallPolicyTransportSecurity_STATUS() to populate field TransportSecurity")
		}
		policy.TransportSecurity = &transportSecurity
	} else {
		policy.TransportSecurity = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (policy *FirewallPolicy_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (policy *FirewallPolicy_Spec) SetAzureName(azureName string) { policy.AzureName = azureName }

// FirewallPolicy Resource.
type FirewallPolicy_STATUS struct {
	// BasePolicy: The parent firewall policy from which rules are inherited.
	BasePolicy *SubResource_STATUS `json:"basePolicy,omitempty"`

	// ChildPolicies: List of references to Child Firewall Policies.
	ChildPolicies []SubResource_STATUS `json:"childPolicies,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// DnsSettings: DNS Proxy Settings definition.
	DnsSettings *DnsSettings_STATUS `json:"dnsSettings,omitempty"`

	// Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	// ExplicitProxy: Explicit Proxy Settings definition.
	ExplicitProxy *ExplicitProxy_STATUS `json:"explicitProxy,omitempty"`

	// Firewalls: List of references to Azure Firewalls that this Firewall Policy is associated with.
	Firewalls []SubResource_STATUS `json:"firewalls,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// Identity: The identity of the firewall policy.
	Identity *ManagedServiceIdentity_STATUS `json:"identity,omitempty"`

	// Insights: Insights on Firewall Policy.
	Insights *FirewallPolicyInsights_STATUS `json:"insights,omitempty"`

	// IntrusionDetection: The configuration for Intrusion detection.
	IntrusionDetection *FirewallPolicyIntrusionDetection_STATUS `json:"intrusionDetection,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// Name: Resource name.
	Name *string `json:"name,omitempty"`

	// ProvisioningState: The provisioning state of the firewall policy resource.
	ProvisioningState *ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// RuleCollectionGroups: List of references to FirewallPolicyRuleCollectionGroups.
	RuleCollectionGroups []SubResource_STATUS `json:"ruleCollectionGroups,omitempty"`

	// Size: A read-only string that represents the size of the FirewallPolicyPropertiesFormat in MB. (ex 0.5MB)
	Size *string `json:"size,omitempty"`

	// Sku: The Firewall Policy SKU.
	Sku *FirewallPolicySku_STATUS `json:"sku,omitempty"`

	// Snat: The private IP addresses/IP ranges to which traffic will not be SNAT.
	Snat *FirewallPolicySNAT_STATUS `json:"snat,omitempty"`

	// Sql: SQL Settings definition.
	Sql *FirewallPolicySQL_STATUS `json:"sql,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// ThreatIntelMode: The operation mode for Threat Intelligence.
	ThreatIntelMode *AzureFirewallThreatIntelMode_STATUS `json:"threatIntelMode,omitempty"`

	// ThreatIntelWhitelist: ThreatIntel Whitelist for Firewall Policy.
	ThreatIntelWhitelist *FirewallPolicyThreatIntelWhitelist_STATUS `json:"threatIntelWhitelist,omitempty"`

	// TransportSecurity: TLS Configuration definition.
	TransportSecurity *FirewallPolicyTransportSecurity_STATUS `json:"transportSecurity,omitempty"`

	// Type: Resource type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &FirewallPolicy_STATUS{}

// ConvertStatusFrom populates our FirewallPolicy_STATUS from the provided source
func (policy *FirewallPolicy_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.FirewallPolicy_STATUS)
	if ok {
		// Populate our instance from source
		return policy.AssignProperties_From_FirewallPolicy_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.FirewallPolicy_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = policy.AssignProperties_From_FirewallPolicy_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our FirewallPolicy_STATUS
func (policy *FirewallPolicy_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.FirewallPolicy_STATUS)
	if ok {
		// Populate destination from our instance
		return policy.AssignProperties_To_FirewallPolicy_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.FirewallPolicy_STATUS{}
	err := policy.AssignProperties_To_FirewallPolicy_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &FirewallPolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *FirewallPolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FirewallPolicy_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *FirewallPolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FirewallPolicy_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FirewallPolicy_STATUS, got %T", armInput)
	}

	// Set property "BasePolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BasePolicy != nil {
			var basePolicy1 SubResource_STATUS
			err := basePolicy1.PopulateFromARM(owner, *typedInput.Properties.BasePolicy)
			if err != nil {
				return err
			}
			basePolicy := basePolicy1
			policy.BasePolicy = &basePolicy
		}
	}

	// Set property "ChildPolicies":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ChildPolicies {
			var item1 SubResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			policy.ChildPolicies = append(policy.ChildPolicies, item1)
		}
	}

	// no assignment for property "Conditions"

	// Set property "DnsSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
			var dnsSettings1 DnsSettings_STATUS
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			policy.DnsSettings = &dnsSettings
		}
	}

	// Set property "Etag":
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		policy.Etag = &etag
	}

	// Set property "ExplicitProxy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ExplicitProxy != nil {
			var explicitProxy1 ExplicitProxy_STATUS
			err := explicitProxy1.PopulateFromARM(owner, *typedInput.Properties.ExplicitProxy)
			if err != nil {
				return err
			}
			explicitProxy := explicitProxy1
			policy.ExplicitProxy = &explicitProxy
		}
	}

	// Set property "Firewalls":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Firewalls {
			var item1 SubResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			policy.Firewalls = append(policy.Firewalls, item1)
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		policy.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		policy.Identity = &identity
	}

	// Set property "Insights":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Insights != nil {
			var insights1 FirewallPolicyInsights_STATUS
			err := insights1.PopulateFromARM(owner, *typedInput.Properties.Insights)
			if err != nil {
				return err
			}
			insights := insights1
			policy.Insights = &insights
		}
	}

	// Set property "IntrusionDetection":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IntrusionDetection != nil {
			var intrusionDetection1 FirewallPolicyIntrusionDetection_STATUS
			err := intrusionDetection1.PopulateFromARM(owner, *typedInput.Properties.IntrusionDetection)
			if err != nil {
				return err
			}
			intrusionDetection := intrusionDetection1
			policy.IntrusionDetection = &intrusionDetection
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		policy.Location = &location
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		policy.Name = &name
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			var temp string
			temp = string(*typedInput.Properties.ProvisioningState)
			provisioningState := ProvisioningState_STATUS(temp)
			policy.ProvisioningState = &provisioningState
		}
	}

	// Set property "RuleCollectionGroups":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.RuleCollectionGroups {
			var item1 SubResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			policy.RuleCollectionGroups = append(policy.RuleCollectionGroups, item1)
		}
	}

	// Set property "Size":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Size != nil {
			size := *typedInput.Properties.Size
			policy.Size = &size
		}
	}

	// Set property "Sku":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Sku != nil {
			var sku1 FirewallPolicySku_STATUS
			err := sku1.PopulateFromARM(owner, *typedInput.Properties.Sku)
			if err != nil {
				return err
			}
			sku := sku1
			policy.Sku = &sku
		}
	}

	// Set property "Snat":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Snat != nil {
			var snat1 FirewallPolicySNAT_STATUS
			err := snat1.PopulateFromARM(owner, *typedInput.Properties.Snat)
			if err != nil {
				return err
			}
			snat := snat1
			policy.Snat = &snat
		}
	}

	// Set property "Sql":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Sql != nil {
			var sql1 FirewallPolicySQL_STATUS
			err := sql1.PopulateFromARM(owner, *typedInput.Properties.Sql)
			if err != nil {
				return err
			}
			sql := sql1
			policy.Sql = &sql
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		policy.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			policy.Tags[key] = value
		}
	}

	// Set property "ThreatIntelMode":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ThreatIntelMode != nil {
			var temp string
			temp = string(*typedInput.Properties.ThreatIntelMode)
			threatIntelMode := AzureFirewallThreatIntelMode_STATUS(temp)
			policy.ThreatIntelMode = &threatIntelMode
		}
	}

	// Set property "ThreatIntelWhitelist":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ThreatIntelWhitelist != nil {
			var threatIntelWhitelist1 FirewallPolicyThreatIntelWhitelist_STATUS
			err := threatIntelWhitelist1.PopulateFromARM(owner, *typedInput.Properties.ThreatIntelWhitelist)
			if err != nil {
				return err
			}
			threatIntelWhitelist := threatIntelWhitelist1
			policy.ThreatIntelWhitelist = &threatIntelWhitelist
		}
	}

	// Set property "TransportSecurity":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TransportSecurity != nil {
			var transportSecurity1 FirewallPolicyTransportSecurity_STATUS
			err := transportSecurity1.PopulateFromARM(owner, *typedInput.Properties.TransportSecurity)
			if err != nil {
				return err
			}
			transportSecurity := transportSecurity1
			policy.TransportSecurity = &transportSecurity
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		policy.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_FirewallPolicy_STATUS populates our FirewallPolicy_STATUS from the provided source FirewallPolicy_STATUS
func (policy *FirewallPolicy_STATUS) AssignProperties_From_FirewallPolicy_STATUS(source *storage.FirewallPolicy_STATUS) error {

	// BasePolicy
	if source.BasePolicy != nil {
		var basePolicy SubResource_STATUS
		err := basePolicy.AssignProperties_From_SubResource_STATUS(source.BasePolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field BasePolicy")
		}
		policy.BasePolicy = &basePolicy
	} else {
		policy.BasePolicy = nil
	}

	// ChildPolicies
	if source.ChildPolicies != nil {
		childPolicyList := make([]SubResource_STATUS, len(source.ChildPolicies))
		for childPolicyIndex, childPolicyItem := range source.ChildPolicies {
			// Shadow the loop variable to avoid aliasing
			childPolicyItem := childPolicyItem
			var childPolicy SubResource_STATUS
			err := childPolicy.AssignProperties_From_SubResource_STATUS(&childPolicyItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field ChildPolicies")
			}
			childPolicyList[childPolicyIndex] = childPolicy
		}
		policy.ChildPolicies = childPolicyList
	} else {
		policy.ChildPolicies = nil
	}

	// Conditions
	policy.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting DnsSettings_STATUS
		err := dnsSetting.AssignProperties_From_DnsSettings_STATUS(source.DnsSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DnsSettings_STATUS() to populate field DnsSettings")
		}
		policy.DnsSettings = &dnsSetting
	} else {
		policy.DnsSettings = nil
	}

	// Etag
	policy.Etag = genruntime.ClonePointerToString(source.Etag)

	// ExplicitProxy
	if source.ExplicitProxy != nil {
		var explicitProxy ExplicitProxy_STATUS
		err := explicitProxy.AssignProperties_From_ExplicitProxy_STATUS(source.ExplicitProxy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ExplicitProxy_STATUS() to populate field ExplicitProxy")
		}
		policy.ExplicitProxy = &explicitProxy
	} else {
		policy.ExplicitProxy = nil
	}

	// Firewalls
	if source.Firewalls != nil {
		firewallList := make([]SubResource_STATUS, len(source.Firewalls))
		for firewallIndex, firewallItem := range source.Firewalls {
			// Shadow the loop variable to avoid aliasing
			firewallItem := firewallItem
			var firewall SubResource_STATUS
			err := firewall.AssignProperties_From_SubResource_STATUS(&firewallItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field Firewalls")
			}
			firewallList[firewallIndex] = firewall
		}
		policy.Firewalls = firewallList
	} else {
		policy.Firewalls = nil
	}

	// Id
	policy.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity_STATUS
		err := identity.AssignProperties_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		policy.Identity = &identity
	} else {
		policy.Identity = nil
	}

	// Insights
	if source.Insights != nil {
		var insight FirewallPolicyInsights_STATUS
		err := insight.AssignProperties_From_FirewallPolicyInsights_STATUS(source.Insights)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_FirewallPolicyInsights_STATUS() to populate field Insights")
		}
		policy.Insights = &insight
	} else {
		policy.Insights = nil
	}

	// IntrusionDetection
	if source.IntrusionDetection != nil {
		var intrusionDetection FirewallPolicyIntrusionDetection_STATUS
		err := intrusionDetection.AssignProperties_From_FirewallPolicyIntrusionDetection_STATUS(source.IntrusionDetection)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_FirewallPolicyIntrusionDetection_STATUS() to populate field IntrusionDetection")
		}
		policy.IntrusionDetection = &intrusionDetection
	} else {
		policy.IntrusionDetection = nil
	}

	// Location
	policy.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	policy.Name = genruntime.ClonePointerToString(source.Name)

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, provisioningState_STATUS_Values)
		policy.ProvisioningState = &provisioningStateTemp
	} else {
		policy.ProvisioningState = nil
	}

	// RuleCollectionGroups
	if source.RuleCollectionGroups != nil {
		ruleCollectionGroupList := make([]SubResource_STATUS, len(source.RuleCollectionGroups))
		for ruleCollectionGroupIndex, ruleCollectionGroupItem := range source.RuleCollectionGroups {
			// Shadow the loop variable to avoid aliasing
			ruleCollectionGroupItem := ruleCollectionGroupItem
			var ruleCollectionGroup SubResource_STATUS
			err := ruleCollectionGroup.AssignProperties_From_SubResource_STATUS(&ruleCollectionGroupItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field RuleCollectionGroups")
			}
			ruleCollectionGroupList[ruleCollectionGroupIndex] = ruleCollectionGroup
		}
		policy.RuleCollectionGroups = ruleCollectionGroupList
	} else {
		policy.RuleCollectionGroups = nil
	}

	// Size
	policy.Size = genruntime.ClonePointerToString(source.Size)

	// Sku
	if source.Sku != nil {
		var sku FirewallPolicySku_STATUS
		err := sku.AssignProperties_From_FirewallPolicySku_STATUS(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_FirewallPolicySku_STATUS() to populate field Sku")
		}
		policy.Sku = &sku
	} else {
		policy.Sku = nil
	}

	// Snat
	if source.Snat != nil {
		var snat FirewallPolicySNAT_STATUS
		err := snat.AssignProperties_From_FirewallPolicySNAT_STATUS(source.Snat)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_FirewallPolicySNAT_STATUS() to populate field Snat")
		}
		policy.Snat = &snat
	} else {
		policy.Snat = nil
	}

	// Sql
	if source.Sql != nil {
		var sql FirewallPolicySQL_STATUS
		err := sql.AssignProperties_From_FirewallPolicySQL_STATUS(source.Sql)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_FirewallPolicySQL_STATUS() to populate field Sql")
		}
		policy.Sql = &sql
	} else {
		policy.Sql = nil
	}

	// Tags
	policy.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// ThreatIntelMode
	if source.ThreatIntelMode != nil {
		threatIntelMode := *source.ThreatIntelMode
		threatIntelModeTemp := genruntime.ToEnum(threatIntelMode, azureFirewallThreatIntelMode_STATUS_Values)
		policy.ThreatIntelMode = &threatIntelModeTemp
	} else {
		policy.ThreatIntelMode = nil
	}

	// ThreatIntelWhitelist
	if source.ThreatIntelWhitelist != nil {
		var threatIntelWhitelist FirewallPolicyThreatIntelWhitelist_STATUS
		err := threatIntelWhitelist.AssignProperties_From_FirewallPolicyThreatIntelWhitelist_STATUS(source.ThreatIntelWhitelist)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_FirewallPolicyThreatIntelWhitelist_STATUS() to populate field ThreatIntelWhitelist")
		}
		policy.ThreatIntelWhitelist = &threatIntelWhitelist
	} else {
		policy.ThreatIntelWhitelist = nil
	}

	// TransportSecurity
	if source.TransportSecurity != nil {
		var transportSecurity FirewallPolicyTransportSecurity_STATUS
		err := transportSecurity.AssignProperties_From_FirewallPolicyTransportSecurity_STATUS(source.TransportSecurity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_FirewallPolicyTransportSecurity_STATUS() to populate field TransportSecurity")
		}
		policy.TransportSecurity = &transportSecurity
	} else {
		policy.TransportSecurity = nil
	}

	// Type
	policy.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicy_STATUS populates the provided destination FirewallPolicy_STATUS from our FirewallPolicy_STATUS
func (policy *FirewallPolicy_STATUS) AssignProperties_To_FirewallPolicy_STATUS(destination *storage.FirewallPolicy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BasePolicy
	if policy.BasePolicy != nil {
		var basePolicy storage.SubResource_STATUS
		err := policy.BasePolicy.AssignProperties_To_SubResource_STATUS(&basePolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field BasePolicy")
		}
		destination.BasePolicy = &basePolicy
	} else {
		destination.BasePolicy = nil
	}

	// ChildPolicies
	if policy.ChildPolicies != nil {
		childPolicyList := make([]storage.SubResource_STATUS, len(policy.ChildPolicies))
		for childPolicyIndex, childPolicyItem := range policy.ChildPolicies {
			// Shadow the loop variable to avoid aliasing
			childPolicyItem := childPolicyItem
			var childPolicy storage.SubResource_STATUS
			err := childPolicyItem.AssignProperties_To_SubResource_STATUS(&childPolicy)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field ChildPolicies")
			}
			childPolicyList[childPolicyIndex] = childPolicy
		}
		destination.ChildPolicies = childPolicyList
	} else {
		destination.ChildPolicies = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(policy.Conditions)

	// DnsSettings
	if policy.DnsSettings != nil {
		var dnsSetting storage.DnsSettings_STATUS
		err := policy.DnsSettings.AssignProperties_To_DnsSettings_STATUS(&dnsSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DnsSettings_STATUS() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(policy.Etag)

	// ExplicitProxy
	if policy.ExplicitProxy != nil {
		var explicitProxy storage.ExplicitProxy_STATUS
		err := policy.ExplicitProxy.AssignProperties_To_ExplicitProxy_STATUS(&explicitProxy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ExplicitProxy_STATUS() to populate field ExplicitProxy")
		}
		destination.ExplicitProxy = &explicitProxy
	} else {
		destination.ExplicitProxy = nil
	}

	// Firewalls
	if policy.Firewalls != nil {
		firewallList := make([]storage.SubResource_STATUS, len(policy.Firewalls))
		for firewallIndex, firewallItem := range policy.Firewalls {
			// Shadow the loop variable to avoid aliasing
			firewallItem := firewallItem
			var firewall storage.SubResource_STATUS
			err := firewallItem.AssignProperties_To_SubResource_STATUS(&firewall)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field Firewalls")
			}
			firewallList[firewallIndex] = firewall
		}
		destination.Firewalls = firewallList
	} else {
		destination.Firewalls = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(policy.Id)

	// Identity
	if policy.Identity != nil {
		var identity storage.ManagedServiceIdentity_STATUS
		err := policy.Identity.AssignProperties_To_ManagedServiceIdentity_STATUS(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Insights
	if policy.Insights != nil {
		var insight storage.FirewallPolicyInsights_STATUS
		err := policy.Insights.AssignProperties_To_FirewallPolicyInsights_STATUS(&insight)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_FirewallPolicyInsights_STATUS() to populate field Insights")
		}
		destination.Insights = &insight
	} else {
		destination.Insights = nil
	}

	// IntrusionDetection
	if policy.IntrusionDetection != nil {
		var intrusionDetection storage.FirewallPolicyIntrusionDetection_STATUS
		err := policy.IntrusionDetection.AssignProperties_To_FirewallPolicyIntrusionDetection_STATUS(&intrusionDetection)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_FirewallPolicyIntrusionDetection_STATUS() to populate field IntrusionDetection")
		}
		destination.IntrusionDetection = &intrusionDetection
	} else {
		destination.IntrusionDetection = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(policy.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(policy.Name)

	// ProvisioningState
	if policy.ProvisioningState != nil {
		provisioningState := string(*policy.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// RuleCollectionGroups
	if policy.RuleCollectionGroups != nil {
		ruleCollectionGroupList := make([]storage.SubResource_STATUS, len(policy.RuleCollectionGroups))
		for ruleCollectionGroupIndex, ruleCollectionGroupItem := range policy.RuleCollectionGroups {
			// Shadow the loop variable to avoid aliasing
			ruleCollectionGroupItem := ruleCollectionGroupItem
			var ruleCollectionGroup storage.SubResource_STATUS
			err := ruleCollectionGroupItem.AssignProperties_To_SubResource_STATUS(&ruleCollectionGroup)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field RuleCollectionGroups")
			}
			ruleCollectionGroupList[ruleCollectionGroupIndex] = ruleCollectionGroup
		}
		destination.RuleCollectionGroups = ruleCollectionGroupList
	} else {
		destination.RuleCollectionGroups = nil
	}

	// Size
	destination.Size = genruntime.ClonePointerToString(policy.Size)

	// Sku
	if policy.Sku != nil {
		var sku storage.FirewallPolicySku_STATUS
		err := policy.Sku.AssignProperties_To_FirewallPolicySku_STATUS(&sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_FirewallPolicySku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Snat
	if policy.Snat != nil {
		var snat storage.FirewallPolicySNAT_STATUS
		err := policy.Snat.AssignProperties_To_FirewallPolicySNAT_STATUS(&snat)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_FirewallPolicySNAT_STATUS() to populate field Snat")
		}
		destination.Snat = &snat
	} else {
		destination.Snat = nil
	}

	// Sql
	if policy.Sql != nil {
		var sql storage.FirewallPolicySQL_STATUS
		err := policy.Sql.AssignProperties_To_FirewallPolicySQL_STATUS(&sql)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_FirewallPolicySQL_STATUS() to populate field Sql")
		}
		destination.Sql = &sql
	} else {
		destination.Sql = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(policy.Tags)

	// ThreatIntelMode
	if policy.ThreatIntelMode != nil {
		threatIntelMode := string(*policy.ThreatIntelMode)
		destination.ThreatIntelMode = &threatIntelMode
	} else {
		destination.ThreatIntelMode = nil
	}

	// ThreatIntelWhitelist
	if policy.ThreatIntelWhitelist != nil {
		var threatIntelWhitelist storage.FirewallPolicyThreatIntelWhitelist_STATUS
		err := policy.ThreatIntelWhitelist.AssignProperties_To_FirewallPolicyThreatIntelWhitelist_STATUS(&threatIntelWhitelist)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_FirewallPolicyThreatIntelWhitelist_STATUS() to populate field ThreatIntelWhitelist")
		}
		destination.ThreatIntelWhitelist = &threatIntelWhitelist
	} else {
		destination.ThreatIntelWhitelist = nil
	}

	// TransportSecurity
	if policy.TransportSecurity != nil {
		var transportSecurity storage.FirewallPolicyTransportSecurity_STATUS
		err := policy.TransportSecurity.AssignProperties_To_FirewallPolicyTransportSecurity_STATUS(&transportSecurity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_FirewallPolicyTransportSecurity_STATUS() to populate field TransportSecurity")
		}
		destination.TransportSecurity = &transportSecurity
	} else {
		destination.TransportSecurity = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(policy.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// DNS Proxy Settings in Firewall Policy.
type DnsSettings struct {
	// EnableProxy: Enable DNS Proxy on Firewalls attached to the Firewall Policy.
	EnableProxy *bool `json:"enableProxy,omitempty"`

	// RequireProxyForNetworkRules: FQDNs in Network Rules are supported when set to true.
	RequireProxyForNetworkRules *bool `json:"requireProxyForNetworkRules,omitempty"`

	// Servers: List of Custom DNS Servers.
	Servers []string `json:"servers,omitempty"`
}

var _ genruntime.ARMTransformer = &DnsSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *DnsSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.DnsSettings{}

	// Set property "EnableProxy":
	if settings.EnableProxy != nil {
		enableProxy := *settings.EnableProxy
		result.EnableProxy = &enableProxy
	}

	// Set property "RequireProxyForNetworkRules":
	if settings.RequireProxyForNetworkRules != nil {
		requireProxyForNetworkRules := *settings.RequireProxyForNetworkRules
		result.RequireProxyForNetworkRules = &requireProxyForNetworkRules
	}

	// Set property "Servers":
	for _, item := range settings.Servers {
		result.Servers = append(result.Servers, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *DnsSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DnsSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *DnsSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DnsSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DnsSettings, got %T", armInput)
	}

	// Set property "EnableProxy":
	if typedInput.EnableProxy != nil {
		enableProxy := *typedInput.EnableProxy
		settings.EnableProxy = &enableProxy
	}

	// Set property "RequireProxyForNetworkRules":
	if typedInput.RequireProxyForNetworkRules != nil {
		requireProxyForNetworkRules := *typedInput.RequireProxyForNetworkRules
		settings.RequireProxyForNetworkRules = &requireProxyForNetworkRules
	}

	// Set property "Servers":
	for _, item := range typedInput.Servers {
		settings.Servers = append(settings.Servers, item)
	}

	// No error
	return nil
}

// AssignProperties_From_DnsSettings populates our DnsSettings from the provided source DnsSettings
func (settings *DnsSettings) AssignProperties_From_DnsSettings(source *storage.DnsSettings) error {

	// EnableProxy
	if source.EnableProxy != nil {
		enableProxy := *source.EnableProxy
		settings.EnableProxy = &enableProxy
	} else {
		settings.EnableProxy = nil
	}

	// RequireProxyForNetworkRules
	if source.RequireProxyForNetworkRules != nil {
		requireProxyForNetworkRule := *source.RequireProxyForNetworkRules
		settings.RequireProxyForNetworkRules = &requireProxyForNetworkRule
	} else {
		settings.RequireProxyForNetworkRules = nil
	}

	// Servers
	settings.Servers = genruntime.CloneSliceOfString(source.Servers)

	// No error
	return nil
}

// AssignProperties_To_DnsSettings populates the provided destination DnsSettings from our DnsSettings
func (settings *DnsSettings) AssignProperties_To_DnsSettings(destination *storage.DnsSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EnableProxy
	if settings.EnableProxy != nil {
		enableProxy := *settings.EnableProxy
		destination.EnableProxy = &enableProxy
	} else {
		destination.EnableProxy = nil
	}

	// RequireProxyForNetworkRules
	if settings.RequireProxyForNetworkRules != nil {
		requireProxyForNetworkRule := *settings.RequireProxyForNetworkRules
		destination.RequireProxyForNetworkRules = &requireProxyForNetworkRule
	} else {
		destination.RequireProxyForNetworkRules = nil
	}

	// Servers
	destination.Servers = genruntime.CloneSliceOfString(settings.Servers)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DnsSettings_STATUS populates our DnsSettings from the provided source DnsSettings_STATUS
func (settings *DnsSettings) Initialize_From_DnsSettings_STATUS(source *DnsSettings_STATUS) error {

	// EnableProxy
	if source.EnableProxy != nil {
		enableProxy := *source.EnableProxy
		settings.EnableProxy = &enableProxy
	} else {
		settings.EnableProxy = nil
	}

	// RequireProxyForNetworkRules
	if source.RequireProxyForNetworkRules != nil {
		requireProxyForNetworkRule := *source.RequireProxyForNetworkRules
		settings.RequireProxyForNetworkRules = &requireProxyForNetworkRule
	} else {
		settings.RequireProxyForNetworkRules = nil
	}

	// Servers
	settings.Servers = genruntime.CloneSliceOfString(source.Servers)

	// No error
	return nil
}

// DNS Proxy Settings in Firewall Policy.
type DnsSettings_STATUS struct {
	// EnableProxy: Enable DNS Proxy on Firewalls attached to the Firewall Policy.
	EnableProxy *bool `json:"enableProxy,omitempty"`

	// RequireProxyForNetworkRules: FQDNs in Network Rules are supported when set to true.
	RequireProxyForNetworkRules *bool `json:"requireProxyForNetworkRules,omitempty"`

	// Servers: List of Custom DNS Servers.
	Servers []string `json:"servers,omitempty"`
}

var _ genruntime.FromARMConverter = &DnsSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *DnsSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DnsSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *DnsSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DnsSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DnsSettings_STATUS, got %T", armInput)
	}

	// Set property "EnableProxy":
	if typedInput.EnableProxy != nil {
		enableProxy := *typedInput.EnableProxy
		settings.EnableProxy = &enableProxy
	}

	// Set property "RequireProxyForNetworkRules":
	if typedInput.RequireProxyForNetworkRules != nil {
		requireProxyForNetworkRules := *typedInput.RequireProxyForNetworkRules
		settings.RequireProxyForNetworkRules = &requireProxyForNetworkRules
	}

	// Set property "Servers":
	for _, item := range typedInput.Servers {
		settings.Servers = append(settings.Servers, item)
	}

	// No error
	return nil
}

// AssignProperties_From_DnsSettings_STATUS populates our DnsSettings_STATUS from the provided source DnsSettings_STATUS
func (settings *DnsSettings_STATUS) AssignProperties_From_DnsSettings_STATUS(source *storage.DnsSettings_STATUS) error {

	// EnableProxy
	if source.EnableProxy != nil {
		enableProxy := *source.EnableProxy
		settings.EnableProxy = &enableProxy
	} else {
		settings.EnableProxy = nil
	}

	// RequireProxyForNetworkRules
	if source.RequireProxyForNetworkRules != nil {
		requireProxyForNetworkRule := *source.RequireProxyForNetworkRules
		settings.RequireProxyForNetworkRules = &requireProxyForNetworkRule
	} else {
		settings.RequireProxyForNetworkRules = nil
	}

	// Servers
	settings.Servers = genruntime.CloneSliceOfString(source.Servers)

	// No error
	return nil
}

// AssignProperties_To_DnsSettings_STATUS populates the provided destination DnsSettings_STATUS from our DnsSettings_STATUS
func (settings *DnsSettings_STATUS) AssignProperties_To_DnsSettings_STATUS(destination *storage.DnsSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EnableProxy
	if settings.EnableProxy != nil {
		enableProxy := *settings.EnableProxy
		destination.EnableProxy = &enableProxy
	} else {
		destination.EnableProxy = nil
	}

	// RequireProxyForNetworkRules
	if settings.RequireProxyForNetworkRules != nil {
		requireProxyForNetworkRule := *settings.RequireProxyForNetworkRules
		destination.RequireProxyForNetworkRules = &requireProxyForNetworkRule
	} else {
		destination.RequireProxyForNetworkRules = nil
	}

	// Servers
	destination.Servers = genruntime.CloneSliceOfString(settings.Servers)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Explicit Proxy Settings in Firewall Policy.
type ExplicitProxy struct {
	// EnableExplicitProxy: When set to true, explicit proxy mode is enabled.
	EnableExplicitProxy *bool `json:"enableExplicitProxy,omitempty"`

	// EnablePacFile: When set to true, pac file port and url needs to be provided.
	EnablePacFile *bool `json:"enablePacFile,omitempty"`

	// +kubebuilder:validation:Maximum=64000
	// +kubebuilder:validation:Minimum=0
	// HttpPort: Port number for explicit proxy http protocol, cannot be greater than 64000.
	HttpPort *int `json:"httpPort,omitempty"`

	// +kubebuilder:validation:Maximum=64000
	// +kubebuilder:validation:Minimum=0
	// HttpsPort: Port number for explicit proxy https protocol, cannot be greater than 64000.
	HttpsPort *int `json:"httpsPort,omitempty"`

	// PacFile: SAS URL for PAC file.
	PacFile *string `json:"pacFile,omitempty"`

	// +kubebuilder:validation:Maximum=64000
	// +kubebuilder:validation:Minimum=0
	// PacFilePort: Port number for firewall to serve PAC file.
	PacFilePort *int `json:"pacFilePort,omitempty"`
}

var _ genruntime.ARMTransformer = &ExplicitProxy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (proxy *ExplicitProxy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if proxy == nil {
		return nil, nil
	}
	result := &arm.ExplicitProxy{}

	// Set property "EnableExplicitProxy":
	if proxy.EnableExplicitProxy != nil {
		enableExplicitProxy := *proxy.EnableExplicitProxy
		result.EnableExplicitProxy = &enableExplicitProxy
	}

	// Set property "EnablePacFile":
	if proxy.EnablePacFile != nil {
		enablePacFile := *proxy.EnablePacFile
		result.EnablePacFile = &enablePacFile
	}

	// Set property "HttpPort":
	if proxy.HttpPort != nil {
		httpPort := *proxy.HttpPort
		result.HttpPort = &httpPort
	}

	// Set property "HttpsPort":
	if proxy.HttpsPort != nil {
		httpsPort := *proxy.HttpsPort
		result.HttpsPort = &httpsPort
	}

	// Set property "PacFile":
	if proxy.PacFile != nil {
		pacFile := *proxy.PacFile
		result.PacFile = &pacFile
	}

	// Set property "PacFilePort":
	if proxy.PacFilePort != nil {
		pacFilePort := *proxy.PacFilePort
		result.PacFilePort = &pacFilePort
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (proxy *ExplicitProxy) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ExplicitProxy{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (proxy *ExplicitProxy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ExplicitProxy)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ExplicitProxy, got %T", armInput)
	}

	// Set property "EnableExplicitProxy":
	if typedInput.EnableExplicitProxy != nil {
		enableExplicitProxy := *typedInput.EnableExplicitProxy
		proxy.EnableExplicitProxy = &enableExplicitProxy
	}

	// Set property "EnablePacFile":
	if typedInput.EnablePacFile != nil {
		enablePacFile := *typedInput.EnablePacFile
		proxy.EnablePacFile = &enablePacFile
	}

	// Set property "HttpPort":
	if typedInput.HttpPort != nil {
		httpPort := *typedInput.HttpPort
		proxy.HttpPort = &httpPort
	}

	// Set property "HttpsPort":
	if typedInput.HttpsPort != nil {
		httpsPort := *typedInput.HttpsPort
		proxy.HttpsPort = &httpsPort
	}

	// Set property "PacFile":
	if typedInput.PacFile != nil {
		pacFile := *typedInput.PacFile
		proxy.PacFile = &pacFile
	}

	// Set property "PacFilePort":
	if typedInput.PacFilePort != nil {
		pacFilePort := *typedInput.PacFilePort
		proxy.PacFilePort = &pacFilePort
	}

	// No error
	return nil
}

// AssignProperties_From_ExplicitProxy populates our ExplicitProxy from the provided source ExplicitProxy
func (proxy *ExplicitProxy) AssignProperties_From_ExplicitProxy(source *storage.ExplicitProxy) error {

	// EnableExplicitProxy
	if source.EnableExplicitProxy != nil {
		enableExplicitProxy := *source.EnableExplicitProxy
		proxy.EnableExplicitProxy = &enableExplicitProxy
	} else {
		proxy.EnableExplicitProxy = nil
	}

	// EnablePacFile
	if source.EnablePacFile != nil {
		enablePacFile := *source.EnablePacFile
		proxy.EnablePacFile = &enablePacFile
	} else {
		proxy.EnablePacFile = nil
	}

	// HttpPort
	proxy.HttpPort = genruntime.ClonePointerToInt(source.HttpPort)

	// HttpsPort
	proxy.HttpsPort = genruntime.ClonePointerToInt(source.HttpsPort)

	// PacFile
	proxy.PacFile = genruntime.ClonePointerToString(source.PacFile)

	// PacFilePort
	proxy.PacFilePort = genruntime.ClonePointerToInt(source.PacFilePort)

	// No error
	return nil
}

// AssignProperties_To_ExplicitProxy populates the provided destination ExplicitProxy from our ExplicitProxy
func (proxy *ExplicitProxy) AssignProperties_To_ExplicitProxy(destination *storage.ExplicitProxy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EnableExplicitProxy
	if proxy.EnableExplicitProxy != nil {
		enableExplicitProxy := *proxy.EnableExplicitProxy
		destination.EnableExplicitProxy = &enableExplicitProxy
	} else {
		destination.EnableExplicitProxy = nil
	}

	// EnablePacFile
	if proxy.EnablePacFile != nil {
		enablePacFile := *proxy.EnablePacFile
		destination.EnablePacFile = &enablePacFile
	} else {
		destination.EnablePacFile = nil
	}

	// HttpPort
	destination.HttpPort = genruntime.ClonePointerToInt(proxy.HttpPort)

	// HttpsPort
	destination.HttpsPort = genruntime.ClonePointerToInt(proxy.HttpsPort)

	// PacFile
	destination.PacFile = genruntime.ClonePointerToString(proxy.PacFile)

	// PacFilePort
	destination.PacFilePort = genruntime.ClonePointerToInt(proxy.PacFilePort)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ExplicitProxy_STATUS populates our ExplicitProxy from the provided source ExplicitProxy_STATUS
func (proxy *ExplicitProxy) Initialize_From_ExplicitProxy_STATUS(source *ExplicitProxy_STATUS) error {

	// EnableExplicitProxy
	if source.EnableExplicitProxy != nil {
		enableExplicitProxy := *source.EnableExplicitProxy
		proxy.EnableExplicitProxy = &enableExplicitProxy
	} else {
		proxy.EnableExplicitProxy = nil
	}

	// EnablePacFile
	if source.EnablePacFile != nil {
		enablePacFile := *source.EnablePacFile
		proxy.EnablePacFile = &enablePacFile
	} else {
		proxy.EnablePacFile = nil
	}

	// HttpPort
	proxy.HttpPort = genruntime.ClonePointerToInt(source.HttpPort)

	// HttpsPort
	proxy.HttpsPort = genruntime.ClonePointerToInt(source.HttpsPort)

	// PacFile
	proxy.PacFile = genruntime.ClonePointerToString(source.PacFile)

	// PacFilePort
	proxy.PacFilePort = genruntime.ClonePointerToInt(source.PacFilePort)

	// No error
	return nil
}

// Explicit Proxy Settings in Firewall Policy.
type ExplicitProxy_STATUS struct {
	// EnableExplicitProxy: When set to true, explicit proxy mode is enabled.
	EnableExplicitProxy *bool `json:"enableExplicitProxy,omitempty"`

	// EnablePacFile: When set to true, pac file port and url needs to be provided.
	EnablePacFile *bool `json:"enablePacFile,omitempty"`

	// HttpPort: Port number for explicit proxy http protocol, cannot be greater than 64000.
	HttpPort *int `json:"httpPort,omitempty"`

	// HttpsPort: Port number for explicit proxy https protocol, cannot be greater than 64000.
	HttpsPort *int `json:"httpsPort,omitempty"`

	// PacFile: SAS URL for PAC file.
	PacFile *string `json:"pacFile,omitempty"`

	// PacFilePort: Port number for firewall to serve PAC file.
	PacFilePort *int `json:"pacFilePort,omitempty"`
}

var _ genruntime.FromARMConverter = &ExplicitProxy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (proxy *ExplicitProxy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ExplicitProxy_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (proxy *ExplicitProxy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ExplicitProxy_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ExplicitProxy_STATUS, got %T", armInput)
	}

	// Set property "EnableExplicitProxy":
	if typedInput.EnableExplicitProxy != nil {
		enableExplicitProxy := *typedInput.EnableExplicitProxy
		proxy.EnableExplicitProxy = &enableExplicitProxy
	}

	// Set property "EnablePacFile":
	if typedInput.EnablePacFile != nil {
		enablePacFile := *typedInput.EnablePacFile
		proxy.EnablePacFile = &enablePacFile
	}

	// Set property "HttpPort":
	if typedInput.HttpPort != nil {
		httpPort := *typedInput.HttpPort
		proxy.HttpPort = &httpPort
	}

	// Set property "HttpsPort":
	if typedInput.HttpsPort != nil {
		httpsPort := *typedInput.HttpsPort
		proxy.HttpsPort = &httpsPort
	}

	// Set property "PacFile":
	if typedInput.PacFile != nil {
		pacFile := *typedInput.PacFile
		proxy.PacFile = &pacFile
	}

	// Set property "PacFilePort":
	if typedInput.PacFilePort != nil {
		pacFilePort := *typedInput.PacFilePort
		proxy.PacFilePort = &pacFilePort
	}

	// No error
	return nil
}

// AssignProperties_From_ExplicitProxy_STATUS populates our ExplicitProxy_STATUS from the provided source ExplicitProxy_STATUS
func (proxy *ExplicitProxy_STATUS) AssignProperties_From_ExplicitProxy_STATUS(source *storage.ExplicitProxy_STATUS) error {

	// EnableExplicitProxy
	if source.EnableExplicitProxy != nil {
		enableExplicitProxy := *source.EnableExplicitProxy
		proxy.EnableExplicitProxy = &enableExplicitProxy
	} else {
		proxy.EnableExplicitProxy = nil
	}

	// EnablePacFile
	if source.EnablePacFile != nil {
		enablePacFile := *source.EnablePacFile
		proxy.EnablePacFile = &enablePacFile
	} else {
		proxy.EnablePacFile = nil
	}

	// HttpPort
	proxy.HttpPort = genruntime.ClonePointerToInt(source.HttpPort)

	// HttpsPort
	proxy.HttpsPort = genruntime.ClonePointerToInt(source.HttpsPort)

	// PacFile
	proxy.PacFile = genruntime.ClonePointerToString(source.PacFile)

	// PacFilePort
	proxy.PacFilePort = genruntime.ClonePointerToInt(source.PacFilePort)

	// No error
	return nil
}

// AssignProperties_To_ExplicitProxy_STATUS populates the provided destination ExplicitProxy_STATUS from our ExplicitProxy_STATUS
func (proxy *ExplicitProxy_STATUS) AssignProperties_To_ExplicitProxy_STATUS(destination *storage.ExplicitProxy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EnableExplicitProxy
	if proxy.EnableExplicitProxy != nil {
		enableExplicitProxy := *proxy.EnableExplicitProxy
		destination.EnableExplicitProxy = &enableExplicitProxy
	} else {
		destination.EnableExplicitProxy = nil
	}

	// EnablePacFile
	if proxy.EnablePacFile != nil {
		enablePacFile := *proxy.EnablePacFile
		destination.EnablePacFile = &enablePacFile
	} else {
		destination.EnablePacFile = nil
	}

	// HttpPort
	destination.HttpPort = genruntime.ClonePointerToInt(proxy.HttpPort)

	// HttpsPort
	destination.HttpsPort = genruntime.ClonePointerToInt(proxy.HttpsPort)

	// PacFile
	destination.PacFile = genruntime.ClonePointerToString(proxy.PacFile)

	// PacFilePort
	destination.PacFilePort = genruntime.ClonePointerToInt(proxy.PacFilePort)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Firewall Policy Insights.
type FirewallPolicyInsights struct {
	// IsEnabled: A flag to indicate if the insights are enabled on the policy.
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// LogAnalyticsResources: Workspaces needed to configure the Firewall Policy Insights.
	LogAnalyticsResources *FirewallPolicyLogAnalyticsResources `json:"logAnalyticsResources,omitempty"`

	// RetentionDays: Number of days the insights should be enabled on the policy.
	RetentionDays *int `json:"retentionDays,omitempty"`
}

var _ genruntime.ARMTransformer = &FirewallPolicyInsights{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (insights *FirewallPolicyInsights) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if insights == nil {
		return nil, nil
	}
	result := &arm.FirewallPolicyInsights{}

	// Set property "IsEnabled":
	if insights.IsEnabled != nil {
		isEnabled := *insights.IsEnabled
		result.IsEnabled = &isEnabled
	}

	// Set property "LogAnalyticsResources":
	if insights.LogAnalyticsResources != nil {
		logAnalyticsResources_ARM, err := (*insights.LogAnalyticsResources).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		logAnalyticsResources := *logAnalyticsResources_ARM.(*arm.FirewallPolicyLogAnalyticsResources)
		result.LogAnalyticsResources = &logAnalyticsResources
	}

	// Set property "RetentionDays":
	if insights.RetentionDays != nil {
		retentionDays := *insights.RetentionDays
		result.RetentionDays = &retentionDays
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (insights *FirewallPolicyInsights) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FirewallPolicyInsights{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (insights *FirewallPolicyInsights) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FirewallPolicyInsights)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FirewallPolicyInsights, got %T", armInput)
	}

	// Set property "IsEnabled":
	if typedInput.IsEnabled != nil {
		isEnabled := *typedInput.IsEnabled
		insights.IsEnabled = &isEnabled
	}

	// Set property "LogAnalyticsResources":
	if typedInput.LogAnalyticsResources != nil {
		var logAnalyticsResources1 FirewallPolicyLogAnalyticsResources
		err := logAnalyticsResources1.PopulateFromARM(owner, *typedInput.LogAnalyticsResources)
		if err != nil {
			return err
		}
		logAnalyticsResources := logAnalyticsResources1
		insights.LogAnalyticsResources = &logAnalyticsResources
	}

	// Set property "RetentionDays":
	if typedInput.RetentionDays != nil {
		retentionDays := *typedInput.RetentionDays
		insights.RetentionDays = &retentionDays
	}

	// No error
	return nil
}

// AssignProperties_From_FirewallPolicyInsights populates our FirewallPolicyInsights from the provided source FirewallPolicyInsights
func (insights *FirewallPolicyInsights) AssignProperties_From_FirewallPolicyInsights(source *storage.FirewallPolicyInsights) error {

	// IsEnabled
	if source.IsEnabled != nil {
		isEnabled := *source.IsEnabled
		insights.IsEnabled = &isEnabled
	} else {
		insights.IsEnabled = nil
	}

	// LogAnalyticsResources
	if source.LogAnalyticsResources != nil {
		var logAnalyticsResource FirewallPolicyLogAnalyticsResources
		err := logAnalyticsResource.AssignProperties_From_FirewallPolicyLogAnalyticsResources(source.LogAnalyticsResources)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_FirewallPolicyLogAnalyticsResources() to populate field LogAnalyticsResources")
		}
		insights.LogAnalyticsResources = &logAnalyticsResource
	} else {
		insights.LogAnalyticsResources = nil
	}

	// RetentionDays
	insights.RetentionDays = genruntime.ClonePointerToInt(source.RetentionDays)

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicyInsights populates the provided destination FirewallPolicyInsights from our FirewallPolicyInsights
func (insights *FirewallPolicyInsights) AssignProperties_To_FirewallPolicyInsights(destination *storage.FirewallPolicyInsights) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IsEnabled
	if insights.IsEnabled != nil {
		isEnabled := *insights.IsEnabled
		destination.IsEnabled = &isEnabled
	} else {
		destination.IsEnabled = nil
	}

	// LogAnalyticsResources
	if insights.LogAnalyticsResources != nil {
		var logAnalyticsResource storage.FirewallPolicyLogAnalyticsResources
		err := insights.LogAnalyticsResources.AssignProperties_To_FirewallPolicyLogAnalyticsResources(&logAnalyticsResource)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_FirewallPolicyLogAnalyticsResources() to populate field LogAnalyticsResources")
		}
		destination.LogAnalyticsResources = &logAnalyticsResource
	} else {
		destination.LogAnalyticsResources = nil
	}

	// RetentionDays
	destination.RetentionDays = genruntime.ClonePointerToInt(insights.RetentionDays)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_FirewallPolicyInsights_STATUS populates our FirewallPolicyInsights from the provided source FirewallPolicyInsights_STATUS
func (insights *FirewallPolicyInsights) Initialize_From_FirewallPolicyInsights_STATUS(source *FirewallPolicyInsights_STATUS) error {

	// IsEnabled
	if source.IsEnabled != nil {
		isEnabled := *source.IsEnabled
		insights.IsEnabled = &isEnabled
	} else {
		insights.IsEnabled = nil
	}

	// LogAnalyticsResources
	if source.LogAnalyticsResources != nil {
		var logAnalyticsResource FirewallPolicyLogAnalyticsResources
		err := logAnalyticsResource.Initialize_From_FirewallPolicyLogAnalyticsResources_STATUS(source.LogAnalyticsResources)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_FirewallPolicyLogAnalyticsResources_STATUS() to populate field LogAnalyticsResources")
		}
		insights.LogAnalyticsResources = &logAnalyticsResource
	} else {
		insights.LogAnalyticsResources = nil
	}

	// RetentionDays
	insights.RetentionDays = genruntime.ClonePointerToInt(source.RetentionDays)

	// No error
	return nil
}

// Firewall Policy Insights.
type FirewallPolicyInsights_STATUS struct {
	// IsEnabled: A flag to indicate if the insights are enabled on the policy.
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// LogAnalyticsResources: Workspaces needed to configure the Firewall Policy Insights.
	LogAnalyticsResources *FirewallPolicyLogAnalyticsResources_STATUS `json:"logAnalyticsResources,omitempty"`

	// RetentionDays: Number of days the insights should be enabled on the policy.
	RetentionDays *int `json:"retentionDays,omitempty"`
}

var _ genruntime.FromARMConverter = &FirewallPolicyInsights_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (insights *FirewallPolicyInsights_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FirewallPolicyInsights_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (insights *FirewallPolicyInsights_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FirewallPolicyInsights_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FirewallPolicyInsights_STATUS, got %T", armInput)
	}

	// Set property "IsEnabled":
	if typedInput.IsEnabled != nil {
		isEnabled := *typedInput.IsEnabled
		insights.IsEnabled = &isEnabled
	}

	// Set property "LogAnalyticsResources":
	if typedInput.LogAnalyticsResources != nil {
		var logAnalyticsResources1 FirewallPolicyLogAnalyticsResources_STATUS
		err := logAnalyticsResources1.PopulateFromARM(owner, *typedInput.LogAnalyticsResources)
		if err != nil {
			return err
		}
		logAnalyticsResources := logAnalyticsResources1
		insights.LogAnalyticsResources = &logAnalyticsResources
	}

	// Set property "RetentionDays":
	if typedInput.RetentionDays != nil {
		retentionDays := *typedInput.RetentionDays
		insights.RetentionDays = &retentionDays
	}

	// No error
	return nil
}

// AssignProperties_From_FirewallPolicyInsights_STATUS populates our FirewallPolicyInsights_STATUS from the provided source FirewallPolicyInsights_STATUS
func (insights *FirewallPolicyInsights_STATUS) AssignProperties_From_FirewallPolicyInsights_STATUS(source *storage.FirewallPolicyInsights_STATUS) error {

	// IsEnabled
	if source.IsEnabled != nil {
		isEnabled := *source.IsEnabled
		insights.IsEnabled = &isEnabled
	} else {
		insights.IsEnabled = nil
	}

	// LogAnalyticsResources
	if source.LogAnalyticsResources != nil {
		var logAnalyticsResource FirewallPolicyLogAnalyticsResources_STATUS
		err := logAnalyticsResource.AssignProperties_From_FirewallPolicyLogAnalyticsResources_STATUS(source.LogAnalyticsResources)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_FirewallPolicyLogAnalyticsResources_STATUS() to populate field LogAnalyticsResources")
		}
		insights.LogAnalyticsResources = &logAnalyticsResource
	} else {
		insights.LogAnalyticsResources = nil
	}

	// RetentionDays
	insights.RetentionDays = genruntime.ClonePointerToInt(source.RetentionDays)

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicyInsights_STATUS populates the provided destination FirewallPolicyInsights_STATUS from our FirewallPolicyInsights_STATUS
func (insights *FirewallPolicyInsights_STATUS) AssignProperties_To_FirewallPolicyInsights_STATUS(destination *storage.FirewallPolicyInsights_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IsEnabled
	if insights.IsEnabled != nil {
		isEnabled := *insights.IsEnabled
		destination.IsEnabled = &isEnabled
	} else {
		destination.IsEnabled = nil
	}

	// LogAnalyticsResources
	if insights.LogAnalyticsResources != nil {
		var logAnalyticsResource storage.FirewallPolicyLogAnalyticsResources_STATUS
		err := insights.LogAnalyticsResources.AssignProperties_To_FirewallPolicyLogAnalyticsResources_STATUS(&logAnalyticsResource)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_FirewallPolicyLogAnalyticsResources_STATUS() to populate field LogAnalyticsResources")
		}
		destination.LogAnalyticsResources = &logAnalyticsResource
	} else {
		destination.LogAnalyticsResources = nil
	}

	// RetentionDays
	destination.RetentionDays = genruntime.ClonePointerToInt(insights.RetentionDays)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Configuration for intrusion detection mode and rules.
type FirewallPolicyIntrusionDetection struct {
	// Configuration: Intrusion detection configuration properties.
	Configuration *FirewallPolicyIntrusionDetectionConfiguration `json:"configuration,omitempty"`

	// Mode: Intrusion detection general state. When attached to a parent policy, the firewall's effective IDPS mode is the
	// stricter mode of the two.
	Mode *FirewallPolicyIntrusionDetectionStateOptions `json:"mode,omitempty"`

	// Profile: IDPS profile name. When attached to a parent policy, the firewall's effective profile is the profile name of
	// the parent policy.
	Profile *FirewallPolicyIntrusionDetectionProfileOptions `json:"profile,omitempty"`
}

var _ genruntime.ARMTransformer = &FirewallPolicyIntrusionDetection{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (detection *FirewallPolicyIntrusionDetection) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if detection == nil {
		return nil, nil
	}
	result := &arm.FirewallPolicyIntrusionDetection{}

	// Set property "Configuration":
	if detection.Configuration != nil {
		configuration_ARM, err := (*detection.Configuration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		configuration := *configuration_ARM.(*arm.FirewallPolicyIntrusionDetectionConfiguration)
		result.Configuration = &configuration
	}

	// Set property "Mode":
	if detection.Mode != nil {
		var temp string
		temp = string(*detection.Mode)
		mode := arm.FirewallPolicyIntrusionDetectionStateOptions(temp)
		result.Mode = &mode
	}

	// Set property "Profile":
	if detection.Profile != nil {
		var temp string
		temp = string(*detection.Profile)
		profile := arm.FirewallPolicyIntrusionDetectionProfileOptions(temp)
		result.Profile = &profile
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (detection *FirewallPolicyIntrusionDetection) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FirewallPolicyIntrusionDetection{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (detection *FirewallPolicyIntrusionDetection) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FirewallPolicyIntrusionDetection)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FirewallPolicyIntrusionDetection, got %T", armInput)
	}

	// Set property "Configuration":
	if typedInput.Configuration != nil {
		var configuration1 FirewallPolicyIntrusionDetectionConfiguration
		err := configuration1.PopulateFromARM(owner, *typedInput.Configuration)
		if err != nil {
			return err
		}
		configuration := configuration1
		detection.Configuration = &configuration
	}

	// Set property "Mode":
	if typedInput.Mode != nil {
		var temp string
		temp = string(*typedInput.Mode)
		mode := FirewallPolicyIntrusionDetectionStateOptions(temp)
		detection.Mode = &mode
	}

	// Set property "Profile":
	if typedInput.Profile != nil {
		var temp string
		temp = string(*typedInput.Profile)
		profile := FirewallPolicyIntrusionDetectionProfileOptions(temp)
		detection.Profile = &profile
	}

	// No error
	return nil
}

// AssignProperties_From_FirewallPolicyIntrusionDetection populates our FirewallPolicyIntrusionDetection from the provided source FirewallPolicyIntrusionDetection
func (detection *FirewallPolicyIntrusionDetection) AssignProperties_From_FirewallPolicyIntrusionDetection(source *storage.FirewallPolicyIntrusionDetection) error {

	// Configuration
	if source.Configuration != nil {
		var configuration FirewallPolicyIntrusionDetectionConfiguration
		err := configuration.AssignProperties_From_FirewallPolicyIntrusionDetectionConfiguration(source.Configuration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_FirewallPolicyIntrusionDetectionConfiguration() to populate field Configuration")
		}
		detection.Configuration = &configuration
	} else {
		detection.Configuration = nil
	}

	// Mode
	if source.Mode != nil {
		mode := *source.Mode
		modeTemp := genruntime.ToEnum(mode, firewallPolicyIntrusionDetectionStateOptions_Values)
		detection.Mode = &modeTemp
	} else {
		detection.Mode = nil
	}

	// Profile
	if source.Profile != nil {
		profile := *source.Profile
		profileTemp := genruntime.ToEnum(profile, firewallPolicyIntrusionDetectionProfileOptions_Values)
		detection.Profile = &profileTemp
	} else {
		detection.Profile = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicyIntrusionDetection populates the provided destination FirewallPolicyIntrusionDetection from our FirewallPolicyIntrusionDetection
func (detection *FirewallPolicyIntrusionDetection) AssignProperties_To_FirewallPolicyIntrusionDetection(destination *storage.FirewallPolicyIntrusionDetection) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Configuration
	if detection.Configuration != nil {
		var configuration storage.FirewallPolicyIntrusionDetectionConfiguration
		err := detection.Configuration.AssignProperties_To_FirewallPolicyIntrusionDetectionConfiguration(&configuration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_FirewallPolicyIntrusionDetectionConfiguration() to populate field Configuration")
		}
		destination.Configuration = &configuration
	} else {
		destination.Configuration = nil
	}

	// Mode
	if detection.Mode != nil {
		mode := string(*detection.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// Profile
	if detection.Profile != nil {
		profile := string(*detection.Profile)
		destination.Profile = &profile
	} else {
		destination.Profile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_FirewallPolicyIntrusionDetection_STATUS populates our FirewallPolicyIntrusionDetection from the provided source FirewallPolicyIntrusionDetection_STATUS
func (detection *FirewallPolicyIntrusionDetection) Initialize_From_FirewallPolicyIntrusionDetection_STATUS(source *FirewallPolicyIntrusionDetection_STATUS) error {

	// Configuration
	if source.Configuration != nil {
		var configuration FirewallPolicyIntrusionDetectionConfiguration
		err := configuration.Initialize_From_FirewallPolicyIntrusionDetectionConfiguration_STATUS(source.Configuration)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_FirewallPolicyIntrusionDetectionConfiguration_STATUS() to populate field Configuration")
		}
		detection.Configuration = &configuration
	} else {
		detection.Configuration = nil
	}

	// Mode
	if source.Mode != nil {
		mode := genruntime.ToEnum(string(*source.Mode), firewallPolicyIntrusionDetectionStateOptions_Values)
		detection.Mode = &mode
	} else {
		detection.Mode = nil
	}

	// Profile
	if source.Profile != nil {
		profile := genruntime.ToEnum(string(*source.Profile), firewallPolicyIntrusionDetectionProfileOptions_Values)
		detection.Profile = &profile
	} else {
		detection.Profile = nil
	}

	// No error
	return nil
}

// Configuration for intrusion detection mode and rules.
type FirewallPolicyIntrusionDetection_STATUS struct {
	// Configuration: Intrusion detection configuration properties.
	Configuration *FirewallPolicyIntrusionDetectionConfiguration_STATUS `json:"configuration,omitempty"`

	// Mode: Intrusion detection general state. When attached to a parent policy, the firewall's effective IDPS mode is the
	// stricter mode of the two.
	Mode *FirewallPolicyIntrusionDetectionStateOptions_STATUS `json:"mode,omitempty"`

	// Profile: IDPS profile name. When attached to a parent policy, the firewall's effective profile is the profile name of
	// the parent policy.
	Profile *FirewallPolicyIntrusionDetectionProfileOptions_STATUS `json:"profile,omitempty"`
}

var _ genruntime.FromARMConverter = &FirewallPolicyIntrusionDetection_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (detection *FirewallPolicyIntrusionDetection_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FirewallPolicyIntrusionDetection_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (detection *FirewallPolicyIntrusionDetection_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FirewallPolicyIntrusionDetection_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FirewallPolicyIntrusionDetection_STATUS, got %T", armInput)
	}

	// Set property "Configuration":
	if typedInput.Configuration != nil {
		var configuration1 FirewallPolicyIntrusionDetectionConfiguration_STATUS
		err := configuration1.PopulateFromARM(owner, *typedInput.Configuration)
		if err != nil {
			return err
		}
		configuration := configuration1
		detection.Configuration = &configuration
	}

	// Set property "Mode":
	if typedInput.Mode != nil {
		var temp string
		temp = string(*typedInput.Mode)
		mode := FirewallPolicyIntrusionDetectionStateOptions_STATUS(temp)
		detection.Mode = &mode
	}

	// Set property "Profile":
	if typedInput.Profile != nil {
		var temp string
		temp = string(*typedInput.Profile)
		profile := FirewallPolicyIntrusionDetectionProfileOptions_STATUS(temp)
		detection.Profile = &profile
	}

	// No error
	return nil
}

// AssignProperties_From_FirewallPolicyIntrusionDetection_STATUS populates our FirewallPolicyIntrusionDetection_STATUS from the provided source FirewallPolicyIntrusionDetection_STATUS
func (detection *FirewallPolicyIntrusionDetection_STATUS) AssignProperties_From_FirewallPolicyIntrusionDetection_STATUS(source *storage.FirewallPolicyIntrusionDetection_STATUS) error {

	// Configuration
	if source.Configuration != nil {
		var configuration FirewallPolicyIntrusionDetectionConfiguration_STATUS
		err := configuration.AssignProperties_From_FirewallPolicyIntrusionDetectionConfiguration_STATUS(source.Configuration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_FirewallPolicyIntrusionDetectionConfiguration_STATUS() to populate field Configuration")
		}
		detection.Configuration = &configuration
	} else {
		detection.Configuration = nil
	}

	// Mode
	if source.Mode != nil {
		mode := *source.Mode
		modeTemp := genruntime.ToEnum(mode, firewallPolicyIntrusionDetectionStateOptions_STATUS_Values)
		detection.Mode = &modeTemp
	} else {
		detection.Mode = nil
	}

	// Profile
	if source.Profile != nil {
		profile := *source.Profile
		profileTemp := genruntime.ToEnum(profile, firewallPolicyIntrusionDetectionProfileOptions_STATUS_Values)
		detection.Profile = &profileTemp
	} else {
		detection.Profile = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicyIntrusionDetection_STATUS populates the provided destination FirewallPolicyIntrusionDetection_STATUS from our FirewallPolicyIntrusionDetection_STATUS
func (detection *FirewallPolicyIntrusionDetection_STATUS) AssignProperties_To_FirewallPolicyIntrusionDetection_STATUS(destination *storage.FirewallPolicyIntrusionDetection_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Configuration
	if detection.Configuration != nil {
		var configuration storage.FirewallPolicyIntrusionDetectionConfiguration_STATUS
		err := detection.Configuration.AssignProperties_To_FirewallPolicyIntrusionDetectionConfiguration_STATUS(&configuration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_FirewallPolicyIntrusionDetectionConfiguration_STATUS() to populate field Configuration")
		}
		destination.Configuration = &configuration
	} else {
		destination.Configuration = nil
	}

	// Mode
	if detection.Mode != nil {
		mode := string(*detection.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// Profile
	if detection.Profile != nil {
		profile := string(*detection.Profile)
		destination.Profile = &profile
	} else {
		destination.Profile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type FirewallPolicyOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_FirewallPolicyOperatorSpec populates our FirewallPolicyOperatorSpec from the provided source FirewallPolicyOperatorSpec
func (operator *FirewallPolicyOperatorSpec) AssignProperties_From_FirewallPolicyOperatorSpec(source *storage.FirewallPolicyOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicyOperatorSpec populates the provided destination FirewallPolicyOperatorSpec from our FirewallPolicyOperatorSpec
func (operator *FirewallPolicyOperatorSpec) AssignProperties_To_FirewallPolicyOperatorSpec(destination *storage.FirewallPolicyOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// SKU of Firewall policy.
type FirewallPolicySku struct {
	// Tier: Tier of Firewall Policy.
	Tier *FirewallPolicySku_Tier `json:"tier,omitempty"`
}

var _ genruntime.ARMTransformer = &FirewallPolicySku{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policySku *FirewallPolicySku) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policySku == nil {
		return nil, nil
	}
	result := &arm.FirewallPolicySku{}

	// Set property "Tier":
	if policySku.Tier != nil {
		var temp string
		temp = string(*policySku.Tier)
		tier := arm.FirewallPolicySku_Tier(temp)
		result.Tier = &tier
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policySku *FirewallPolicySku) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FirewallPolicySku{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policySku *FirewallPolicySku) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FirewallPolicySku)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FirewallPolicySku, got %T", armInput)
	}

	// Set property "Tier":
	if typedInput.Tier != nil {
		var temp string
		temp = string(*typedInput.Tier)
		tier := FirewallPolicySku_Tier(temp)
		policySku.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_FirewallPolicySku populates our FirewallPolicySku from the provided source FirewallPolicySku
func (policySku *FirewallPolicySku) AssignProperties_From_FirewallPolicySku(source *storage.FirewallPolicySku) error {

	// Tier
	if source.Tier != nil {
		tier := *source.Tier
		tierTemp := genruntime.ToEnum(tier, firewallPolicySku_Tier_Values)
		policySku.Tier = &tierTemp
	} else {
		policySku.Tier = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicySku populates the provided destination FirewallPolicySku from our FirewallPolicySku
func (policySku *FirewallPolicySku) AssignProperties_To_FirewallPolicySku(destination *storage.FirewallPolicySku) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Tier
	if policySku.Tier != nil {
		tier := string(*policySku.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_FirewallPolicySku_STATUS populates our FirewallPolicySku from the provided source FirewallPolicySku_STATUS
func (policySku *FirewallPolicySku) Initialize_From_FirewallPolicySku_STATUS(source *FirewallPolicySku_STATUS) error {

	// Tier
	if source.Tier != nil {
		tier := genruntime.ToEnum(string(*source.Tier), firewallPolicySku_Tier_Values)
		policySku.Tier = &tier
	} else {
		policySku.Tier = nil
	}

	// No error
	return nil
}

// SKU of Firewall policy.
type FirewallPolicySku_STATUS struct {
	// Tier: Tier of Firewall Policy.
	Tier *FirewallPolicySku_Tier_STATUS `json:"tier,omitempty"`
}

var _ genruntime.FromARMConverter = &FirewallPolicySku_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policySku *FirewallPolicySku_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FirewallPolicySku_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policySku *FirewallPolicySku_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FirewallPolicySku_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FirewallPolicySku_STATUS, got %T", armInput)
	}

	// Set property "Tier":
	if typedInput.Tier != nil {
		var temp string
		temp = string(*typedInput.Tier)
		tier := FirewallPolicySku_Tier_STATUS(temp)
		policySku.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_FirewallPolicySku_STATUS populates our FirewallPolicySku_STATUS from the provided source FirewallPolicySku_STATUS
func (policySku *FirewallPolicySku_STATUS) AssignProperties_From_FirewallPolicySku_STATUS(source *storage.FirewallPolicySku_STATUS) error {

	// Tier
	if source.Tier != nil {
		tier := *source.Tier
		tierTemp := genruntime.ToEnum(tier, firewallPolicySku_Tier_STATUS_Values)
		policySku.Tier = &tierTemp
	} else {
		policySku.Tier = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicySku_STATUS populates the provided destination FirewallPolicySku_STATUS from our FirewallPolicySku_STATUS
func (policySku *FirewallPolicySku_STATUS) AssignProperties_To_FirewallPolicySku_STATUS(destination *storage.FirewallPolicySku_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Tier
	if policySku.Tier != nil {
		tier := string(*policySku.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The private IP addresses/IP ranges to which traffic will not be SNAT.
type FirewallPolicySNAT struct {
	// AutoLearnPrivateRanges: The operation mode for automatically learning private ranges to not be SNAT
	AutoLearnPrivateRanges *FirewallPolicySNAT_AutoLearnPrivateRanges `json:"autoLearnPrivateRanges,omitempty"`

	// PrivateRanges: List of private IP addresses/IP address ranges to not be SNAT.
	PrivateRanges []string `json:"privateRanges,omitempty"`
}

var _ genruntime.ARMTransformer = &FirewallPolicySNAT{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (snat *FirewallPolicySNAT) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if snat == nil {
		return nil, nil
	}
	result := &arm.FirewallPolicySNAT{}

	// Set property "AutoLearnPrivateRanges":
	if snat.AutoLearnPrivateRanges != nil {
		var temp string
		temp = string(*snat.AutoLearnPrivateRanges)
		autoLearnPrivateRanges := arm.FirewallPolicySNAT_AutoLearnPrivateRanges(temp)
		result.AutoLearnPrivateRanges = &autoLearnPrivateRanges
	}

	// Set property "PrivateRanges":
	for _, item := range snat.PrivateRanges {
		result.PrivateRanges = append(result.PrivateRanges, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (snat *FirewallPolicySNAT) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FirewallPolicySNAT{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (snat *FirewallPolicySNAT) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FirewallPolicySNAT)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FirewallPolicySNAT, got %T", armInput)
	}

	// Set property "AutoLearnPrivateRanges":
	if typedInput.AutoLearnPrivateRanges != nil {
		var temp string
		temp = string(*typedInput.AutoLearnPrivateRanges)
		autoLearnPrivateRanges := FirewallPolicySNAT_AutoLearnPrivateRanges(temp)
		snat.AutoLearnPrivateRanges = &autoLearnPrivateRanges
	}

	// Set property "PrivateRanges":
	for _, item := range typedInput.PrivateRanges {
		snat.PrivateRanges = append(snat.PrivateRanges, item)
	}

	// No error
	return nil
}

// AssignProperties_From_FirewallPolicySNAT populates our FirewallPolicySNAT from the provided source FirewallPolicySNAT
func (snat *FirewallPolicySNAT) AssignProperties_From_FirewallPolicySNAT(source *storage.FirewallPolicySNAT) error {

	// AutoLearnPrivateRanges
	if source.AutoLearnPrivateRanges != nil {
		autoLearnPrivateRange := *source.AutoLearnPrivateRanges
		autoLearnPrivateRangeTemp := genruntime.ToEnum(autoLearnPrivateRange, firewallPolicySNAT_AutoLearnPrivateRanges_Values)
		snat.AutoLearnPrivateRanges = &autoLearnPrivateRangeTemp
	} else {
		snat.AutoLearnPrivateRanges = nil
	}

	// PrivateRanges
	snat.PrivateRanges = genruntime.CloneSliceOfString(source.PrivateRanges)

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicySNAT populates the provided destination FirewallPolicySNAT from our FirewallPolicySNAT
func (snat *FirewallPolicySNAT) AssignProperties_To_FirewallPolicySNAT(destination *storage.FirewallPolicySNAT) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutoLearnPrivateRanges
	if snat.AutoLearnPrivateRanges != nil {
		autoLearnPrivateRange := string(*snat.AutoLearnPrivateRanges)
		destination.AutoLearnPrivateRanges = &autoLearnPrivateRange
	} else {
		destination.AutoLearnPrivateRanges = nil
	}

	// PrivateRanges
	destination.PrivateRanges = genruntime.CloneSliceOfString(snat.PrivateRanges)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_FirewallPolicySNAT_STATUS populates our FirewallPolicySNAT from the provided source FirewallPolicySNAT_STATUS
func (snat *FirewallPolicySNAT) Initialize_From_FirewallPolicySNAT_STATUS(source *FirewallPolicySNAT_STATUS) error {

	// AutoLearnPrivateRanges
	if source.AutoLearnPrivateRanges != nil {
		autoLearnPrivateRange := genruntime.ToEnum(string(*source.AutoLearnPrivateRanges), firewallPolicySNAT_AutoLearnPrivateRanges_Values)
		snat.AutoLearnPrivateRanges = &autoLearnPrivateRange
	} else {
		snat.AutoLearnPrivateRanges = nil
	}

	// PrivateRanges
	snat.PrivateRanges = genruntime.CloneSliceOfString(source.PrivateRanges)

	// No error
	return nil
}

// The private IP addresses/IP ranges to which traffic will not be SNAT.
type FirewallPolicySNAT_STATUS struct {
	// AutoLearnPrivateRanges: The operation mode for automatically learning private ranges to not be SNAT
	AutoLearnPrivateRanges *FirewallPolicySNAT_AutoLearnPrivateRanges_STATUS `json:"autoLearnPrivateRanges,omitempty"`

	// PrivateRanges: List of private IP addresses/IP address ranges to not be SNAT.
	PrivateRanges []string `json:"privateRanges,omitempty"`
}

var _ genruntime.FromARMConverter = &FirewallPolicySNAT_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (snat *FirewallPolicySNAT_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FirewallPolicySNAT_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (snat *FirewallPolicySNAT_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FirewallPolicySNAT_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FirewallPolicySNAT_STATUS, got %T", armInput)
	}

	// Set property "AutoLearnPrivateRanges":
	if typedInput.AutoLearnPrivateRanges != nil {
		var temp string
		temp = string(*typedInput.AutoLearnPrivateRanges)
		autoLearnPrivateRanges := FirewallPolicySNAT_AutoLearnPrivateRanges_STATUS(temp)
		snat.AutoLearnPrivateRanges = &autoLearnPrivateRanges
	}

	// Set property "PrivateRanges":
	for _, item := range typedInput.PrivateRanges {
		snat.PrivateRanges = append(snat.PrivateRanges, item)
	}

	// No error
	return nil
}

// AssignProperties_From_FirewallPolicySNAT_STATUS populates our FirewallPolicySNAT_STATUS from the provided source FirewallPolicySNAT_STATUS
func (snat *FirewallPolicySNAT_STATUS) AssignProperties_From_FirewallPolicySNAT_STATUS(source *storage.FirewallPolicySNAT_STATUS) error {

	// AutoLearnPrivateRanges
	if source.AutoLearnPrivateRanges != nil {
		autoLearnPrivateRange := *source.AutoLearnPrivateRanges
		autoLearnPrivateRangeTemp := genruntime.ToEnum(autoLearnPrivateRange, firewallPolicySNAT_AutoLearnPrivateRanges_STATUS_Values)
		snat.AutoLearnPrivateRanges = &autoLearnPrivateRangeTemp
	} else {
		snat.AutoLearnPrivateRanges = nil
	}

	// PrivateRanges
	snat.PrivateRanges = genruntime.CloneSliceOfString(source.PrivateRanges)

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicySNAT_STATUS populates the provided destination FirewallPolicySNAT_STATUS from our FirewallPolicySNAT_STATUS
func (snat *FirewallPolicySNAT_STATUS) AssignProperties_To_FirewallPolicySNAT_STATUS(destination *storage.FirewallPolicySNAT_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutoLearnPrivateRanges
	if snat.AutoLearnPrivateRanges != nil {
		autoLearnPrivateRange := string(*snat.AutoLearnPrivateRanges)
		destination.AutoLearnPrivateRanges = &autoLearnPrivateRange
	} else {
		destination.AutoLearnPrivateRanges = nil
	}

	// PrivateRanges
	destination.PrivateRanges = genruntime.CloneSliceOfString(snat.PrivateRanges)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// SQL Settings in Firewall Policy.
type FirewallPolicySQL struct {
	// AllowSqlRedirect: A flag to indicate if SQL Redirect traffic filtering is enabled. Turning on the flag requires no rule
	// using port 11000-11999.
	AllowSqlRedirect *bool `json:"allowSqlRedirect,omitempty"`
}

var _ genruntime.ARMTransformer = &FirewallPolicySQL{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policySQL *FirewallPolicySQL) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policySQL == nil {
		return nil, nil
	}
	result := &arm.FirewallPolicySQL{}

	// Set property "AllowSqlRedirect":
	if policySQL.AllowSqlRedirect != nil {
		allowSqlRedirect := *policySQL.AllowSqlRedirect
		result.AllowSqlRedirect = &allowSqlRedirect
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policySQL *FirewallPolicySQL) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FirewallPolicySQL{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policySQL *FirewallPolicySQL) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FirewallPolicySQL)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FirewallPolicySQL, got %T", armInput)
	}

	// Set property "AllowSqlRedirect":
	if typedInput.AllowSqlRedirect != nil {
		allowSqlRedirect := *typedInput.AllowSqlRedirect
		policySQL.AllowSqlRedirect = &allowSqlRedirect
	}

	// No error
	return nil
}

// AssignProperties_From_FirewallPolicySQL populates our FirewallPolicySQL from the provided source FirewallPolicySQL
func (policySQL *FirewallPolicySQL) AssignProperties_From_FirewallPolicySQL(source *storage.FirewallPolicySQL) error {

	// AllowSqlRedirect
	if source.AllowSqlRedirect != nil {
		allowSqlRedirect := *source.AllowSqlRedirect
		policySQL.AllowSqlRedirect = &allowSqlRedirect
	} else {
		policySQL.AllowSqlRedirect = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicySQL populates the provided destination FirewallPolicySQL from our FirewallPolicySQL
func (policySQL *FirewallPolicySQL) AssignProperties_To_FirewallPolicySQL(destination *storage.FirewallPolicySQL) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowSqlRedirect
	if policySQL.AllowSqlRedirect != nil {
		allowSqlRedirect := *policySQL.AllowSqlRedirect
		destination.AllowSqlRedirect = &allowSqlRedirect
	} else {
		destination.AllowSqlRedirect = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_FirewallPolicySQL_STATUS populates our FirewallPolicySQL from the provided source FirewallPolicySQL_STATUS
func (policySQL *FirewallPolicySQL) Initialize_From_FirewallPolicySQL_STATUS(source *FirewallPolicySQL_STATUS) error {

	// AllowSqlRedirect
	if source.AllowSqlRedirect != nil {
		allowSqlRedirect := *source.AllowSqlRedirect
		policySQL.AllowSqlRedirect = &allowSqlRedirect
	} else {
		policySQL.AllowSqlRedirect = nil
	}

	// No error
	return nil
}

// SQL Settings in Firewall Policy.
type FirewallPolicySQL_STATUS struct {
	// AllowSqlRedirect: A flag to indicate if SQL Redirect traffic filtering is enabled. Turning on the flag requires no rule
	// using port 11000-11999.
	AllowSqlRedirect *bool `json:"allowSqlRedirect,omitempty"`
}

var _ genruntime.FromARMConverter = &FirewallPolicySQL_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policySQL *FirewallPolicySQL_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FirewallPolicySQL_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policySQL *FirewallPolicySQL_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FirewallPolicySQL_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FirewallPolicySQL_STATUS, got %T", armInput)
	}

	// Set property "AllowSqlRedirect":
	if typedInput.AllowSqlRedirect != nil {
		allowSqlRedirect := *typedInput.AllowSqlRedirect
		policySQL.AllowSqlRedirect = &allowSqlRedirect
	}

	// No error
	return nil
}

// AssignProperties_From_FirewallPolicySQL_STATUS populates our FirewallPolicySQL_STATUS from the provided source FirewallPolicySQL_STATUS
func (policySQL *FirewallPolicySQL_STATUS) AssignProperties_From_FirewallPolicySQL_STATUS(source *storage.FirewallPolicySQL_STATUS) error {

	// AllowSqlRedirect
	if source.AllowSqlRedirect != nil {
		allowSqlRedirect := *source.AllowSqlRedirect
		policySQL.AllowSqlRedirect = &allowSqlRedirect
	} else {
		policySQL.AllowSqlRedirect = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicySQL_STATUS populates the provided destination FirewallPolicySQL_STATUS from our FirewallPolicySQL_STATUS
func (policySQL *FirewallPolicySQL_STATUS) AssignProperties_To_FirewallPolicySQL_STATUS(destination *storage.FirewallPolicySQL_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowSqlRedirect
	if policySQL.AllowSqlRedirect != nil {
		allowSqlRedirect := *policySQL.AllowSqlRedirect
		destination.AllowSqlRedirect = &allowSqlRedirect
	} else {
		destination.AllowSqlRedirect = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// ThreatIntel Whitelist for Firewall Policy.
type FirewallPolicyThreatIntelWhitelist struct {
	// Fqdns: List of FQDNs for the ThreatIntel Whitelist.
	Fqdns []string `json:"fqdns,omitempty"`

	// IpAddresses: List of IP addresses for the ThreatIntel Whitelist.
	IpAddresses []string `json:"ipAddresses,omitempty"`
}

var _ genruntime.ARMTransformer = &FirewallPolicyThreatIntelWhitelist{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (whitelist *FirewallPolicyThreatIntelWhitelist) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if whitelist == nil {
		return nil, nil
	}
	result := &arm.FirewallPolicyThreatIntelWhitelist{}

	// Set property "Fqdns":
	for _, item := range whitelist.Fqdns {
		result.Fqdns = append(result.Fqdns, item)
	}

	// Set property "IpAddresses":
	for _, item := range whitelist.IpAddresses {
		result.IpAddresses = append(result.IpAddresses, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (whitelist *FirewallPolicyThreatIntelWhitelist) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FirewallPolicyThreatIntelWhitelist{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (whitelist *FirewallPolicyThreatIntelWhitelist) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FirewallPolicyThreatIntelWhitelist)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FirewallPolicyThreatIntelWhitelist, got %T", armInput)
	}

	// Set property "Fqdns":
	for _, item := range typedInput.Fqdns {
		whitelist.Fqdns = append(whitelist.Fqdns, item)
	}

	// Set property "IpAddresses":
	for _, item := range typedInput.IpAddresses {
		whitelist.IpAddresses = append(whitelist.IpAddresses, item)
	}

	// No error
	return nil
}

// AssignProperties_From_FirewallPolicyThreatIntelWhitelist populates our FirewallPolicyThreatIntelWhitelist from the provided source FirewallPolicyThreatIntelWhitelist
func (whitelist *FirewallPolicyThreatIntelWhitelist) AssignProperties_From_FirewallPolicyThreatIntelWhitelist(source *storage.FirewallPolicyThreatIntelWhitelist) error {

	// Fqdns
	whitelist.Fqdns = genruntime.CloneSliceOfString(source.Fqdns)

	// IpAddresses
	whitelist.IpAddresses = genruntime.CloneSliceOfString(source.IpAddresses)

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicyThreatIntelWhitelist populates the provided destination FirewallPolicyThreatIntelWhitelist from our FirewallPolicyThreatIntelWhitelist
func (whitelist *FirewallPolicyThreatIntelWhitelist) AssignProperties_To_FirewallPolicyThreatIntelWhitelist(destination *storage.FirewallPolicyThreatIntelWhitelist) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Fqdns
	destination.Fqdns = genruntime.CloneSliceOfString(whitelist.Fqdns)

	// IpAddresses
	destination.IpAddresses = genruntime.CloneSliceOfString(whitelist.IpAddresses)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_FirewallPolicyThreatIntelWhitelist_STATUS populates our FirewallPolicyThreatIntelWhitelist from the provided source FirewallPolicyThreatIntelWhitelist_STATUS
func (whitelist *FirewallPolicyThreatIntelWhitelist) Initialize_From_FirewallPolicyThreatIntelWhitelist_STATUS(source *FirewallPolicyThreatIntelWhitelist_STATUS) error {

	// Fqdns
	whitelist.Fqdns = genruntime.CloneSliceOfString(source.Fqdns)

	// IpAddresses
	whitelist.IpAddresses = genruntime.CloneSliceOfString(source.IpAddresses)

	// No error
	return nil
}

// ThreatIntel Whitelist for Firewall Policy.
type FirewallPolicyThreatIntelWhitelist_STATUS struct {
	// Fqdns: List of FQDNs for the ThreatIntel Whitelist.
	Fqdns []string `json:"fqdns,omitempty"`

	// IpAddresses: List of IP addresses for the ThreatIntel Whitelist.
	IpAddresses []string `json:"ipAddresses,omitempty"`
}

var _ genruntime.FromARMConverter = &FirewallPolicyThreatIntelWhitelist_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (whitelist *FirewallPolicyThreatIntelWhitelist_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FirewallPolicyThreatIntelWhitelist_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (whitelist *FirewallPolicyThreatIntelWhitelist_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FirewallPolicyThreatIntelWhitelist_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FirewallPolicyThreatIntelWhitelist_STATUS, got %T", armInput)
	}

	// Set property "Fqdns":
	for _, item := range typedInput.Fqdns {
		whitelist.Fqdns = append(whitelist.Fqdns, item)
	}

	// Set property "IpAddresses":
	for _, item := range typedInput.IpAddresses {
		whitelist.IpAddresses = append(whitelist.IpAddresses, item)
	}

	// No error
	return nil
}

// AssignProperties_From_FirewallPolicyThreatIntelWhitelist_STATUS populates our FirewallPolicyThreatIntelWhitelist_STATUS from the provided source FirewallPolicyThreatIntelWhitelist_STATUS
func (whitelist *FirewallPolicyThreatIntelWhitelist_STATUS) AssignProperties_From_FirewallPolicyThreatIntelWhitelist_STATUS(source *storage.FirewallPolicyThreatIntelWhitelist_STATUS) error {

	// Fqdns
	whitelist.Fqdns = genruntime.CloneSliceOfString(source.Fqdns)

	// IpAddresses
	whitelist.IpAddresses = genruntime.CloneSliceOfString(source.IpAddresses)

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicyThreatIntelWhitelist_STATUS populates the provided destination FirewallPolicyThreatIntelWhitelist_STATUS from our FirewallPolicyThreatIntelWhitelist_STATUS
func (whitelist *FirewallPolicyThreatIntelWhitelist_STATUS) AssignProperties_To_FirewallPolicyThreatIntelWhitelist_STATUS(destination *storage.FirewallPolicyThreatIntelWhitelist_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Fqdns
	destination.Fqdns = genruntime.CloneSliceOfString(whitelist.Fqdns)

	// IpAddresses
	destination.IpAddresses = genruntime.CloneSliceOfString(whitelist.IpAddresses)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Configuration needed to perform TLS termination & initiation.
type FirewallPolicyTransportSecurity struct {
	// CertificateAuthority: The CA used for intermediate CA generation.
	CertificateAuthority *FirewallPolicyCertificateAuthority `json:"certificateAuthority,omitempty"`
}

var _ genruntime.ARMTransformer = &FirewallPolicyTransportSecurity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (security *FirewallPolicyTransportSecurity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if security == nil {
		return nil, nil
	}
	result := &arm.FirewallPolicyTransportSecurity{}

	// Set property "CertificateAuthority":
	if security.CertificateAuthority != nil {
		certificateAuthority_ARM, err := (*security.CertificateAuthority).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		certificateAuthority := *certificateAuthority_ARM.(*arm.FirewallPolicyCertificateAuthority)
		result.CertificateAuthority = &certificateAuthority
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (security *FirewallPolicyTransportSecurity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FirewallPolicyTransportSecurity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (security *FirewallPolicyTransportSecurity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FirewallPolicyTransportSecurity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FirewallPolicyTransportSecurity, got %T", armInput)
	}

	// Set property "CertificateAuthority":
	if typedInput.CertificateAuthority != nil {
		var certificateAuthority1 FirewallPolicyCertificateAuthority
		err := certificateAuthority1.PopulateFromARM(owner, *typedInput.CertificateAuthority)
		if err != nil {
			return err
		}
		certificateAuthority := certificateAuthority1
		security.CertificateAuthority = &certificateAuthority
	}

	// No error
	return nil
}

// AssignProperties_From_FirewallPolicyTransportSecurity populates our FirewallPolicyTransportSecurity from the provided source FirewallPolicyTransportSecurity
func (security *FirewallPolicyTransportSecurity) AssignProperties_From_FirewallPolicyTransportSecurity(source *storage.FirewallPolicyTransportSecurity) error {

	// CertificateAuthority
	if source.CertificateAuthority != nil {
		var certificateAuthority FirewallPolicyCertificateAuthority
		err := certificateAuthority.AssignProperties_From_FirewallPolicyCertificateAuthority(source.CertificateAuthority)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_FirewallPolicyCertificateAuthority() to populate field CertificateAuthority")
		}
		security.CertificateAuthority = &certificateAuthority
	} else {
		security.CertificateAuthority = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicyTransportSecurity populates the provided destination FirewallPolicyTransportSecurity from our FirewallPolicyTransportSecurity
func (security *FirewallPolicyTransportSecurity) AssignProperties_To_FirewallPolicyTransportSecurity(destination *storage.FirewallPolicyTransportSecurity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CertificateAuthority
	if security.CertificateAuthority != nil {
		var certificateAuthority storage.FirewallPolicyCertificateAuthority
		err := security.CertificateAuthority.AssignProperties_To_FirewallPolicyCertificateAuthority(&certificateAuthority)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_FirewallPolicyCertificateAuthority() to populate field CertificateAuthority")
		}
		destination.CertificateAuthority = &certificateAuthority
	} else {
		destination.CertificateAuthority = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_FirewallPolicyTransportSecurity_STATUS populates our FirewallPolicyTransportSecurity from the provided source FirewallPolicyTransportSecurity_STATUS
func (security *FirewallPolicyTransportSecurity) Initialize_From_FirewallPolicyTransportSecurity_STATUS(source *FirewallPolicyTransportSecurity_STATUS) error {

	// CertificateAuthority
	if source.CertificateAuthority != nil {
		var certificateAuthority FirewallPolicyCertificateAuthority
		err := certificateAuthority.Initialize_From_FirewallPolicyCertificateAuthority_STATUS(source.CertificateAuthority)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_FirewallPolicyCertificateAuthority_STATUS() to populate field CertificateAuthority")
		}
		security.CertificateAuthority = &certificateAuthority
	} else {
		security.CertificateAuthority = nil
	}

	// No error
	return nil
}

// Configuration needed to perform TLS termination & initiation.
type FirewallPolicyTransportSecurity_STATUS struct {
	// CertificateAuthority: The CA used for intermediate CA generation.
	CertificateAuthority *FirewallPolicyCertificateAuthority_STATUS `json:"certificateAuthority,omitempty"`
}

var _ genruntime.FromARMConverter = &FirewallPolicyTransportSecurity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (security *FirewallPolicyTransportSecurity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FirewallPolicyTransportSecurity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (security *FirewallPolicyTransportSecurity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FirewallPolicyTransportSecurity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FirewallPolicyTransportSecurity_STATUS, got %T", armInput)
	}

	// Set property "CertificateAuthority":
	if typedInput.CertificateAuthority != nil {
		var certificateAuthority1 FirewallPolicyCertificateAuthority_STATUS
		err := certificateAuthority1.PopulateFromARM(owner, *typedInput.CertificateAuthority)
		if err != nil {
			return err
		}
		certificateAuthority := certificateAuthority1
		security.CertificateAuthority = &certificateAuthority
	}

	// No error
	return nil
}

// AssignProperties_From_FirewallPolicyTransportSecurity_STATUS populates our FirewallPolicyTransportSecurity_STATUS from the provided source FirewallPolicyTransportSecurity_STATUS
func (security *FirewallPolicyTransportSecurity_STATUS) AssignProperties_From_FirewallPolicyTransportSecurity_STATUS(source *storage.FirewallPolicyTransportSecurity_STATUS) error {

	// CertificateAuthority
	if source.CertificateAuthority != nil {
		var certificateAuthority FirewallPolicyCertificateAuthority_STATUS
		err := certificateAuthority.AssignProperties_From_FirewallPolicyCertificateAuthority_STATUS(source.CertificateAuthority)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_FirewallPolicyCertificateAuthority_STATUS() to populate field CertificateAuthority")
		}
		security.CertificateAuthority = &certificateAuthority
	} else {
		security.CertificateAuthority = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicyTransportSecurity_STATUS populates the provided destination FirewallPolicyTransportSecurity_STATUS from our FirewallPolicyTransportSecurity_STATUS
func (security *FirewallPolicyTransportSecurity_STATUS) AssignProperties_To_FirewallPolicyTransportSecurity_STATUS(destination *storage.FirewallPolicyTransportSecurity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CertificateAuthority
	if security.CertificateAuthority != nil {
		var certificateAuthority storage.FirewallPolicyCertificateAuthority_STATUS
		err := security.CertificateAuthority.AssignProperties_To_FirewallPolicyCertificateAuthority_STATUS(&certificateAuthority)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_FirewallPolicyCertificateAuthority_STATUS() to populate field CertificateAuthority")
		}
		destination.CertificateAuthority = &certificateAuthority
	} else {
		destination.CertificateAuthority = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Identity for the resource.
type ManagedServiceIdentity struct {
	// Type: The type of identity used for the resource. The type 'SystemAssigned, UserAssigned' includes both an implicitly
	// created identity and a set of user assigned identities. The type 'None' will remove any identities from the virtual
	// machine.
	Type *ManagedServiceIdentity_Type `json:"type,omitempty"`

	// UserAssignedIdentities: The list of user identities associated with resource. The user identity dictionary key
	// references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities []UserAssignedIdentityDetails `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedServiceIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *ManagedServiceIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &arm.ManagedServiceIdentity{}

	// Set property "Type":
	if identity.Type != nil {
		var temp string
		temp = string(*identity.Type)
		typeVar := arm.ManagedServiceIdentity_Type(temp)
		result.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	result.UserAssignedIdentities = make(map[string]arm.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
	for _, ident := range identity.UserAssignedIdentities {
		identARMID, err := resolved.ResolvedReferences.Lookup(ident.Reference)
		if err != nil {
			return nil, err
		}
		key := identARMID
		result.UserAssignedIdentities[key] = arm.UserAssignedIdentityDetails{}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedServiceIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedServiceIdentity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedServiceIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedServiceIdentity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedServiceIdentity, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ManagedServiceIdentity_Type(temp)
		identity.Type = &typeVar
	}

	// no assignment for property "UserAssignedIdentities"

	// No error
	return nil
}

// AssignProperties_From_ManagedServiceIdentity populates our ManagedServiceIdentity from the provided source ManagedServiceIdentity
func (identity *ManagedServiceIdentity) AssignProperties_From_ManagedServiceIdentity(source *storage.ManagedServiceIdentity) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, managedServiceIdentity_Type_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity UserAssignedIdentityDetails
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentityDetails(&userAssignedIdentityItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedServiceIdentity populates the provided destination ManagedServiceIdentity from our ManagedServiceIdentity
func (identity *ManagedServiceIdentity) AssignProperties_To_ManagedServiceIdentity(destination *storage.ManagedServiceIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]storage.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity storage.UserAssignedIdentityDetails
			err := userAssignedIdentityItem.AssignProperties_To_UserAssignedIdentityDetails(&userAssignedIdentity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedServiceIdentity_STATUS populates our ManagedServiceIdentity from the provided source ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity) Initialize_From_ManagedServiceIdentity_STATUS(source *ManagedServiceIdentity_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), managedServiceIdentity_Type_Values)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, 0, len(source.UserAssignedIdentities))
		for userAssignedIdentitiesKey := range source.UserAssignedIdentities {
			userAssignedIdentitiesRef := genruntime.CreateResourceReferenceFromARMID(userAssignedIdentitiesKey)
			userAssignedIdentityList = append(userAssignedIdentityList, UserAssignedIdentityDetails{Reference: userAssignedIdentitiesRef})
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// Identity for the resource.
type ManagedServiceIdentity_STATUS struct {
	// PrincipalId: The principal id of the system assigned identity. This property will only be provided for a system assigned
	// identity.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: The tenant id of the system assigned identity. This property will only be provided for a system assigned
	// identity.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: The type of identity used for the resource. The type 'SystemAssigned, UserAssigned' includes both an implicitly
	// created identity and a set of user assigned identities. The type 'None' will remove any identities from the virtual
	// machine.
	Type *ManagedServiceIdentity_Type_STATUS `json:"type,omitempty"`

	// UserAssignedIdentities: The list of user identities associated with resource. The user identity dictionary key
	// references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]ManagedServiceIdentity_UserAssignedIdentities_STATUS `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedServiceIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedServiceIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedServiceIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedServiceIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedServiceIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedServiceIdentity_STATUS, got %T", armInput)
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ManagedServiceIdentity_Type_STATUS(temp)
		identity.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	if typedInput.UserAssignedIdentities != nil {
		identity.UserAssignedIdentities = make(map[string]ManagedServiceIdentity_UserAssignedIdentities_STATUS, len(typedInput.UserAssignedIdentities))
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 ManagedServiceIdentity_UserAssignedIdentities_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			identity.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedServiceIdentity_STATUS populates our ManagedServiceIdentity_STATUS from the provided source ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity_STATUS) AssignProperties_From_ManagedServiceIdentity_STATUS(source *storage.ManagedServiceIdentity_STATUS) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, managedServiceIdentity_Type_STATUS_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]ManagedServiceIdentity_UserAssignedIdentities_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity ManagedServiceIdentity_UserAssignedIdentities_STATUS
			err := userAssignedIdentity.AssignProperties_From_ManagedServiceIdentity_UserAssignedIdentities_STATUS(&userAssignedIdentityValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity_UserAssignedIdentities_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedServiceIdentity_STATUS populates the provided destination ManagedServiceIdentity_STATUS from our ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity_STATUS) AssignProperties_To_ManagedServiceIdentity_STATUS(destination *storage.ManagedServiceIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]storage.ManagedServiceIdentity_UserAssignedIdentities_STATUS, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity storage.ManagedServiceIdentity_UserAssignedIdentities_STATUS
			err := userAssignedIdentityValue.AssignProperties_To_ManagedServiceIdentity_UserAssignedIdentities_STATUS(&userAssignedIdentity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity_UserAssignedIdentities_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Trusted Root certificates properties for tls.
type FirewallPolicyCertificateAuthority struct {
	// KeyVaultSecretId: Secret Id of (base-64 encoded unencrypted pfx) 'Secret' or 'Certificate' object stored in KeyVault.
	KeyVaultSecretId *string `json:"keyVaultSecretId,omitempty"`

	// Name: Name of the CA certificate.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.ARMTransformer = &FirewallPolicyCertificateAuthority{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (authority *FirewallPolicyCertificateAuthority) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if authority == nil {
		return nil, nil
	}
	result := &arm.FirewallPolicyCertificateAuthority{}

	// Set property "KeyVaultSecretId":
	if authority.KeyVaultSecretId != nil {
		keyVaultSecretId := *authority.KeyVaultSecretId
		result.KeyVaultSecretId = &keyVaultSecretId
	}

	// Set property "Name":
	if authority.Name != nil {
		name := *authority.Name
		result.Name = &name
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (authority *FirewallPolicyCertificateAuthority) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FirewallPolicyCertificateAuthority{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (authority *FirewallPolicyCertificateAuthority) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FirewallPolicyCertificateAuthority)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FirewallPolicyCertificateAuthority, got %T", armInput)
	}

	// Set property "KeyVaultSecretId":
	if typedInput.KeyVaultSecretId != nil {
		keyVaultSecretId := *typedInput.KeyVaultSecretId
		authority.KeyVaultSecretId = &keyVaultSecretId
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		authority.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_FirewallPolicyCertificateAuthority populates our FirewallPolicyCertificateAuthority from the provided source FirewallPolicyCertificateAuthority
func (authority *FirewallPolicyCertificateAuthority) AssignProperties_From_FirewallPolicyCertificateAuthority(source *storage.FirewallPolicyCertificateAuthority) error {

	// KeyVaultSecretId
	authority.KeyVaultSecretId = genruntime.ClonePointerToString(source.KeyVaultSecretId)

	// Name
	authority.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicyCertificateAuthority populates the provided destination FirewallPolicyCertificateAuthority from our FirewallPolicyCertificateAuthority
func (authority *FirewallPolicyCertificateAuthority) AssignProperties_To_FirewallPolicyCertificateAuthority(destination *storage.FirewallPolicyCertificateAuthority) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyVaultSecretId
	destination.KeyVaultSecretId = genruntime.ClonePointerToString(authority.KeyVaultSecretId)

	// Name
	destination.Name = genruntime.ClonePointerToString(authority.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_FirewallPolicyCertificateAuthority_STATUS populates our FirewallPolicyCertificateAuthority from the provided source FirewallPolicyCertificateAuthority_STATUS
func (authority *FirewallPolicyCertificateAuthority) Initialize_From_FirewallPolicyCertificateAuthority_STATUS(source *FirewallPolicyCertificateAuthority_STATUS) error {

	// KeyVaultSecretId
	authority.KeyVaultSecretId = genruntime.ClonePointerToString(source.KeyVaultSecretId)

	// Name
	authority.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// Trusted Root certificates properties for tls.
type FirewallPolicyCertificateAuthority_STATUS struct {
	// KeyVaultSecretId: Secret Id of (base-64 encoded unencrypted pfx) 'Secret' or 'Certificate' object stored in KeyVault.
	KeyVaultSecretId *string `json:"keyVaultSecretId,omitempty"`

	// Name: Name of the CA certificate.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.FromARMConverter = &FirewallPolicyCertificateAuthority_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (authority *FirewallPolicyCertificateAuthority_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FirewallPolicyCertificateAuthority_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (authority *FirewallPolicyCertificateAuthority_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FirewallPolicyCertificateAuthority_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FirewallPolicyCertificateAuthority_STATUS, got %T", armInput)
	}

	// Set property "KeyVaultSecretId":
	if typedInput.KeyVaultSecretId != nil {
		keyVaultSecretId := *typedInput.KeyVaultSecretId
		authority.KeyVaultSecretId = &keyVaultSecretId
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		authority.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_FirewallPolicyCertificateAuthority_STATUS populates our FirewallPolicyCertificateAuthority_STATUS from the provided source FirewallPolicyCertificateAuthority_STATUS
func (authority *FirewallPolicyCertificateAuthority_STATUS) AssignProperties_From_FirewallPolicyCertificateAuthority_STATUS(source *storage.FirewallPolicyCertificateAuthority_STATUS) error {

	// KeyVaultSecretId
	authority.KeyVaultSecretId = genruntime.ClonePointerToString(source.KeyVaultSecretId)

	// Name
	authority.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicyCertificateAuthority_STATUS populates the provided destination FirewallPolicyCertificateAuthority_STATUS from our FirewallPolicyCertificateAuthority_STATUS
func (authority *FirewallPolicyCertificateAuthority_STATUS) AssignProperties_To_FirewallPolicyCertificateAuthority_STATUS(destination *storage.FirewallPolicyCertificateAuthority_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyVaultSecretId
	destination.KeyVaultSecretId = genruntime.ClonePointerToString(authority.KeyVaultSecretId)

	// Name
	destination.Name = genruntime.ClonePointerToString(authority.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The operation for configuring intrusion detection.
type FirewallPolicyIntrusionDetectionConfiguration struct {
	// BypassTrafficSettings: List of rules for traffic to bypass.
	BypassTrafficSettings []FirewallPolicyIntrusionDetectionBypassTrafficSpecifications `json:"bypassTrafficSettings,omitempty"`

	// PrivateRanges: IDPS Private IP address ranges are used to identify traffic direction (i.e. inbound, outbound, etc.). By
	// default, only ranges defined by IANA RFC 1918 are considered private IP addresses. To modify default ranges, specify
	// your Private IP address ranges with this property
	PrivateRanges []string `json:"privateRanges,omitempty"`

	// SignatureOverrides: List of specific signatures states.
	SignatureOverrides []FirewallPolicyIntrusionDetectionSignatureSpecification `json:"signatureOverrides,omitempty"`
}

var _ genruntime.ARMTransformer = &FirewallPolicyIntrusionDetectionConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *FirewallPolicyIntrusionDetectionConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.FirewallPolicyIntrusionDetectionConfiguration{}

	// Set property "BypassTrafficSettings":
	for _, item := range configuration.BypassTrafficSettings {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.BypassTrafficSettings = append(result.BypassTrafficSettings, *item_ARM.(*arm.FirewallPolicyIntrusionDetectionBypassTrafficSpecifications))
	}

	// Set property "PrivateRanges":
	for _, item := range configuration.PrivateRanges {
		result.PrivateRanges = append(result.PrivateRanges, item)
	}

	// Set property "SignatureOverrides":
	for _, item := range configuration.SignatureOverrides {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.SignatureOverrides = append(result.SignatureOverrides, *item_ARM.(*arm.FirewallPolicyIntrusionDetectionSignatureSpecification))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *FirewallPolicyIntrusionDetectionConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FirewallPolicyIntrusionDetectionConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *FirewallPolicyIntrusionDetectionConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FirewallPolicyIntrusionDetectionConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FirewallPolicyIntrusionDetectionConfiguration, got %T", armInput)
	}

	// Set property "BypassTrafficSettings":
	for _, item := range typedInput.BypassTrafficSettings {
		var item1 FirewallPolicyIntrusionDetectionBypassTrafficSpecifications
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.BypassTrafficSettings = append(configuration.BypassTrafficSettings, item1)
	}

	// Set property "PrivateRanges":
	for _, item := range typedInput.PrivateRanges {
		configuration.PrivateRanges = append(configuration.PrivateRanges, item)
	}

	// Set property "SignatureOverrides":
	for _, item := range typedInput.SignatureOverrides {
		var item1 FirewallPolicyIntrusionDetectionSignatureSpecification
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.SignatureOverrides = append(configuration.SignatureOverrides, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_FirewallPolicyIntrusionDetectionConfiguration populates our FirewallPolicyIntrusionDetectionConfiguration from the provided source FirewallPolicyIntrusionDetectionConfiguration
func (configuration *FirewallPolicyIntrusionDetectionConfiguration) AssignProperties_From_FirewallPolicyIntrusionDetectionConfiguration(source *storage.FirewallPolicyIntrusionDetectionConfiguration) error {

	// BypassTrafficSettings
	if source.BypassTrafficSettings != nil {
		bypassTrafficSettingList := make([]FirewallPolicyIntrusionDetectionBypassTrafficSpecifications, len(source.BypassTrafficSettings))
		for bypassTrafficSettingIndex, bypassTrafficSettingItem := range source.BypassTrafficSettings {
			// Shadow the loop variable to avoid aliasing
			bypassTrafficSettingItem := bypassTrafficSettingItem
			var bypassTrafficSetting FirewallPolicyIntrusionDetectionBypassTrafficSpecifications
			err := bypassTrafficSetting.AssignProperties_From_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications(&bypassTrafficSettingItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications() to populate field BypassTrafficSettings")
			}
			bypassTrafficSettingList[bypassTrafficSettingIndex] = bypassTrafficSetting
		}
		configuration.BypassTrafficSettings = bypassTrafficSettingList
	} else {
		configuration.BypassTrafficSettings = nil
	}

	// PrivateRanges
	configuration.PrivateRanges = genruntime.CloneSliceOfString(source.PrivateRanges)

	// SignatureOverrides
	if source.SignatureOverrides != nil {
		signatureOverrideList := make([]FirewallPolicyIntrusionDetectionSignatureSpecification, len(source.SignatureOverrides))
		for signatureOverrideIndex, signatureOverrideItem := range source.SignatureOverrides {
			// Shadow the loop variable to avoid aliasing
			signatureOverrideItem := signatureOverrideItem
			var signatureOverride FirewallPolicyIntrusionDetectionSignatureSpecification
			err := signatureOverride.AssignProperties_From_FirewallPolicyIntrusionDetectionSignatureSpecification(&signatureOverrideItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_FirewallPolicyIntrusionDetectionSignatureSpecification() to populate field SignatureOverrides")
			}
			signatureOverrideList[signatureOverrideIndex] = signatureOverride
		}
		configuration.SignatureOverrides = signatureOverrideList
	} else {
		configuration.SignatureOverrides = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicyIntrusionDetectionConfiguration populates the provided destination FirewallPolicyIntrusionDetectionConfiguration from our FirewallPolicyIntrusionDetectionConfiguration
func (configuration *FirewallPolicyIntrusionDetectionConfiguration) AssignProperties_To_FirewallPolicyIntrusionDetectionConfiguration(destination *storage.FirewallPolicyIntrusionDetectionConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BypassTrafficSettings
	if configuration.BypassTrafficSettings != nil {
		bypassTrafficSettingList := make([]storage.FirewallPolicyIntrusionDetectionBypassTrafficSpecifications, len(configuration.BypassTrafficSettings))
		for bypassTrafficSettingIndex, bypassTrafficSettingItem := range configuration.BypassTrafficSettings {
			// Shadow the loop variable to avoid aliasing
			bypassTrafficSettingItem := bypassTrafficSettingItem
			var bypassTrafficSetting storage.FirewallPolicyIntrusionDetectionBypassTrafficSpecifications
			err := bypassTrafficSettingItem.AssignProperties_To_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications(&bypassTrafficSetting)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications() to populate field BypassTrafficSettings")
			}
			bypassTrafficSettingList[bypassTrafficSettingIndex] = bypassTrafficSetting
		}
		destination.BypassTrafficSettings = bypassTrafficSettingList
	} else {
		destination.BypassTrafficSettings = nil
	}

	// PrivateRanges
	destination.PrivateRanges = genruntime.CloneSliceOfString(configuration.PrivateRanges)

	// SignatureOverrides
	if configuration.SignatureOverrides != nil {
		signatureOverrideList := make([]storage.FirewallPolicyIntrusionDetectionSignatureSpecification, len(configuration.SignatureOverrides))
		for signatureOverrideIndex, signatureOverrideItem := range configuration.SignatureOverrides {
			// Shadow the loop variable to avoid aliasing
			signatureOverrideItem := signatureOverrideItem
			var signatureOverride storage.FirewallPolicyIntrusionDetectionSignatureSpecification
			err := signatureOverrideItem.AssignProperties_To_FirewallPolicyIntrusionDetectionSignatureSpecification(&signatureOverride)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_FirewallPolicyIntrusionDetectionSignatureSpecification() to populate field SignatureOverrides")
			}
			signatureOverrideList[signatureOverrideIndex] = signatureOverride
		}
		destination.SignatureOverrides = signatureOverrideList
	} else {
		destination.SignatureOverrides = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_FirewallPolicyIntrusionDetectionConfiguration_STATUS populates our FirewallPolicyIntrusionDetectionConfiguration from the provided source FirewallPolicyIntrusionDetectionConfiguration_STATUS
func (configuration *FirewallPolicyIntrusionDetectionConfiguration) Initialize_From_FirewallPolicyIntrusionDetectionConfiguration_STATUS(source *FirewallPolicyIntrusionDetectionConfiguration_STATUS) error {

	// BypassTrafficSettings
	if source.BypassTrafficSettings != nil {
		bypassTrafficSettingList := make([]FirewallPolicyIntrusionDetectionBypassTrafficSpecifications, len(source.BypassTrafficSettings))
		for bypassTrafficSettingIndex, bypassTrafficSettingItem := range source.BypassTrafficSettings {
			// Shadow the loop variable to avoid aliasing
			bypassTrafficSettingItem := bypassTrafficSettingItem
			var bypassTrafficSetting FirewallPolicyIntrusionDetectionBypassTrafficSpecifications
			err := bypassTrafficSetting.Initialize_From_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS(&bypassTrafficSettingItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS() to populate field BypassTrafficSettings")
			}
			bypassTrafficSettingList[bypassTrafficSettingIndex] = bypassTrafficSetting
		}
		configuration.BypassTrafficSettings = bypassTrafficSettingList
	} else {
		configuration.BypassTrafficSettings = nil
	}

	// PrivateRanges
	configuration.PrivateRanges = genruntime.CloneSliceOfString(source.PrivateRanges)

	// SignatureOverrides
	if source.SignatureOverrides != nil {
		signatureOverrideList := make([]FirewallPolicyIntrusionDetectionSignatureSpecification, len(source.SignatureOverrides))
		for signatureOverrideIndex, signatureOverrideItem := range source.SignatureOverrides {
			// Shadow the loop variable to avoid aliasing
			signatureOverrideItem := signatureOverrideItem
			var signatureOverride FirewallPolicyIntrusionDetectionSignatureSpecification
			err := signatureOverride.Initialize_From_FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS(&signatureOverrideItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS() to populate field SignatureOverrides")
			}
			signatureOverrideList[signatureOverrideIndex] = signatureOverride
		}
		configuration.SignatureOverrides = signatureOverrideList
	} else {
		configuration.SignatureOverrides = nil
	}

	// No error
	return nil
}

// The operation for configuring intrusion detection.
type FirewallPolicyIntrusionDetectionConfiguration_STATUS struct {
	// BypassTrafficSettings: List of rules for traffic to bypass.
	BypassTrafficSettings []FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS `json:"bypassTrafficSettings,omitempty"`

	// PrivateRanges: IDPS Private IP address ranges are used to identify traffic direction (i.e. inbound, outbound, etc.). By
	// default, only ranges defined by IANA RFC 1918 are considered private IP addresses. To modify default ranges, specify
	// your Private IP address ranges with this property
	PrivateRanges []string `json:"privateRanges,omitempty"`

	// SignatureOverrides: List of specific signatures states.
	SignatureOverrides []FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS `json:"signatureOverrides,omitempty"`
}

var _ genruntime.FromARMConverter = &FirewallPolicyIntrusionDetectionConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *FirewallPolicyIntrusionDetectionConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FirewallPolicyIntrusionDetectionConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *FirewallPolicyIntrusionDetectionConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FirewallPolicyIntrusionDetectionConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FirewallPolicyIntrusionDetectionConfiguration_STATUS, got %T", armInput)
	}

	// Set property "BypassTrafficSettings":
	for _, item := range typedInput.BypassTrafficSettings {
		var item1 FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.BypassTrafficSettings = append(configuration.BypassTrafficSettings, item1)
	}

	// Set property "PrivateRanges":
	for _, item := range typedInput.PrivateRanges {
		configuration.PrivateRanges = append(configuration.PrivateRanges, item)
	}

	// Set property "SignatureOverrides":
	for _, item := range typedInput.SignatureOverrides {
		var item1 FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.SignatureOverrides = append(configuration.SignatureOverrides, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_FirewallPolicyIntrusionDetectionConfiguration_STATUS populates our FirewallPolicyIntrusionDetectionConfiguration_STATUS from the provided source FirewallPolicyIntrusionDetectionConfiguration_STATUS
func (configuration *FirewallPolicyIntrusionDetectionConfiguration_STATUS) AssignProperties_From_FirewallPolicyIntrusionDetectionConfiguration_STATUS(source *storage.FirewallPolicyIntrusionDetectionConfiguration_STATUS) error {

	// BypassTrafficSettings
	if source.BypassTrafficSettings != nil {
		bypassTrafficSettingList := make([]FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS, len(source.BypassTrafficSettings))
		for bypassTrafficSettingIndex, bypassTrafficSettingItem := range source.BypassTrafficSettings {
			// Shadow the loop variable to avoid aliasing
			bypassTrafficSettingItem := bypassTrafficSettingItem
			var bypassTrafficSetting FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS
			err := bypassTrafficSetting.AssignProperties_From_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS(&bypassTrafficSettingItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS() to populate field BypassTrafficSettings")
			}
			bypassTrafficSettingList[bypassTrafficSettingIndex] = bypassTrafficSetting
		}
		configuration.BypassTrafficSettings = bypassTrafficSettingList
	} else {
		configuration.BypassTrafficSettings = nil
	}

	// PrivateRanges
	configuration.PrivateRanges = genruntime.CloneSliceOfString(source.PrivateRanges)

	// SignatureOverrides
	if source.SignatureOverrides != nil {
		signatureOverrideList := make([]FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS, len(source.SignatureOverrides))
		for signatureOverrideIndex, signatureOverrideItem := range source.SignatureOverrides {
			// Shadow the loop variable to avoid aliasing
			signatureOverrideItem := signatureOverrideItem
			var signatureOverride FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS
			err := signatureOverride.AssignProperties_From_FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS(&signatureOverrideItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS() to populate field SignatureOverrides")
			}
			signatureOverrideList[signatureOverrideIndex] = signatureOverride
		}
		configuration.SignatureOverrides = signatureOverrideList
	} else {
		configuration.SignatureOverrides = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicyIntrusionDetectionConfiguration_STATUS populates the provided destination FirewallPolicyIntrusionDetectionConfiguration_STATUS from our FirewallPolicyIntrusionDetectionConfiguration_STATUS
func (configuration *FirewallPolicyIntrusionDetectionConfiguration_STATUS) AssignProperties_To_FirewallPolicyIntrusionDetectionConfiguration_STATUS(destination *storage.FirewallPolicyIntrusionDetectionConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BypassTrafficSettings
	if configuration.BypassTrafficSettings != nil {
		bypassTrafficSettingList := make([]storage.FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS, len(configuration.BypassTrafficSettings))
		for bypassTrafficSettingIndex, bypassTrafficSettingItem := range configuration.BypassTrafficSettings {
			// Shadow the loop variable to avoid aliasing
			bypassTrafficSettingItem := bypassTrafficSettingItem
			var bypassTrafficSetting storage.FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS
			err := bypassTrafficSettingItem.AssignProperties_To_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS(&bypassTrafficSetting)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS() to populate field BypassTrafficSettings")
			}
			bypassTrafficSettingList[bypassTrafficSettingIndex] = bypassTrafficSetting
		}
		destination.BypassTrafficSettings = bypassTrafficSettingList
	} else {
		destination.BypassTrafficSettings = nil
	}

	// PrivateRanges
	destination.PrivateRanges = genruntime.CloneSliceOfString(configuration.PrivateRanges)

	// SignatureOverrides
	if configuration.SignatureOverrides != nil {
		signatureOverrideList := make([]storage.FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS, len(configuration.SignatureOverrides))
		for signatureOverrideIndex, signatureOverrideItem := range configuration.SignatureOverrides {
			// Shadow the loop variable to avoid aliasing
			signatureOverrideItem := signatureOverrideItem
			var signatureOverride storage.FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS
			err := signatureOverrideItem.AssignProperties_To_FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS(&signatureOverride)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS() to populate field SignatureOverrides")
			}
			signatureOverrideList[signatureOverrideIndex] = signatureOverride
		}
		destination.SignatureOverrides = signatureOverrideList
	} else {
		destination.SignatureOverrides = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Possible Intrusion Detection profile values.
// +kubebuilder:validation:Enum={"Advanced","Basic","Extended","Standard"}
type FirewallPolicyIntrusionDetectionProfileOptions string

const (
	FirewallPolicyIntrusionDetectionProfileOptions_Advanced = FirewallPolicyIntrusionDetectionProfileOptions("Advanced")
	FirewallPolicyIntrusionDetectionProfileOptions_Basic    = FirewallPolicyIntrusionDetectionProfileOptions("Basic")
	FirewallPolicyIntrusionDetectionProfileOptions_Extended = FirewallPolicyIntrusionDetectionProfileOptions("Extended")
	FirewallPolicyIntrusionDetectionProfileOptions_Standard = FirewallPolicyIntrusionDetectionProfileOptions("Standard")
)

// Mapping from string to FirewallPolicyIntrusionDetectionProfileOptions
var firewallPolicyIntrusionDetectionProfileOptions_Values = map[string]FirewallPolicyIntrusionDetectionProfileOptions{
	"advanced": FirewallPolicyIntrusionDetectionProfileOptions_Advanced,
	"basic":    FirewallPolicyIntrusionDetectionProfileOptions_Basic,
	"extended": FirewallPolicyIntrusionDetectionProfileOptions_Extended,
	"standard": FirewallPolicyIntrusionDetectionProfileOptions_Standard,
}

// Possible Intrusion Detection profile values.
type FirewallPolicyIntrusionDetectionProfileOptions_STATUS string

const (
	FirewallPolicyIntrusionDetectionProfileOptions_STATUS_Advanced = FirewallPolicyIntrusionDetectionProfileOptions_STATUS("Advanced")
	FirewallPolicyIntrusionDetectionProfileOptions_STATUS_Basic    = FirewallPolicyIntrusionDetectionProfileOptions_STATUS("Basic")
	FirewallPolicyIntrusionDetectionProfileOptions_STATUS_Extended = FirewallPolicyIntrusionDetectionProfileOptions_STATUS("Extended")
	FirewallPolicyIntrusionDetectionProfileOptions_STATUS_Standard = FirewallPolicyIntrusionDetectionProfileOptions_STATUS("Standard")
)

// Mapping from string to FirewallPolicyIntrusionDetectionProfileOptions_STATUS
var firewallPolicyIntrusionDetectionProfileOptions_STATUS_Values = map[string]FirewallPolicyIntrusionDetectionProfileOptions_STATUS{
	"advanced": FirewallPolicyIntrusionDetectionProfileOptions_STATUS_Advanced,
	"basic":    FirewallPolicyIntrusionDetectionProfileOptions_STATUS_Basic,
	"extended": FirewallPolicyIntrusionDetectionProfileOptions_STATUS_Extended,
	"standard": FirewallPolicyIntrusionDetectionProfileOptions_STATUS_Standard,
}

// Possible state values.
// +kubebuilder:validation:Enum={"Alert","Deny","Off"}
type FirewallPolicyIntrusionDetectionStateOptions string

const (
	FirewallPolicyIntrusionDetectionStateOptions_Alert = FirewallPolicyIntrusionDetectionStateOptions("Alert")
	FirewallPolicyIntrusionDetectionStateOptions_Deny  = FirewallPolicyIntrusionDetectionStateOptions("Deny")
	FirewallPolicyIntrusionDetectionStateOptions_Off   = FirewallPolicyIntrusionDetectionStateOptions("Off")
)

// Mapping from string to FirewallPolicyIntrusionDetectionStateOptions
var firewallPolicyIntrusionDetectionStateOptions_Values = map[string]FirewallPolicyIntrusionDetectionStateOptions{
	"alert": FirewallPolicyIntrusionDetectionStateOptions_Alert,
	"deny":  FirewallPolicyIntrusionDetectionStateOptions_Deny,
	"off":   FirewallPolicyIntrusionDetectionStateOptions_Off,
}

// Possible state values.
type FirewallPolicyIntrusionDetectionStateOptions_STATUS string

const (
	FirewallPolicyIntrusionDetectionStateOptions_STATUS_Alert = FirewallPolicyIntrusionDetectionStateOptions_STATUS("Alert")
	FirewallPolicyIntrusionDetectionStateOptions_STATUS_Deny  = FirewallPolicyIntrusionDetectionStateOptions_STATUS("Deny")
	FirewallPolicyIntrusionDetectionStateOptions_STATUS_Off   = FirewallPolicyIntrusionDetectionStateOptions_STATUS("Off")
)

// Mapping from string to FirewallPolicyIntrusionDetectionStateOptions_STATUS
var firewallPolicyIntrusionDetectionStateOptions_STATUS_Values = map[string]FirewallPolicyIntrusionDetectionStateOptions_STATUS{
	"alert": FirewallPolicyIntrusionDetectionStateOptions_STATUS_Alert,
	"deny":  FirewallPolicyIntrusionDetectionStateOptions_STATUS_Deny,
	"off":   FirewallPolicyIntrusionDetectionStateOptions_STATUS_Off,
}

// Log Analytics Resources for Firewall Policy Insights.
type FirewallPolicyLogAnalyticsResources struct {
	// DefaultWorkspaceId: The default workspace Id for Firewall Policy Insights.
	DefaultWorkspaceId *SubResource `json:"defaultWorkspaceId,omitempty"`

	// Workspaces: List of workspaces for Firewall Policy Insights.
	Workspaces []FirewallPolicyLogAnalyticsWorkspace `json:"workspaces,omitempty"`
}

var _ genruntime.ARMTransformer = &FirewallPolicyLogAnalyticsResources{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (resources *FirewallPolicyLogAnalyticsResources) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if resources == nil {
		return nil, nil
	}
	result := &arm.FirewallPolicyLogAnalyticsResources{}

	// Set property "DefaultWorkspaceId":
	if resources.DefaultWorkspaceId != nil {
		defaultWorkspaceId_ARM, err := (*resources.DefaultWorkspaceId).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		defaultWorkspaceId := *defaultWorkspaceId_ARM.(*arm.SubResource)
		result.DefaultWorkspaceId = &defaultWorkspaceId
	}

	// Set property "Workspaces":
	for _, item := range resources.Workspaces {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Workspaces = append(result.Workspaces, *item_ARM.(*arm.FirewallPolicyLogAnalyticsWorkspace))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resources *FirewallPolicyLogAnalyticsResources) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FirewallPolicyLogAnalyticsResources{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resources *FirewallPolicyLogAnalyticsResources) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FirewallPolicyLogAnalyticsResources)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FirewallPolicyLogAnalyticsResources, got %T", armInput)
	}

	// Set property "DefaultWorkspaceId":
	if typedInput.DefaultWorkspaceId != nil {
		var defaultWorkspaceId1 SubResource
		err := defaultWorkspaceId1.PopulateFromARM(owner, *typedInput.DefaultWorkspaceId)
		if err != nil {
			return err
		}
		defaultWorkspaceId := defaultWorkspaceId1
		resources.DefaultWorkspaceId = &defaultWorkspaceId
	}

	// Set property "Workspaces":
	for _, item := range typedInput.Workspaces {
		var item1 FirewallPolicyLogAnalyticsWorkspace
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		resources.Workspaces = append(resources.Workspaces, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_FirewallPolicyLogAnalyticsResources populates our FirewallPolicyLogAnalyticsResources from the provided source FirewallPolicyLogAnalyticsResources
func (resources *FirewallPolicyLogAnalyticsResources) AssignProperties_From_FirewallPolicyLogAnalyticsResources(source *storage.FirewallPolicyLogAnalyticsResources) error {

	// DefaultWorkspaceId
	if source.DefaultWorkspaceId != nil {
		var defaultWorkspaceId SubResource
		err := defaultWorkspaceId.AssignProperties_From_SubResource(source.DefaultWorkspaceId)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SubResource() to populate field DefaultWorkspaceId")
		}
		resources.DefaultWorkspaceId = &defaultWorkspaceId
	} else {
		resources.DefaultWorkspaceId = nil
	}

	// Workspaces
	if source.Workspaces != nil {
		workspaceList := make([]FirewallPolicyLogAnalyticsWorkspace, len(source.Workspaces))
		for workspaceIndex, workspaceItem := range source.Workspaces {
			// Shadow the loop variable to avoid aliasing
			workspaceItem := workspaceItem
			var workspace FirewallPolicyLogAnalyticsWorkspace
			err := workspace.AssignProperties_From_FirewallPolicyLogAnalyticsWorkspace(&workspaceItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_FirewallPolicyLogAnalyticsWorkspace() to populate field Workspaces")
			}
			workspaceList[workspaceIndex] = workspace
		}
		resources.Workspaces = workspaceList
	} else {
		resources.Workspaces = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicyLogAnalyticsResources populates the provided destination FirewallPolicyLogAnalyticsResources from our FirewallPolicyLogAnalyticsResources
func (resources *FirewallPolicyLogAnalyticsResources) AssignProperties_To_FirewallPolicyLogAnalyticsResources(destination *storage.FirewallPolicyLogAnalyticsResources) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DefaultWorkspaceId
	if resources.DefaultWorkspaceId != nil {
		var defaultWorkspaceId storage.SubResource
		err := resources.DefaultWorkspaceId.AssignProperties_To_SubResource(&defaultWorkspaceId)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SubResource() to populate field DefaultWorkspaceId")
		}
		destination.DefaultWorkspaceId = &defaultWorkspaceId
	} else {
		destination.DefaultWorkspaceId = nil
	}

	// Workspaces
	if resources.Workspaces != nil {
		workspaceList := make([]storage.FirewallPolicyLogAnalyticsWorkspace, len(resources.Workspaces))
		for workspaceIndex, workspaceItem := range resources.Workspaces {
			// Shadow the loop variable to avoid aliasing
			workspaceItem := workspaceItem
			var workspace storage.FirewallPolicyLogAnalyticsWorkspace
			err := workspaceItem.AssignProperties_To_FirewallPolicyLogAnalyticsWorkspace(&workspace)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_FirewallPolicyLogAnalyticsWorkspace() to populate field Workspaces")
			}
			workspaceList[workspaceIndex] = workspace
		}
		destination.Workspaces = workspaceList
	} else {
		destination.Workspaces = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_FirewallPolicyLogAnalyticsResources_STATUS populates our FirewallPolicyLogAnalyticsResources from the provided source FirewallPolicyLogAnalyticsResources_STATUS
func (resources *FirewallPolicyLogAnalyticsResources) Initialize_From_FirewallPolicyLogAnalyticsResources_STATUS(source *FirewallPolicyLogAnalyticsResources_STATUS) error {

	// DefaultWorkspaceId
	if source.DefaultWorkspaceId != nil {
		var defaultWorkspaceId SubResource
		err := defaultWorkspaceId.Initialize_From_SubResource_STATUS(source.DefaultWorkspaceId)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field DefaultWorkspaceId")
		}
		resources.DefaultWorkspaceId = &defaultWorkspaceId
	} else {
		resources.DefaultWorkspaceId = nil
	}

	// Workspaces
	if source.Workspaces != nil {
		workspaceList := make([]FirewallPolicyLogAnalyticsWorkspace, len(source.Workspaces))
		for workspaceIndex, workspaceItem := range source.Workspaces {
			// Shadow the loop variable to avoid aliasing
			workspaceItem := workspaceItem
			var workspace FirewallPolicyLogAnalyticsWorkspace
			err := workspace.Initialize_From_FirewallPolicyLogAnalyticsWorkspace_STATUS(&workspaceItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_FirewallPolicyLogAnalyticsWorkspace_STATUS() to populate field Workspaces")
			}
			workspaceList[workspaceIndex] = workspace
		}
		resources.Workspaces = workspaceList
	} else {
		resources.Workspaces = nil
	}

	// No error
	return nil
}

// Log Analytics Resources for Firewall Policy Insights.
type FirewallPolicyLogAnalyticsResources_STATUS struct {
	// DefaultWorkspaceId: The default workspace Id for Firewall Policy Insights.
	DefaultWorkspaceId *SubResource_STATUS `json:"defaultWorkspaceId,omitempty"`

	// Workspaces: List of workspaces for Firewall Policy Insights.
	Workspaces []FirewallPolicyLogAnalyticsWorkspace_STATUS `json:"workspaces,omitempty"`
}

var _ genruntime.FromARMConverter = &FirewallPolicyLogAnalyticsResources_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resources *FirewallPolicyLogAnalyticsResources_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FirewallPolicyLogAnalyticsResources_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resources *FirewallPolicyLogAnalyticsResources_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FirewallPolicyLogAnalyticsResources_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FirewallPolicyLogAnalyticsResources_STATUS, got %T", armInput)
	}

	// Set property "DefaultWorkspaceId":
	if typedInput.DefaultWorkspaceId != nil {
		var defaultWorkspaceId1 SubResource_STATUS
		err := defaultWorkspaceId1.PopulateFromARM(owner, *typedInput.DefaultWorkspaceId)
		if err != nil {
			return err
		}
		defaultWorkspaceId := defaultWorkspaceId1
		resources.DefaultWorkspaceId = &defaultWorkspaceId
	}

	// Set property "Workspaces":
	for _, item := range typedInput.Workspaces {
		var item1 FirewallPolicyLogAnalyticsWorkspace_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		resources.Workspaces = append(resources.Workspaces, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_FirewallPolicyLogAnalyticsResources_STATUS populates our FirewallPolicyLogAnalyticsResources_STATUS from the provided source FirewallPolicyLogAnalyticsResources_STATUS
func (resources *FirewallPolicyLogAnalyticsResources_STATUS) AssignProperties_From_FirewallPolicyLogAnalyticsResources_STATUS(source *storage.FirewallPolicyLogAnalyticsResources_STATUS) error {

	// DefaultWorkspaceId
	if source.DefaultWorkspaceId != nil {
		var defaultWorkspaceId SubResource_STATUS
		err := defaultWorkspaceId.AssignProperties_From_SubResource_STATUS(source.DefaultWorkspaceId)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field DefaultWorkspaceId")
		}
		resources.DefaultWorkspaceId = &defaultWorkspaceId
	} else {
		resources.DefaultWorkspaceId = nil
	}

	// Workspaces
	if source.Workspaces != nil {
		workspaceList := make([]FirewallPolicyLogAnalyticsWorkspace_STATUS, len(source.Workspaces))
		for workspaceIndex, workspaceItem := range source.Workspaces {
			// Shadow the loop variable to avoid aliasing
			workspaceItem := workspaceItem
			var workspace FirewallPolicyLogAnalyticsWorkspace_STATUS
			err := workspace.AssignProperties_From_FirewallPolicyLogAnalyticsWorkspace_STATUS(&workspaceItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_FirewallPolicyLogAnalyticsWorkspace_STATUS() to populate field Workspaces")
			}
			workspaceList[workspaceIndex] = workspace
		}
		resources.Workspaces = workspaceList
	} else {
		resources.Workspaces = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicyLogAnalyticsResources_STATUS populates the provided destination FirewallPolicyLogAnalyticsResources_STATUS from our FirewallPolicyLogAnalyticsResources_STATUS
func (resources *FirewallPolicyLogAnalyticsResources_STATUS) AssignProperties_To_FirewallPolicyLogAnalyticsResources_STATUS(destination *storage.FirewallPolicyLogAnalyticsResources_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DefaultWorkspaceId
	if resources.DefaultWorkspaceId != nil {
		var defaultWorkspaceId storage.SubResource_STATUS
		err := resources.DefaultWorkspaceId.AssignProperties_To_SubResource_STATUS(&defaultWorkspaceId)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field DefaultWorkspaceId")
		}
		destination.DefaultWorkspaceId = &defaultWorkspaceId
	} else {
		destination.DefaultWorkspaceId = nil
	}

	// Workspaces
	if resources.Workspaces != nil {
		workspaceList := make([]storage.FirewallPolicyLogAnalyticsWorkspace_STATUS, len(resources.Workspaces))
		for workspaceIndex, workspaceItem := range resources.Workspaces {
			// Shadow the loop variable to avoid aliasing
			workspaceItem := workspaceItem
			var workspace storage.FirewallPolicyLogAnalyticsWorkspace_STATUS
			err := workspaceItem.AssignProperties_To_FirewallPolicyLogAnalyticsWorkspace_STATUS(&workspace)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_FirewallPolicyLogAnalyticsWorkspace_STATUS() to populate field Workspaces")
			}
			workspaceList[workspaceIndex] = workspace
		}
		destination.Workspaces = workspaceList
	} else {
		destination.Workspaces = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Basic","Premium","Standard"}
type FirewallPolicySku_Tier string

const (
	FirewallPolicySku_Tier_Basic    = FirewallPolicySku_Tier("Basic")
	FirewallPolicySku_Tier_Premium  = FirewallPolicySku_Tier("Premium")
	FirewallPolicySku_Tier_Standard = FirewallPolicySku_Tier("Standard")
)

// Mapping from string to FirewallPolicySku_Tier
var firewallPolicySku_Tier_Values = map[string]FirewallPolicySku_Tier{
	"basic":    FirewallPolicySku_Tier_Basic,
	"premium":  FirewallPolicySku_Tier_Premium,
	"standard": FirewallPolicySku_Tier_Standard,
}

type FirewallPolicySku_Tier_STATUS string

const (
	FirewallPolicySku_Tier_STATUS_Basic    = FirewallPolicySku_Tier_STATUS("Basic")
	FirewallPolicySku_Tier_STATUS_Premium  = FirewallPolicySku_Tier_STATUS("Premium")
	FirewallPolicySku_Tier_STATUS_Standard = FirewallPolicySku_Tier_STATUS("Standard")
)

// Mapping from string to FirewallPolicySku_Tier_STATUS
var firewallPolicySku_Tier_STATUS_Values = map[string]FirewallPolicySku_Tier_STATUS{
	"basic":    FirewallPolicySku_Tier_STATUS_Basic,
	"premium":  FirewallPolicySku_Tier_STATUS_Premium,
	"standard": FirewallPolicySku_Tier_STATUS_Standard,
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type FirewallPolicySNAT_AutoLearnPrivateRanges string

const (
	FirewallPolicySNAT_AutoLearnPrivateRanges_Disabled = FirewallPolicySNAT_AutoLearnPrivateRanges("Disabled")
	FirewallPolicySNAT_AutoLearnPrivateRanges_Enabled  = FirewallPolicySNAT_AutoLearnPrivateRanges("Enabled")
)

// Mapping from string to FirewallPolicySNAT_AutoLearnPrivateRanges
var firewallPolicySNAT_AutoLearnPrivateRanges_Values = map[string]FirewallPolicySNAT_AutoLearnPrivateRanges{
	"disabled": FirewallPolicySNAT_AutoLearnPrivateRanges_Disabled,
	"enabled":  FirewallPolicySNAT_AutoLearnPrivateRanges_Enabled,
}

type FirewallPolicySNAT_AutoLearnPrivateRanges_STATUS string

const (
	FirewallPolicySNAT_AutoLearnPrivateRanges_STATUS_Disabled = FirewallPolicySNAT_AutoLearnPrivateRanges_STATUS("Disabled")
	FirewallPolicySNAT_AutoLearnPrivateRanges_STATUS_Enabled  = FirewallPolicySNAT_AutoLearnPrivateRanges_STATUS("Enabled")
)

// Mapping from string to FirewallPolicySNAT_AutoLearnPrivateRanges_STATUS
var firewallPolicySNAT_AutoLearnPrivateRanges_STATUS_Values = map[string]FirewallPolicySNAT_AutoLearnPrivateRanges_STATUS{
	"disabled": FirewallPolicySNAT_AutoLearnPrivateRanges_STATUS_Disabled,
	"enabled":  FirewallPolicySNAT_AutoLearnPrivateRanges_STATUS_Enabled,
}

// +kubebuilder:validation:Enum={"None","SystemAssigned","SystemAssigned, UserAssigned","UserAssigned"}
type ManagedServiceIdentity_Type string

const (
	ManagedServiceIdentity_Type_None                       = ManagedServiceIdentity_Type("None")
	ManagedServiceIdentity_Type_SystemAssigned             = ManagedServiceIdentity_Type("SystemAssigned")
	ManagedServiceIdentity_Type_SystemAssignedUserAssigned = ManagedServiceIdentity_Type("SystemAssigned, UserAssigned")
	ManagedServiceIdentity_Type_UserAssigned               = ManagedServiceIdentity_Type("UserAssigned")
)

// Mapping from string to ManagedServiceIdentity_Type
var managedServiceIdentity_Type_Values = map[string]ManagedServiceIdentity_Type{
	"none":                         ManagedServiceIdentity_Type_None,
	"systemassigned":               ManagedServiceIdentity_Type_SystemAssigned,
	"systemassigned, userassigned": ManagedServiceIdentity_Type_SystemAssignedUserAssigned,
	"userassigned":                 ManagedServiceIdentity_Type_UserAssigned,
}

type ManagedServiceIdentity_Type_STATUS string

const (
	ManagedServiceIdentity_Type_STATUS_None                       = ManagedServiceIdentity_Type_STATUS("None")
	ManagedServiceIdentity_Type_STATUS_SystemAssigned             = ManagedServiceIdentity_Type_STATUS("SystemAssigned")
	ManagedServiceIdentity_Type_STATUS_SystemAssignedUserAssigned = ManagedServiceIdentity_Type_STATUS("SystemAssigned, UserAssigned")
	ManagedServiceIdentity_Type_STATUS_UserAssigned               = ManagedServiceIdentity_Type_STATUS("UserAssigned")
)

// Mapping from string to ManagedServiceIdentity_Type_STATUS
var managedServiceIdentity_Type_STATUS_Values = map[string]ManagedServiceIdentity_Type_STATUS{
	"none":                         ManagedServiceIdentity_Type_STATUS_None,
	"systemassigned":               ManagedServiceIdentity_Type_STATUS_SystemAssigned,
	"systemassigned, userassigned": ManagedServiceIdentity_Type_STATUS_SystemAssignedUserAssigned,
	"userassigned":                 ManagedServiceIdentity_Type_STATUS_UserAssigned,
}

type ManagedServiceIdentity_UserAssignedIdentities_STATUS struct {
	// ClientId: The client id of user assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	// PrincipalId: The principal id of user assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedServiceIdentity_UserAssignedIdentities_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identities *ManagedServiceIdentity_UserAssignedIdentities_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedServiceIdentity_UserAssignedIdentities_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identities *ManagedServiceIdentity_UserAssignedIdentities_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedServiceIdentity_UserAssignedIdentities_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedServiceIdentity_UserAssignedIdentities_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identities.ClientId = &clientId
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identities.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedServiceIdentity_UserAssignedIdentities_STATUS populates our ManagedServiceIdentity_UserAssignedIdentities_STATUS from the provided source ManagedServiceIdentity_UserAssignedIdentities_STATUS
func (identities *ManagedServiceIdentity_UserAssignedIdentities_STATUS) AssignProperties_From_ManagedServiceIdentity_UserAssignedIdentities_STATUS(source *storage.ManagedServiceIdentity_UserAssignedIdentities_STATUS) error {

	// ClientId
	identities.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identities.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// No error
	return nil
}

// AssignProperties_To_ManagedServiceIdentity_UserAssignedIdentities_STATUS populates the provided destination ManagedServiceIdentity_UserAssignedIdentities_STATUS from our ManagedServiceIdentity_UserAssignedIdentities_STATUS
func (identities *ManagedServiceIdentity_UserAssignedIdentities_STATUS) AssignProperties_To_ManagedServiceIdentity_UserAssignedIdentities_STATUS(destination *storage.ManagedServiceIdentity_UserAssignedIdentities_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identities.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identities.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Information about the user assigned identity for the resource
type UserAssignedIdentityDetails struct {
	Reference genruntime.ResourceReference `armReference:"Reference" json:"reference,omitempty"`
}

// AssignProperties_From_UserAssignedIdentityDetails populates our UserAssignedIdentityDetails from the provided source UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_From_UserAssignedIdentityDetails(source *storage.UserAssignedIdentityDetails) error {

	// Reference
	details.Reference = source.Reference.Copy()

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentityDetails populates the provided destination UserAssignedIdentityDetails from our UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_To_UserAssignedIdentityDetails(destination *storage.UserAssignedIdentityDetails) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	destination.Reference = details.Reference.Copy()

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Intrusion detection bypass traffic specification.
type FirewallPolicyIntrusionDetectionBypassTrafficSpecifications struct {
	// Description: Description of the bypass traffic rule.
	Description *string `json:"description,omitempty"`

	// DestinationAddresses: List of destination IP addresses or ranges for this rule.
	DestinationAddresses []string `json:"destinationAddresses,omitempty"`

	// DestinationIpGroups: List of destination IpGroups for this rule.
	DestinationIpGroups []string `json:"destinationIpGroups,omitempty"`

	// DestinationPorts: List of destination ports or ranges.
	DestinationPorts []string `json:"destinationPorts,omitempty"`

	// Name: Name of the bypass traffic rule.
	Name *string `json:"name,omitempty"`

	// Protocol: The rule bypass protocol.
	Protocol *FirewallPolicyIntrusionDetectionBypassTrafficProtocol `json:"protocol,omitempty"`

	// SourceAddresses: List of source IP addresses or ranges for this rule.
	SourceAddresses []string `json:"sourceAddresses,omitempty"`

	// SourceIpGroups: List of source IpGroups for this rule.
	SourceIpGroups []string `json:"sourceIpGroups,omitempty"`
}

var _ genruntime.ARMTransformer = &FirewallPolicyIntrusionDetectionBypassTrafficSpecifications{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (specifications *FirewallPolicyIntrusionDetectionBypassTrafficSpecifications) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if specifications == nil {
		return nil, nil
	}
	result := &arm.FirewallPolicyIntrusionDetectionBypassTrafficSpecifications{}

	// Set property "Description":
	if specifications.Description != nil {
		description := *specifications.Description
		result.Description = &description
	}

	// Set property "DestinationAddresses":
	for _, item := range specifications.DestinationAddresses {
		result.DestinationAddresses = append(result.DestinationAddresses, item)
	}

	// Set property "DestinationIpGroups":
	for _, item := range specifications.DestinationIpGroups {
		result.DestinationIpGroups = append(result.DestinationIpGroups, item)
	}

	// Set property "DestinationPorts":
	for _, item := range specifications.DestinationPorts {
		result.DestinationPorts = append(result.DestinationPorts, item)
	}

	// Set property "Name":
	if specifications.Name != nil {
		name := *specifications.Name
		result.Name = &name
	}

	// Set property "Protocol":
	if specifications.Protocol != nil {
		var temp string
		temp = string(*specifications.Protocol)
		protocol := arm.FirewallPolicyIntrusionDetectionBypassTrafficProtocol(temp)
		result.Protocol = &protocol
	}

	// Set property "SourceAddresses":
	for _, item := range specifications.SourceAddresses {
		result.SourceAddresses = append(result.SourceAddresses, item)
	}

	// Set property "SourceIpGroups":
	for _, item := range specifications.SourceIpGroups {
		result.SourceIpGroups = append(result.SourceIpGroups, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (specifications *FirewallPolicyIntrusionDetectionBypassTrafficSpecifications) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FirewallPolicyIntrusionDetectionBypassTrafficSpecifications{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (specifications *FirewallPolicyIntrusionDetectionBypassTrafficSpecifications) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FirewallPolicyIntrusionDetectionBypassTrafficSpecifications)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FirewallPolicyIntrusionDetectionBypassTrafficSpecifications, got %T", armInput)
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		specifications.Description = &description
	}

	// Set property "DestinationAddresses":
	for _, item := range typedInput.DestinationAddresses {
		specifications.DestinationAddresses = append(specifications.DestinationAddresses, item)
	}

	// Set property "DestinationIpGroups":
	for _, item := range typedInput.DestinationIpGroups {
		specifications.DestinationIpGroups = append(specifications.DestinationIpGroups, item)
	}

	// Set property "DestinationPorts":
	for _, item := range typedInput.DestinationPorts {
		specifications.DestinationPorts = append(specifications.DestinationPorts, item)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		specifications.Name = &name
	}

	// Set property "Protocol":
	if typedInput.Protocol != nil {
		var temp string
		temp = string(*typedInput.Protocol)
		protocol := FirewallPolicyIntrusionDetectionBypassTrafficProtocol(temp)
		specifications.Protocol = &protocol
	}

	// Set property "SourceAddresses":
	for _, item := range typedInput.SourceAddresses {
		specifications.SourceAddresses = append(specifications.SourceAddresses, item)
	}

	// Set property "SourceIpGroups":
	for _, item := range typedInput.SourceIpGroups {
		specifications.SourceIpGroups = append(specifications.SourceIpGroups, item)
	}

	// No error
	return nil
}

// AssignProperties_From_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications populates our FirewallPolicyIntrusionDetectionBypassTrafficSpecifications from the provided source FirewallPolicyIntrusionDetectionBypassTrafficSpecifications
func (specifications *FirewallPolicyIntrusionDetectionBypassTrafficSpecifications) AssignProperties_From_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications(source *storage.FirewallPolicyIntrusionDetectionBypassTrafficSpecifications) error {

	// Description
	specifications.Description = genruntime.ClonePointerToString(source.Description)

	// DestinationAddresses
	specifications.DestinationAddresses = genruntime.CloneSliceOfString(source.DestinationAddresses)

	// DestinationIpGroups
	specifications.DestinationIpGroups = genruntime.CloneSliceOfString(source.DestinationIpGroups)

	// DestinationPorts
	specifications.DestinationPorts = genruntime.CloneSliceOfString(source.DestinationPorts)

	// Name
	specifications.Name = genruntime.ClonePointerToString(source.Name)

	// Protocol
	if source.Protocol != nil {
		protocol := *source.Protocol
		protocolTemp := genruntime.ToEnum(protocol, firewallPolicyIntrusionDetectionBypassTrafficProtocol_Values)
		specifications.Protocol = &protocolTemp
	} else {
		specifications.Protocol = nil
	}

	// SourceAddresses
	specifications.SourceAddresses = genruntime.CloneSliceOfString(source.SourceAddresses)

	// SourceIpGroups
	specifications.SourceIpGroups = genruntime.CloneSliceOfString(source.SourceIpGroups)

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications populates the provided destination FirewallPolicyIntrusionDetectionBypassTrafficSpecifications from our FirewallPolicyIntrusionDetectionBypassTrafficSpecifications
func (specifications *FirewallPolicyIntrusionDetectionBypassTrafficSpecifications) AssignProperties_To_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications(destination *storage.FirewallPolicyIntrusionDetectionBypassTrafficSpecifications) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Description
	destination.Description = genruntime.ClonePointerToString(specifications.Description)

	// DestinationAddresses
	destination.DestinationAddresses = genruntime.CloneSliceOfString(specifications.DestinationAddresses)

	// DestinationIpGroups
	destination.DestinationIpGroups = genruntime.CloneSliceOfString(specifications.DestinationIpGroups)

	// DestinationPorts
	destination.DestinationPorts = genruntime.CloneSliceOfString(specifications.DestinationPorts)

	// Name
	destination.Name = genruntime.ClonePointerToString(specifications.Name)

	// Protocol
	if specifications.Protocol != nil {
		protocol := string(*specifications.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// SourceAddresses
	destination.SourceAddresses = genruntime.CloneSliceOfString(specifications.SourceAddresses)

	// SourceIpGroups
	destination.SourceIpGroups = genruntime.CloneSliceOfString(specifications.SourceIpGroups)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS populates our FirewallPolicyIntrusionDetectionBypassTrafficSpecifications from the provided source FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS
func (specifications *FirewallPolicyIntrusionDetectionBypassTrafficSpecifications) Initialize_From_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS(source *FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS) error {

	// Description
	specifications.Description = genruntime.ClonePointerToString(source.Description)

	// DestinationAddresses
	specifications.DestinationAddresses = genruntime.CloneSliceOfString(source.DestinationAddresses)

	// DestinationIpGroups
	specifications.DestinationIpGroups = genruntime.CloneSliceOfString(source.DestinationIpGroups)

	// DestinationPorts
	specifications.DestinationPorts = genruntime.CloneSliceOfString(source.DestinationPorts)

	// Name
	specifications.Name = genruntime.ClonePointerToString(source.Name)

	// Protocol
	if source.Protocol != nil {
		protocol := genruntime.ToEnum(string(*source.Protocol), firewallPolicyIntrusionDetectionBypassTrafficProtocol_Values)
		specifications.Protocol = &protocol
	} else {
		specifications.Protocol = nil
	}

	// SourceAddresses
	specifications.SourceAddresses = genruntime.CloneSliceOfString(source.SourceAddresses)

	// SourceIpGroups
	specifications.SourceIpGroups = genruntime.CloneSliceOfString(source.SourceIpGroups)

	// No error
	return nil
}

// Intrusion detection bypass traffic specification.
type FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS struct {
	// Description: Description of the bypass traffic rule.
	Description *string `json:"description,omitempty"`

	// DestinationAddresses: List of destination IP addresses or ranges for this rule.
	DestinationAddresses []string `json:"destinationAddresses,omitempty"`

	// DestinationIpGroups: List of destination IpGroups for this rule.
	DestinationIpGroups []string `json:"destinationIpGroups,omitempty"`

	// DestinationPorts: List of destination ports or ranges.
	DestinationPorts []string `json:"destinationPorts,omitempty"`

	// Name: Name of the bypass traffic rule.
	Name *string `json:"name,omitempty"`

	// Protocol: The rule bypass protocol.
	Protocol *FirewallPolicyIntrusionDetectionBypassTrafficProtocol_STATUS `json:"protocol,omitempty"`

	// SourceAddresses: List of source IP addresses or ranges for this rule.
	SourceAddresses []string `json:"sourceAddresses,omitempty"`

	// SourceIpGroups: List of source IpGroups for this rule.
	SourceIpGroups []string `json:"sourceIpGroups,omitempty"`
}

var _ genruntime.FromARMConverter = &FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (specifications *FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (specifications *FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS, got %T", armInput)
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		specifications.Description = &description
	}

	// Set property "DestinationAddresses":
	for _, item := range typedInput.DestinationAddresses {
		specifications.DestinationAddresses = append(specifications.DestinationAddresses, item)
	}

	// Set property "DestinationIpGroups":
	for _, item := range typedInput.DestinationIpGroups {
		specifications.DestinationIpGroups = append(specifications.DestinationIpGroups, item)
	}

	// Set property "DestinationPorts":
	for _, item := range typedInput.DestinationPorts {
		specifications.DestinationPorts = append(specifications.DestinationPorts, item)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		specifications.Name = &name
	}

	// Set property "Protocol":
	if typedInput.Protocol != nil {
		var temp string
		temp = string(*typedInput.Protocol)
		protocol := FirewallPolicyIntrusionDetectionBypassTrafficProtocol_STATUS(temp)
		specifications.Protocol = &protocol
	}

	// Set property "SourceAddresses":
	for _, item := range typedInput.SourceAddresses {
		specifications.SourceAddresses = append(specifications.SourceAddresses, item)
	}

	// Set property "SourceIpGroups":
	for _, item := range typedInput.SourceIpGroups {
		specifications.SourceIpGroups = append(specifications.SourceIpGroups, item)
	}

	// No error
	return nil
}

// AssignProperties_From_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS populates our FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS from the provided source FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS
func (specifications *FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS) AssignProperties_From_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS(source *storage.FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS) error {

	// Description
	specifications.Description = genruntime.ClonePointerToString(source.Description)

	// DestinationAddresses
	specifications.DestinationAddresses = genruntime.CloneSliceOfString(source.DestinationAddresses)

	// DestinationIpGroups
	specifications.DestinationIpGroups = genruntime.CloneSliceOfString(source.DestinationIpGroups)

	// DestinationPorts
	specifications.DestinationPorts = genruntime.CloneSliceOfString(source.DestinationPorts)

	// Name
	specifications.Name = genruntime.ClonePointerToString(source.Name)

	// Protocol
	if source.Protocol != nil {
		protocol := *source.Protocol
		protocolTemp := genruntime.ToEnum(protocol, firewallPolicyIntrusionDetectionBypassTrafficProtocol_STATUS_Values)
		specifications.Protocol = &protocolTemp
	} else {
		specifications.Protocol = nil
	}

	// SourceAddresses
	specifications.SourceAddresses = genruntime.CloneSliceOfString(source.SourceAddresses)

	// SourceIpGroups
	specifications.SourceIpGroups = genruntime.CloneSliceOfString(source.SourceIpGroups)

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS populates the provided destination FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS from our FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS
func (specifications *FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS) AssignProperties_To_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS(destination *storage.FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Description
	destination.Description = genruntime.ClonePointerToString(specifications.Description)

	// DestinationAddresses
	destination.DestinationAddresses = genruntime.CloneSliceOfString(specifications.DestinationAddresses)

	// DestinationIpGroups
	destination.DestinationIpGroups = genruntime.CloneSliceOfString(specifications.DestinationIpGroups)

	// DestinationPorts
	destination.DestinationPorts = genruntime.CloneSliceOfString(specifications.DestinationPorts)

	// Name
	destination.Name = genruntime.ClonePointerToString(specifications.Name)

	// Protocol
	if specifications.Protocol != nil {
		protocol := string(*specifications.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// SourceAddresses
	destination.SourceAddresses = genruntime.CloneSliceOfString(specifications.SourceAddresses)

	// SourceIpGroups
	destination.SourceIpGroups = genruntime.CloneSliceOfString(specifications.SourceIpGroups)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Intrusion detection signatures specification states.
type FirewallPolicyIntrusionDetectionSignatureSpecification struct {
	// Id: Signature id.
	Id *string `json:"id,omitempty"`

	// Mode: The signature state.
	Mode *FirewallPolicyIntrusionDetectionStateOptions `json:"mode,omitempty"`
}

var _ genruntime.ARMTransformer = &FirewallPolicyIntrusionDetectionSignatureSpecification{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (specification *FirewallPolicyIntrusionDetectionSignatureSpecification) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if specification == nil {
		return nil, nil
	}
	result := &arm.FirewallPolicyIntrusionDetectionSignatureSpecification{}

	// Set property "Id":
	if specification.Id != nil {
		id := *specification.Id
		result.Id = &id
	}

	// Set property "Mode":
	if specification.Mode != nil {
		var temp string
		temp = string(*specification.Mode)
		mode := arm.FirewallPolicyIntrusionDetectionStateOptions(temp)
		result.Mode = &mode
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (specification *FirewallPolicyIntrusionDetectionSignatureSpecification) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FirewallPolicyIntrusionDetectionSignatureSpecification{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (specification *FirewallPolicyIntrusionDetectionSignatureSpecification) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FirewallPolicyIntrusionDetectionSignatureSpecification)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FirewallPolicyIntrusionDetectionSignatureSpecification, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		specification.Id = &id
	}

	// Set property "Mode":
	if typedInput.Mode != nil {
		var temp string
		temp = string(*typedInput.Mode)
		mode := FirewallPolicyIntrusionDetectionStateOptions(temp)
		specification.Mode = &mode
	}

	// No error
	return nil
}

// AssignProperties_From_FirewallPolicyIntrusionDetectionSignatureSpecification populates our FirewallPolicyIntrusionDetectionSignatureSpecification from the provided source FirewallPolicyIntrusionDetectionSignatureSpecification
func (specification *FirewallPolicyIntrusionDetectionSignatureSpecification) AssignProperties_From_FirewallPolicyIntrusionDetectionSignatureSpecification(source *storage.FirewallPolicyIntrusionDetectionSignatureSpecification) error {

	// Id
	specification.Id = genruntime.ClonePointerToString(source.Id)

	// Mode
	if source.Mode != nil {
		mode := *source.Mode
		modeTemp := genruntime.ToEnum(mode, firewallPolicyIntrusionDetectionStateOptions_Values)
		specification.Mode = &modeTemp
	} else {
		specification.Mode = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicyIntrusionDetectionSignatureSpecification populates the provided destination FirewallPolicyIntrusionDetectionSignatureSpecification from our FirewallPolicyIntrusionDetectionSignatureSpecification
func (specification *FirewallPolicyIntrusionDetectionSignatureSpecification) AssignProperties_To_FirewallPolicyIntrusionDetectionSignatureSpecification(destination *storage.FirewallPolicyIntrusionDetectionSignatureSpecification) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(specification.Id)

	// Mode
	if specification.Mode != nil {
		mode := string(*specification.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS populates our FirewallPolicyIntrusionDetectionSignatureSpecification from the provided source FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS
func (specification *FirewallPolicyIntrusionDetectionSignatureSpecification) Initialize_From_FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS(source *FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS) error {

	// Id
	specification.Id = genruntime.ClonePointerToString(source.Id)

	// Mode
	if source.Mode != nil {
		mode := genruntime.ToEnum(string(*source.Mode), firewallPolicyIntrusionDetectionStateOptions_Values)
		specification.Mode = &mode
	} else {
		specification.Mode = nil
	}

	// No error
	return nil
}

// Intrusion detection signatures specification states.
type FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS struct {
	// Id: Signature id.
	Id *string `json:"id,omitempty"`

	// Mode: The signature state.
	Mode *FirewallPolicyIntrusionDetectionStateOptions_STATUS `json:"mode,omitempty"`
}

var _ genruntime.FromARMConverter = &FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (specification *FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (specification *FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		specification.Id = &id
	}

	// Set property "Mode":
	if typedInput.Mode != nil {
		var temp string
		temp = string(*typedInput.Mode)
		mode := FirewallPolicyIntrusionDetectionStateOptions_STATUS(temp)
		specification.Mode = &mode
	}

	// No error
	return nil
}

// AssignProperties_From_FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS populates our FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS from the provided source FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS
func (specification *FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS) AssignProperties_From_FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS(source *storage.FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS) error {

	// Id
	specification.Id = genruntime.ClonePointerToString(source.Id)

	// Mode
	if source.Mode != nil {
		mode := *source.Mode
		modeTemp := genruntime.ToEnum(mode, firewallPolicyIntrusionDetectionStateOptions_STATUS_Values)
		specification.Mode = &modeTemp
	} else {
		specification.Mode = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS populates the provided destination FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS from our FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS
func (specification *FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS) AssignProperties_To_FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS(destination *storage.FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(specification.Id)

	// Mode
	if specification.Mode != nil {
		mode := string(*specification.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Log Analytics Workspace for Firewall Policy Insights.
type FirewallPolicyLogAnalyticsWorkspace struct {
	// Region: Region to configure the Workspace.
	Region *string `json:"region,omitempty"`

	// WorkspaceId: The workspace Id for Firewall Policy Insights.
	WorkspaceId *SubResource `json:"workspaceId,omitempty"`
}

var _ genruntime.ARMTransformer = &FirewallPolicyLogAnalyticsWorkspace{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (workspace *FirewallPolicyLogAnalyticsWorkspace) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if workspace == nil {
		return nil, nil
	}
	result := &arm.FirewallPolicyLogAnalyticsWorkspace{}

	// Set property "Region":
	if workspace.Region != nil {
		region := *workspace.Region
		result.Region = &region
	}

	// Set property "WorkspaceId":
	if workspace.WorkspaceId != nil {
		workspaceId_ARM, err := (*workspace.WorkspaceId).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		workspaceId := *workspaceId_ARM.(*arm.SubResource)
		result.WorkspaceId = &workspaceId
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (workspace *FirewallPolicyLogAnalyticsWorkspace) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FirewallPolicyLogAnalyticsWorkspace{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (workspace *FirewallPolicyLogAnalyticsWorkspace) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FirewallPolicyLogAnalyticsWorkspace)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FirewallPolicyLogAnalyticsWorkspace, got %T", armInput)
	}

	// Set property "Region":
	if typedInput.Region != nil {
		region := *typedInput.Region
		workspace.Region = &region
	}

	// Set property "WorkspaceId":
	if typedInput.WorkspaceId != nil {
		var workspaceId1 SubResource
		err := workspaceId1.PopulateFromARM(owner, *typedInput.WorkspaceId)
		if err != nil {
			return err
		}
		workspaceId := workspaceId1
		workspace.WorkspaceId = &workspaceId
	}

	// No error
	return nil
}

// AssignProperties_From_FirewallPolicyLogAnalyticsWorkspace populates our FirewallPolicyLogAnalyticsWorkspace from the provided source FirewallPolicyLogAnalyticsWorkspace
func (workspace *FirewallPolicyLogAnalyticsWorkspace) AssignProperties_From_FirewallPolicyLogAnalyticsWorkspace(source *storage.FirewallPolicyLogAnalyticsWorkspace) error {

	// Region
	workspace.Region = genruntime.ClonePointerToString(source.Region)

	// WorkspaceId
	if source.WorkspaceId != nil {
		var workspaceId SubResource
		err := workspaceId.AssignProperties_From_SubResource(source.WorkspaceId)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SubResource() to populate field WorkspaceId")
		}
		workspace.WorkspaceId = &workspaceId
	} else {
		workspace.WorkspaceId = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicyLogAnalyticsWorkspace populates the provided destination FirewallPolicyLogAnalyticsWorkspace from our FirewallPolicyLogAnalyticsWorkspace
func (workspace *FirewallPolicyLogAnalyticsWorkspace) AssignProperties_To_FirewallPolicyLogAnalyticsWorkspace(destination *storage.FirewallPolicyLogAnalyticsWorkspace) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Region
	destination.Region = genruntime.ClonePointerToString(workspace.Region)

	// WorkspaceId
	if workspace.WorkspaceId != nil {
		var workspaceId storage.SubResource
		err := workspace.WorkspaceId.AssignProperties_To_SubResource(&workspaceId)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SubResource() to populate field WorkspaceId")
		}
		destination.WorkspaceId = &workspaceId
	} else {
		destination.WorkspaceId = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_FirewallPolicyLogAnalyticsWorkspace_STATUS populates our FirewallPolicyLogAnalyticsWorkspace from the provided source FirewallPolicyLogAnalyticsWorkspace_STATUS
func (workspace *FirewallPolicyLogAnalyticsWorkspace) Initialize_From_FirewallPolicyLogAnalyticsWorkspace_STATUS(source *FirewallPolicyLogAnalyticsWorkspace_STATUS) error {

	// Region
	workspace.Region = genruntime.ClonePointerToString(source.Region)

	// WorkspaceId
	if source.WorkspaceId != nil {
		var workspaceId SubResource
		err := workspaceId.Initialize_From_SubResource_STATUS(source.WorkspaceId)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field WorkspaceId")
		}
		workspace.WorkspaceId = &workspaceId
	} else {
		workspace.WorkspaceId = nil
	}

	// No error
	return nil
}

// Log Analytics Workspace for Firewall Policy Insights.
type FirewallPolicyLogAnalyticsWorkspace_STATUS struct {
	// Region: Region to configure the Workspace.
	Region *string `json:"region,omitempty"`

	// WorkspaceId: The workspace Id for Firewall Policy Insights.
	WorkspaceId *SubResource_STATUS `json:"workspaceId,omitempty"`
}

var _ genruntime.FromARMConverter = &FirewallPolicyLogAnalyticsWorkspace_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (workspace *FirewallPolicyLogAnalyticsWorkspace_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FirewallPolicyLogAnalyticsWorkspace_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (workspace *FirewallPolicyLogAnalyticsWorkspace_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FirewallPolicyLogAnalyticsWorkspace_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FirewallPolicyLogAnalyticsWorkspace_STATUS, got %T", armInput)
	}

	// Set property "Region":
	if typedInput.Region != nil {
		region := *typedInput.Region
		workspace.Region = &region
	}

	// Set property "WorkspaceId":
	if typedInput.WorkspaceId != nil {
		var workspaceId1 SubResource_STATUS
		err := workspaceId1.PopulateFromARM(owner, *typedInput.WorkspaceId)
		if err != nil {
			return err
		}
		workspaceId := workspaceId1
		workspace.WorkspaceId = &workspaceId
	}

	// No error
	return nil
}

// AssignProperties_From_FirewallPolicyLogAnalyticsWorkspace_STATUS populates our FirewallPolicyLogAnalyticsWorkspace_STATUS from the provided source FirewallPolicyLogAnalyticsWorkspace_STATUS
func (workspace *FirewallPolicyLogAnalyticsWorkspace_STATUS) AssignProperties_From_FirewallPolicyLogAnalyticsWorkspace_STATUS(source *storage.FirewallPolicyLogAnalyticsWorkspace_STATUS) error {

	// Region
	workspace.Region = genruntime.ClonePointerToString(source.Region)

	// WorkspaceId
	if source.WorkspaceId != nil {
		var workspaceId SubResource_STATUS
		err := workspaceId.AssignProperties_From_SubResource_STATUS(source.WorkspaceId)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field WorkspaceId")
		}
		workspace.WorkspaceId = &workspaceId
	} else {
		workspace.WorkspaceId = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FirewallPolicyLogAnalyticsWorkspace_STATUS populates the provided destination FirewallPolicyLogAnalyticsWorkspace_STATUS from our FirewallPolicyLogAnalyticsWorkspace_STATUS
func (workspace *FirewallPolicyLogAnalyticsWorkspace_STATUS) AssignProperties_To_FirewallPolicyLogAnalyticsWorkspace_STATUS(destination *storage.FirewallPolicyLogAnalyticsWorkspace_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Region
	destination.Region = genruntime.ClonePointerToString(workspace.Region)

	// WorkspaceId
	if workspace.WorkspaceId != nil {
		var workspaceId storage.SubResource_STATUS
		err := workspace.WorkspaceId.AssignProperties_To_SubResource_STATUS(&workspaceId)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field WorkspaceId")
		}
		destination.WorkspaceId = &workspaceId
	} else {
		destination.WorkspaceId = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Possible intrusion detection bypass traffic protocols.
// +kubebuilder:validation:Enum={"ANY","ICMP","TCP","UDP"}
type FirewallPolicyIntrusionDetectionBypassTrafficProtocol string

const (
	FirewallPolicyIntrusionDetectionBypassTrafficProtocol_ANY  = FirewallPolicyIntrusionDetectionBypassTrafficProtocol("ANY")
	FirewallPolicyIntrusionDetectionBypassTrafficProtocol_ICMP = FirewallPolicyIntrusionDetectionBypassTrafficProtocol("ICMP")
	FirewallPolicyIntrusionDetectionBypassTrafficProtocol_TCP  = FirewallPolicyIntrusionDetectionBypassTrafficProtocol("TCP")
	FirewallPolicyIntrusionDetectionBypassTrafficProtocol_UDP  = FirewallPolicyIntrusionDetectionBypassTrafficProtocol("UDP")
)

// Mapping from string to FirewallPolicyIntrusionDetectionBypassTrafficProtocol
var firewallPolicyIntrusionDetectionBypassTrafficProtocol_Values = map[string]FirewallPolicyIntrusionDetectionBypassTrafficProtocol{
	"any":  FirewallPolicyIntrusionDetectionBypassTrafficProtocol_ANY,
	"icmp": FirewallPolicyIntrusionDetectionBypassTrafficProtocol_ICMP,
	"tcp":  FirewallPolicyIntrusionDetectionBypassTrafficProtocol_TCP,
	"udp":  FirewallPolicyIntrusionDetectionBypassTrafficProtocol_UDP,
}

// Possible intrusion detection bypass traffic protocols.
type FirewallPolicyIntrusionDetectionBypassTrafficProtocol_STATUS string

const (
	FirewallPolicyIntrusionDetectionBypassTrafficProtocol_STATUS_ANY  = FirewallPolicyIntrusionDetectionBypassTrafficProtocol_STATUS("ANY")
	FirewallPolicyIntrusionDetectionBypassTrafficProtocol_STATUS_ICMP = FirewallPolicyIntrusionDetectionBypassTrafficProtocol_STATUS("ICMP")
	FirewallPolicyIntrusionDetectionBypassTrafficProtocol_STATUS_TCP  = FirewallPolicyIntrusionDetectionBypassTrafficProtocol_STATUS("TCP")
	FirewallPolicyIntrusionDetectionBypassTrafficProtocol_STATUS_UDP  = FirewallPolicyIntrusionDetectionBypassTrafficProtocol_STATUS("UDP")
)

// Mapping from string to FirewallPolicyIntrusionDetectionBypassTrafficProtocol_STATUS
var firewallPolicyIntrusionDetectionBypassTrafficProtocol_STATUS_Values = map[string]FirewallPolicyIntrusionDetectionBypassTrafficProtocol_STATUS{
	"any":  FirewallPolicyIntrusionDetectionBypassTrafficProtocol_STATUS_ANY,
	"icmp": FirewallPolicyIntrusionDetectionBypassTrafficProtocol_STATUS_ICMP,
	"tcp":  FirewallPolicyIntrusionDetectionBypassTrafficProtocol_STATUS_TCP,
	"udp":  FirewallPolicyIntrusionDetectionBypassTrafficProtocol_STATUS_UDP,
}

func init() {
	SchemeBuilder.Register(&FirewallPolicy{}, &FirewallPolicyList{})
}
