// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240301

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/network/v1api20240301/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/network/v1api20240301/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:resource:categories={azure,network}
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /network/resource-manager/Microsoft.Network/stable/2024-03-01/azureFirewall.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/azureFirewalls/{azureFirewallName}
type AzureFirewall struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              AzureFirewall_Spec   `json:"spec,omitempty"`
	Status            AzureFirewall_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &AzureFirewall{}

// GetConditions returns the conditions of the resource
func (firewall *AzureFirewall) GetConditions() conditions.Conditions {
	return firewall.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (firewall *AzureFirewall) SetConditions(conditions conditions.Conditions) {
	firewall.Status.Conditions = conditions
}

var _ conversion.Convertible = &AzureFirewall{}

// ConvertFrom populates our AzureFirewall from the provided hub AzureFirewall
func (firewall *AzureFirewall) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.AzureFirewall)
	if !ok {
		return fmt.Errorf("expected network/v1api20240301/storage/AzureFirewall but received %T instead", hub)
	}

	return firewall.AssignProperties_From_AzureFirewall(source)
}

// ConvertTo populates the provided hub AzureFirewall from our AzureFirewall
func (firewall *AzureFirewall) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.AzureFirewall)
	if !ok {
		return fmt.Errorf("expected network/v1api20240301/storage/AzureFirewall but received %T instead", hub)
	}

	return firewall.AssignProperties_To_AzureFirewall(destination)
}

var _ configmaps.Exporter = &AzureFirewall{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (firewall *AzureFirewall) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if firewall.Spec.OperatorSpec == nil {
		return nil
	}
	return firewall.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &AzureFirewall{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (firewall *AzureFirewall) SecretDestinationExpressions() []*core.DestinationExpression {
	if firewall.Spec.OperatorSpec == nil {
		return nil
	}
	return firewall.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &AzureFirewall{}

// InitializeSpec initializes the spec for this resource from the given status
func (firewall *AzureFirewall) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*AzureFirewall_STATUS); ok {
		return firewall.Spec.Initialize_From_AzureFirewall_STATUS(s)
	}

	return fmt.Errorf("expected Status of type AzureFirewall_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &AzureFirewall{}

// AzureName returns the Azure name of the resource
func (firewall *AzureFirewall) AzureName() string {
	return firewall.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2024-03-01"
func (firewall AzureFirewall) GetAPIVersion() string {
	return "2024-03-01"
}

// GetResourceScope returns the scope of the resource
func (firewall *AzureFirewall) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (firewall *AzureFirewall) GetSpec() genruntime.ConvertibleSpec {
	return &firewall.Spec
}

// GetStatus returns the status of this resource
func (firewall *AzureFirewall) GetStatus() genruntime.ConvertibleStatus {
	return &firewall.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (firewall *AzureFirewall) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Network/azureFirewalls"
func (firewall *AzureFirewall) GetType() string {
	return "Microsoft.Network/azureFirewalls"
}

// NewEmptyStatus returns a new empty (blank) status
func (firewall *AzureFirewall) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &AzureFirewall_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (firewall *AzureFirewall) Owner() *genruntime.ResourceReference {
	if firewall.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(firewall.Spec)
	return firewall.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (firewall *AzureFirewall) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*AzureFirewall_STATUS); ok {
		firewall.Status = *st
		return nil
	}

	// Convert status to required version
	var st AzureFirewall_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	firewall.Status = st
	return nil
}

// AssignProperties_From_AzureFirewall populates our AzureFirewall from the provided source AzureFirewall
func (firewall *AzureFirewall) AssignProperties_From_AzureFirewall(source *storage.AzureFirewall) error {

	// ObjectMeta
	firewall.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec AzureFirewall_Spec
	err := spec.AssignProperties_From_AzureFirewall_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_AzureFirewall_Spec() to populate field Spec")
	}
	firewall.Spec = spec

	// Status
	var status AzureFirewall_STATUS
	err = status.AssignProperties_From_AzureFirewall_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_AzureFirewall_STATUS() to populate field Status")
	}
	firewall.Status = status

	// No error
	return nil
}

// AssignProperties_To_AzureFirewall populates the provided destination AzureFirewall from our AzureFirewall
func (firewall *AzureFirewall) AssignProperties_To_AzureFirewall(destination *storage.AzureFirewall) error {

	// ObjectMeta
	destination.ObjectMeta = *firewall.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.AzureFirewall_Spec
	err := firewall.Spec.AssignProperties_To_AzureFirewall_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_AzureFirewall_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.AzureFirewall_STATUS
	err = firewall.Status.AssignProperties_To_AzureFirewall_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_AzureFirewall_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (firewall *AzureFirewall) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: firewall.Spec.OriginalVersion(),
		Kind:    "AzureFirewall",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /network/resource-manager/Microsoft.Network/stable/2024-03-01/azureFirewall.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/azureFirewalls/{azureFirewallName}
type AzureFirewallList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []AzureFirewall `json:"items"`
}

// +kubebuilder:validation:Enum={"2024-03-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2024-03-01")

type AzureFirewall_Spec struct {
	// AdditionalProperties: The additional properties used to further config this azure firewall.
	AdditionalProperties map[string]string `json:"additionalProperties,omitempty"`

	// ApplicationRuleCollections: Collection of application rule collections used by Azure Firewall.
	ApplicationRuleCollections []AzureFirewallApplicationRuleCollection `json:"applicationRuleCollections,omitempty"`

	// AutoscaleConfiguration: Properties to provide a custom autoscale configuration to this azure firewall.
	AutoscaleConfiguration *AzureFirewallAutoscaleConfiguration `json:"autoscaleConfiguration,omitempty"`

	// +kubebuilder:validation:MaxLength=56
	// +kubebuilder:validation:MinLength=1
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// FirewallPolicy: The firewallPolicy associated with this azure firewall.
	FirewallPolicy *SubResource `json:"firewallPolicy,omitempty"`

	// HubIPAddresses: IP addresses associated with AzureFirewall.
	HubIPAddresses *HubIPAddresses `json:"hubIPAddresses,omitempty"`

	// IpConfigurations: IP configuration of the Azure Firewall resource.
	IpConfigurations []AzureFirewallIPConfiguration `json:"ipConfigurations,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// ManagementIpConfiguration: IP configuration of the Azure Firewall used for management traffic.
	ManagementIpConfiguration *AzureFirewallIPConfiguration `json:"managementIpConfiguration,omitempty"`

	// NatRuleCollections: Collection of NAT rule collections used by Azure Firewall.
	NatRuleCollections []AzureFirewallNatRuleCollection `json:"natRuleCollections,omitempty"`

	// NetworkRuleCollections: Collection of network rule collections used by Azure Firewall.
	NetworkRuleCollections []AzureFirewallNetworkRuleCollection `json:"networkRuleCollections,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *AzureFirewallOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// Sku: The Azure Firewall Resource SKU.
	Sku *AzureFirewallSku `json:"sku,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// ThreatIntelMode: The operation mode for Threat Intelligence.
	ThreatIntelMode *AzureFirewallThreatIntelMode `json:"threatIntelMode,omitempty"`

	// VirtualHub: The virtualHub to which the firewall belongs.
	VirtualHub *SubResource `json:"virtualHub,omitempty"`

	// Zones: A list of availability zones denoting where the resource needs to come from.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureFirewall_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (firewall *AzureFirewall_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if firewall == nil {
		return nil, nil
	}
	result := &arm.AzureFirewall_Spec{}

	// Set property "Location":
	if firewall.Location != nil {
		location := *firewall.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if firewall.AdditionalProperties != nil ||
		firewall.ApplicationRuleCollections != nil ||
		firewall.AutoscaleConfiguration != nil ||
		firewall.FirewallPolicy != nil ||
		firewall.HubIPAddresses != nil ||
		firewall.IpConfigurations != nil ||
		firewall.ManagementIpConfiguration != nil ||
		firewall.NatRuleCollections != nil ||
		firewall.NetworkRuleCollections != nil ||
		firewall.Sku != nil ||
		firewall.ThreatIntelMode != nil ||
		firewall.VirtualHub != nil {
		result.Properties = &arm.AzureFirewallPropertiesFormat{}
	}
	if firewall.AdditionalProperties != nil {
		result.Properties.AdditionalProperties = make(map[string]string, len(firewall.AdditionalProperties))
		for key, value := range firewall.AdditionalProperties {
			result.Properties.AdditionalProperties[key] = value
		}
	}
	for _, item := range firewall.ApplicationRuleCollections {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.ApplicationRuleCollections = append(result.Properties.ApplicationRuleCollections, *item_ARM.(*arm.AzureFirewallApplicationRuleCollection))
	}
	if firewall.AutoscaleConfiguration != nil {
		autoscaleConfiguration_ARM, err := (*firewall.AutoscaleConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		autoscaleConfiguration := *autoscaleConfiguration_ARM.(*arm.AzureFirewallAutoscaleConfiguration)
		result.Properties.AutoscaleConfiguration = &autoscaleConfiguration
	}
	if firewall.FirewallPolicy != nil {
		firewallPolicy_ARM, err := (*firewall.FirewallPolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		firewallPolicy := *firewallPolicy_ARM.(*arm.SubResource)
		result.Properties.FirewallPolicy = &firewallPolicy
	}
	if firewall.HubIPAddresses != nil {
		hubIPAddresses_ARM, err := (*firewall.HubIPAddresses).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		hubIPAddresses := *hubIPAddresses_ARM.(*arm.HubIPAddresses)
		result.Properties.HubIPAddresses = &hubIPAddresses
	}
	for _, item := range firewall.IpConfigurations {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.IpConfigurations = append(result.Properties.IpConfigurations, *item_ARM.(*arm.AzureFirewallIPConfiguration))
	}
	if firewall.ManagementIpConfiguration != nil {
		managementIpConfiguration_ARM, err := (*firewall.ManagementIpConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		managementIpConfiguration := *managementIpConfiguration_ARM.(*arm.AzureFirewallIPConfiguration)
		result.Properties.ManagementIpConfiguration = &managementIpConfiguration
	}
	for _, item := range firewall.NatRuleCollections {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.NatRuleCollections = append(result.Properties.NatRuleCollections, *item_ARM.(*arm.AzureFirewallNatRuleCollection))
	}
	for _, item := range firewall.NetworkRuleCollections {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.NetworkRuleCollections = append(result.Properties.NetworkRuleCollections, *item_ARM.(*arm.AzureFirewallNetworkRuleCollection))
	}
	if firewall.Sku != nil {
		sku_ARM, err := (*firewall.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *sku_ARM.(*arm.AzureFirewallSku)
		result.Properties.Sku = &sku
	}
	if firewall.ThreatIntelMode != nil {
		var temp string
		temp = string(*firewall.ThreatIntelMode)
		threatIntelMode := arm.AzureFirewallThreatIntelMode(temp)
		result.Properties.ThreatIntelMode = &threatIntelMode
	}
	if firewall.VirtualHub != nil {
		virtualHub_ARM, err := (*firewall.VirtualHub).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		virtualHub := *virtualHub_ARM.(*arm.SubResource)
		result.Properties.VirtualHub = &virtualHub
	}

	// Set property "Tags":
	if firewall.Tags != nil {
		result.Tags = make(map[string]string, len(firewall.Tags))
		for key, value := range firewall.Tags {
			result.Tags[key] = value
		}
	}

	// Set property "Zones":
	for _, item := range firewall.Zones {
		result.Zones = append(result.Zones, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (firewall *AzureFirewall_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureFirewall_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (firewall *AzureFirewall_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureFirewall_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureFirewall_Spec, got %T", armInput)
	}

	// Set property "AdditionalProperties":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AdditionalProperties != nil {
			firewall.AdditionalProperties = make(map[string]string, len(typedInput.Properties.AdditionalProperties))
			for key, value := range typedInput.Properties.AdditionalProperties {
				firewall.AdditionalProperties[key] = value
			}
		}
	}

	// Set property "ApplicationRuleCollections":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationRuleCollections {
			var item1 AzureFirewallApplicationRuleCollection
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			firewall.ApplicationRuleCollections = append(firewall.ApplicationRuleCollections, item1)
		}
	}

	// Set property "AutoscaleConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoscaleConfiguration != nil {
			var autoscaleConfiguration1 AzureFirewallAutoscaleConfiguration
			err := autoscaleConfiguration1.PopulateFromARM(owner, *typedInput.Properties.AutoscaleConfiguration)
			if err != nil {
				return err
			}
			autoscaleConfiguration := autoscaleConfiguration1
			firewall.AutoscaleConfiguration = &autoscaleConfiguration
		}
	}

	// Set property "AzureName":
	firewall.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "FirewallPolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FirewallPolicy != nil {
			var firewallPolicy1 SubResource
			err := firewallPolicy1.PopulateFromARM(owner, *typedInput.Properties.FirewallPolicy)
			if err != nil {
				return err
			}
			firewallPolicy := firewallPolicy1
			firewall.FirewallPolicy = &firewallPolicy
		}
	}

	// Set property "HubIPAddresses":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HubIPAddresses != nil {
			var hubIPAddresses1 HubIPAddresses
			err := hubIPAddresses1.PopulateFromARM(owner, *typedInput.Properties.HubIPAddresses)
			if err != nil {
				return err
			}
			hubIPAddresses := hubIPAddresses1
			firewall.HubIPAddresses = &hubIPAddresses
		}
	}

	// Set property "IpConfigurations":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpConfigurations {
			var item1 AzureFirewallIPConfiguration
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			firewall.IpConfigurations = append(firewall.IpConfigurations, item1)
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		firewall.Location = &location
	}

	// Set property "ManagementIpConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ManagementIpConfiguration != nil {
			var managementIpConfiguration1 AzureFirewallIPConfiguration
			err := managementIpConfiguration1.PopulateFromARM(owner, *typedInput.Properties.ManagementIpConfiguration)
			if err != nil {
				return err
			}
			managementIpConfiguration := managementIpConfiguration1
			firewall.ManagementIpConfiguration = &managementIpConfiguration
		}
	}

	// Set property "NatRuleCollections":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.NatRuleCollections {
			var item1 AzureFirewallNatRuleCollection
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			firewall.NatRuleCollections = append(firewall.NatRuleCollections, item1)
		}
	}

	// Set property "NetworkRuleCollections":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.NetworkRuleCollections {
			var item1 AzureFirewallNetworkRuleCollection
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			firewall.NetworkRuleCollections = append(firewall.NetworkRuleCollections, item1)
		}
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	firewall.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Sku":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Sku != nil {
			var sku1 AzureFirewallSku
			err := sku1.PopulateFromARM(owner, *typedInput.Properties.Sku)
			if err != nil {
				return err
			}
			sku := sku1
			firewall.Sku = &sku
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		firewall.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			firewall.Tags[key] = value
		}
	}

	// Set property "ThreatIntelMode":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ThreatIntelMode != nil {
			var temp string
			temp = string(*typedInput.Properties.ThreatIntelMode)
			threatIntelMode := AzureFirewallThreatIntelMode(temp)
			firewall.ThreatIntelMode = &threatIntelMode
		}
	}

	// Set property "VirtualHub":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VirtualHub != nil {
			var virtualHub1 SubResource
			err := virtualHub1.PopulateFromARM(owner, *typedInput.Properties.VirtualHub)
			if err != nil {
				return err
			}
			virtualHub := virtualHub1
			firewall.VirtualHub = &virtualHub
		}
	}

	// Set property "Zones":
	for _, item := range typedInput.Zones {
		firewall.Zones = append(firewall.Zones, item)
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &AzureFirewall_Spec{}

// ConvertSpecFrom populates our AzureFirewall_Spec from the provided source
func (firewall *AzureFirewall_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.AzureFirewall_Spec)
	if ok {
		// Populate our instance from source
		return firewall.AssignProperties_From_AzureFirewall_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.AzureFirewall_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = firewall.AssignProperties_From_AzureFirewall_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our AzureFirewall_Spec
func (firewall *AzureFirewall_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.AzureFirewall_Spec)
	if ok {
		// Populate destination from our instance
		return firewall.AssignProperties_To_AzureFirewall_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.AzureFirewall_Spec{}
	err := firewall.AssignProperties_To_AzureFirewall_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_AzureFirewall_Spec populates our AzureFirewall_Spec from the provided source AzureFirewall_Spec
func (firewall *AzureFirewall_Spec) AssignProperties_From_AzureFirewall_Spec(source *storage.AzureFirewall_Spec) error {

	// AdditionalProperties
	firewall.AdditionalProperties = genruntime.CloneMapOfStringToString(source.AdditionalProperties)

	// ApplicationRuleCollections
	if source.ApplicationRuleCollections != nil {
		applicationRuleCollectionList := make([]AzureFirewallApplicationRuleCollection, len(source.ApplicationRuleCollections))
		for applicationRuleCollectionIndex, applicationRuleCollectionItem := range source.ApplicationRuleCollections {
			// Shadow the loop variable to avoid aliasing
			applicationRuleCollectionItem := applicationRuleCollectionItem
			var applicationRuleCollection AzureFirewallApplicationRuleCollection
			err := applicationRuleCollection.AssignProperties_From_AzureFirewallApplicationRuleCollection(&applicationRuleCollectionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_AzureFirewallApplicationRuleCollection() to populate field ApplicationRuleCollections")
			}
			applicationRuleCollectionList[applicationRuleCollectionIndex] = applicationRuleCollection
		}
		firewall.ApplicationRuleCollections = applicationRuleCollectionList
	} else {
		firewall.ApplicationRuleCollections = nil
	}

	// AutoscaleConfiguration
	if source.AutoscaleConfiguration != nil {
		var autoscaleConfiguration AzureFirewallAutoscaleConfiguration
		err := autoscaleConfiguration.AssignProperties_From_AzureFirewallAutoscaleConfiguration(source.AutoscaleConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureFirewallAutoscaleConfiguration() to populate field AutoscaleConfiguration")
		}
		firewall.AutoscaleConfiguration = &autoscaleConfiguration
	} else {
		firewall.AutoscaleConfiguration = nil
	}

	// AzureName
	firewall.AzureName = source.AzureName

	// FirewallPolicy
	if source.FirewallPolicy != nil {
		var firewallPolicy SubResource
		err := firewallPolicy.AssignProperties_From_SubResource(source.FirewallPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SubResource() to populate field FirewallPolicy")
		}
		firewall.FirewallPolicy = &firewallPolicy
	} else {
		firewall.FirewallPolicy = nil
	}

	// HubIPAddresses
	if source.HubIPAddresses != nil {
		var hubIPAddress HubIPAddresses
		err := hubIPAddress.AssignProperties_From_HubIPAddresses(source.HubIPAddresses)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_HubIPAddresses() to populate field HubIPAddresses")
		}
		firewall.HubIPAddresses = &hubIPAddress
	} else {
		firewall.HubIPAddresses = nil
	}

	// IpConfigurations
	if source.IpConfigurations != nil {
		ipConfigurationList := make([]AzureFirewallIPConfiguration, len(source.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration AzureFirewallIPConfiguration
			err := ipConfiguration.AssignProperties_From_AzureFirewallIPConfiguration(&ipConfigurationItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_AzureFirewallIPConfiguration() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		firewall.IpConfigurations = ipConfigurationList
	} else {
		firewall.IpConfigurations = nil
	}

	// Location
	firewall.Location = genruntime.ClonePointerToString(source.Location)

	// ManagementIpConfiguration
	if source.ManagementIpConfiguration != nil {
		var managementIpConfiguration AzureFirewallIPConfiguration
		err := managementIpConfiguration.AssignProperties_From_AzureFirewallIPConfiguration(source.ManagementIpConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureFirewallIPConfiguration() to populate field ManagementIpConfiguration")
		}
		firewall.ManagementIpConfiguration = &managementIpConfiguration
	} else {
		firewall.ManagementIpConfiguration = nil
	}

	// NatRuleCollections
	if source.NatRuleCollections != nil {
		natRuleCollectionList := make([]AzureFirewallNatRuleCollection, len(source.NatRuleCollections))
		for natRuleCollectionIndex, natRuleCollectionItem := range source.NatRuleCollections {
			// Shadow the loop variable to avoid aliasing
			natRuleCollectionItem := natRuleCollectionItem
			var natRuleCollection AzureFirewallNatRuleCollection
			err := natRuleCollection.AssignProperties_From_AzureFirewallNatRuleCollection(&natRuleCollectionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_AzureFirewallNatRuleCollection() to populate field NatRuleCollections")
			}
			natRuleCollectionList[natRuleCollectionIndex] = natRuleCollection
		}
		firewall.NatRuleCollections = natRuleCollectionList
	} else {
		firewall.NatRuleCollections = nil
	}

	// NetworkRuleCollections
	if source.NetworkRuleCollections != nil {
		networkRuleCollectionList := make([]AzureFirewallNetworkRuleCollection, len(source.NetworkRuleCollections))
		for networkRuleCollectionIndex, networkRuleCollectionItem := range source.NetworkRuleCollections {
			// Shadow the loop variable to avoid aliasing
			networkRuleCollectionItem := networkRuleCollectionItem
			var networkRuleCollection AzureFirewallNetworkRuleCollection
			err := networkRuleCollection.AssignProperties_From_AzureFirewallNetworkRuleCollection(&networkRuleCollectionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_AzureFirewallNetworkRuleCollection() to populate field NetworkRuleCollections")
			}
			networkRuleCollectionList[networkRuleCollectionIndex] = networkRuleCollection
		}
		firewall.NetworkRuleCollections = networkRuleCollectionList
	} else {
		firewall.NetworkRuleCollections = nil
	}

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec AzureFirewallOperatorSpec
		err := operatorSpec.AssignProperties_From_AzureFirewallOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureFirewallOperatorSpec() to populate field OperatorSpec")
		}
		firewall.OperatorSpec = &operatorSpec
	} else {
		firewall.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		firewall.Owner = &owner
	} else {
		firewall.Owner = nil
	}

	// Sku
	if source.Sku != nil {
		var sku AzureFirewallSku
		err := sku.AssignProperties_From_AzureFirewallSku(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureFirewallSku() to populate field Sku")
		}
		firewall.Sku = &sku
	} else {
		firewall.Sku = nil
	}

	// Tags
	firewall.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// ThreatIntelMode
	if source.ThreatIntelMode != nil {
		threatIntelMode := *source.ThreatIntelMode
		threatIntelModeTemp := genruntime.ToEnum(threatIntelMode, azureFirewallThreatIntelMode_Values)
		firewall.ThreatIntelMode = &threatIntelModeTemp
	} else {
		firewall.ThreatIntelMode = nil
	}

	// VirtualHub
	if source.VirtualHub != nil {
		var virtualHub SubResource
		err := virtualHub.AssignProperties_From_SubResource(source.VirtualHub)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SubResource() to populate field VirtualHub")
		}
		firewall.VirtualHub = &virtualHub
	} else {
		firewall.VirtualHub = nil
	}

	// Zones
	firewall.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignProperties_To_AzureFirewall_Spec populates the provided destination AzureFirewall_Spec from our AzureFirewall_Spec
func (firewall *AzureFirewall_Spec) AssignProperties_To_AzureFirewall_Spec(destination *storage.AzureFirewall_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalProperties
	destination.AdditionalProperties = genruntime.CloneMapOfStringToString(firewall.AdditionalProperties)

	// ApplicationRuleCollections
	if firewall.ApplicationRuleCollections != nil {
		applicationRuleCollectionList := make([]storage.AzureFirewallApplicationRuleCollection, len(firewall.ApplicationRuleCollections))
		for applicationRuleCollectionIndex, applicationRuleCollectionItem := range firewall.ApplicationRuleCollections {
			// Shadow the loop variable to avoid aliasing
			applicationRuleCollectionItem := applicationRuleCollectionItem
			var applicationRuleCollection storage.AzureFirewallApplicationRuleCollection
			err := applicationRuleCollectionItem.AssignProperties_To_AzureFirewallApplicationRuleCollection(&applicationRuleCollection)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_AzureFirewallApplicationRuleCollection() to populate field ApplicationRuleCollections")
			}
			applicationRuleCollectionList[applicationRuleCollectionIndex] = applicationRuleCollection
		}
		destination.ApplicationRuleCollections = applicationRuleCollectionList
	} else {
		destination.ApplicationRuleCollections = nil
	}

	// AutoscaleConfiguration
	if firewall.AutoscaleConfiguration != nil {
		var autoscaleConfiguration storage.AzureFirewallAutoscaleConfiguration
		err := firewall.AutoscaleConfiguration.AssignProperties_To_AzureFirewallAutoscaleConfiguration(&autoscaleConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureFirewallAutoscaleConfiguration() to populate field AutoscaleConfiguration")
		}
		destination.AutoscaleConfiguration = &autoscaleConfiguration
	} else {
		destination.AutoscaleConfiguration = nil
	}

	// AzureName
	destination.AzureName = firewall.AzureName

	// FirewallPolicy
	if firewall.FirewallPolicy != nil {
		var firewallPolicy storage.SubResource
		err := firewall.FirewallPolicy.AssignProperties_To_SubResource(&firewallPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SubResource() to populate field FirewallPolicy")
		}
		destination.FirewallPolicy = &firewallPolicy
	} else {
		destination.FirewallPolicy = nil
	}

	// HubIPAddresses
	if firewall.HubIPAddresses != nil {
		var hubIPAddress storage.HubIPAddresses
		err := firewall.HubIPAddresses.AssignProperties_To_HubIPAddresses(&hubIPAddress)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_HubIPAddresses() to populate field HubIPAddresses")
		}
		destination.HubIPAddresses = &hubIPAddress
	} else {
		destination.HubIPAddresses = nil
	}

	// IpConfigurations
	if firewall.IpConfigurations != nil {
		ipConfigurationList := make([]storage.AzureFirewallIPConfiguration, len(firewall.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range firewall.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration storage.AzureFirewallIPConfiguration
			err := ipConfigurationItem.AssignProperties_To_AzureFirewallIPConfiguration(&ipConfiguration)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_AzureFirewallIPConfiguration() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		destination.IpConfigurations = ipConfigurationList
	} else {
		destination.IpConfigurations = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(firewall.Location)

	// ManagementIpConfiguration
	if firewall.ManagementIpConfiguration != nil {
		var managementIpConfiguration storage.AzureFirewallIPConfiguration
		err := firewall.ManagementIpConfiguration.AssignProperties_To_AzureFirewallIPConfiguration(&managementIpConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureFirewallIPConfiguration() to populate field ManagementIpConfiguration")
		}
		destination.ManagementIpConfiguration = &managementIpConfiguration
	} else {
		destination.ManagementIpConfiguration = nil
	}

	// NatRuleCollections
	if firewall.NatRuleCollections != nil {
		natRuleCollectionList := make([]storage.AzureFirewallNatRuleCollection, len(firewall.NatRuleCollections))
		for natRuleCollectionIndex, natRuleCollectionItem := range firewall.NatRuleCollections {
			// Shadow the loop variable to avoid aliasing
			natRuleCollectionItem := natRuleCollectionItem
			var natRuleCollection storage.AzureFirewallNatRuleCollection
			err := natRuleCollectionItem.AssignProperties_To_AzureFirewallNatRuleCollection(&natRuleCollection)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_AzureFirewallNatRuleCollection() to populate field NatRuleCollections")
			}
			natRuleCollectionList[natRuleCollectionIndex] = natRuleCollection
		}
		destination.NatRuleCollections = natRuleCollectionList
	} else {
		destination.NatRuleCollections = nil
	}

	// NetworkRuleCollections
	if firewall.NetworkRuleCollections != nil {
		networkRuleCollectionList := make([]storage.AzureFirewallNetworkRuleCollection, len(firewall.NetworkRuleCollections))
		for networkRuleCollectionIndex, networkRuleCollectionItem := range firewall.NetworkRuleCollections {
			// Shadow the loop variable to avoid aliasing
			networkRuleCollectionItem := networkRuleCollectionItem
			var networkRuleCollection storage.AzureFirewallNetworkRuleCollection
			err := networkRuleCollectionItem.AssignProperties_To_AzureFirewallNetworkRuleCollection(&networkRuleCollection)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_AzureFirewallNetworkRuleCollection() to populate field NetworkRuleCollections")
			}
			networkRuleCollectionList[networkRuleCollectionIndex] = networkRuleCollection
		}
		destination.NetworkRuleCollections = networkRuleCollectionList
	} else {
		destination.NetworkRuleCollections = nil
	}

	// OperatorSpec
	if firewall.OperatorSpec != nil {
		var operatorSpec storage.AzureFirewallOperatorSpec
		err := firewall.OperatorSpec.AssignProperties_To_AzureFirewallOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureFirewallOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = firewall.OriginalVersion()

	// Owner
	if firewall.Owner != nil {
		owner := firewall.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Sku
	if firewall.Sku != nil {
		var sku storage.AzureFirewallSku
		err := firewall.Sku.AssignProperties_To_AzureFirewallSku(&sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureFirewallSku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(firewall.Tags)

	// ThreatIntelMode
	if firewall.ThreatIntelMode != nil {
		threatIntelMode := string(*firewall.ThreatIntelMode)
		destination.ThreatIntelMode = &threatIntelMode
	} else {
		destination.ThreatIntelMode = nil
	}

	// VirtualHub
	if firewall.VirtualHub != nil {
		var virtualHub storage.SubResource
		err := firewall.VirtualHub.AssignProperties_To_SubResource(&virtualHub)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SubResource() to populate field VirtualHub")
		}
		destination.VirtualHub = &virtualHub
	} else {
		destination.VirtualHub = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(firewall.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AzureFirewall_STATUS populates our AzureFirewall_Spec from the provided source AzureFirewall_STATUS
func (firewall *AzureFirewall_Spec) Initialize_From_AzureFirewall_STATUS(source *AzureFirewall_STATUS) error {

	// AdditionalProperties
	firewall.AdditionalProperties = genruntime.CloneMapOfStringToString(source.AdditionalProperties)

	// ApplicationRuleCollections
	if source.ApplicationRuleCollections != nil {
		applicationRuleCollectionList := make([]AzureFirewallApplicationRuleCollection, len(source.ApplicationRuleCollections))
		for applicationRuleCollectionIndex, applicationRuleCollectionItem := range source.ApplicationRuleCollections {
			// Shadow the loop variable to avoid aliasing
			applicationRuleCollectionItem := applicationRuleCollectionItem
			var applicationRuleCollection AzureFirewallApplicationRuleCollection
			err := applicationRuleCollection.Initialize_From_AzureFirewallApplicationRuleCollection_STATUS(&applicationRuleCollectionItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_AzureFirewallApplicationRuleCollection_STATUS() to populate field ApplicationRuleCollections")
			}
			applicationRuleCollectionList[applicationRuleCollectionIndex] = applicationRuleCollection
		}
		firewall.ApplicationRuleCollections = applicationRuleCollectionList
	} else {
		firewall.ApplicationRuleCollections = nil
	}

	// AutoscaleConfiguration
	if source.AutoscaleConfiguration != nil {
		var autoscaleConfiguration AzureFirewallAutoscaleConfiguration
		err := autoscaleConfiguration.Initialize_From_AzureFirewallAutoscaleConfiguration_STATUS(source.AutoscaleConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_AzureFirewallAutoscaleConfiguration_STATUS() to populate field AutoscaleConfiguration")
		}
		firewall.AutoscaleConfiguration = &autoscaleConfiguration
	} else {
		firewall.AutoscaleConfiguration = nil
	}

	// FirewallPolicy
	if source.FirewallPolicy != nil {
		var firewallPolicy SubResource
		err := firewallPolicy.Initialize_From_SubResource_STATUS(source.FirewallPolicy)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field FirewallPolicy")
		}
		firewall.FirewallPolicy = &firewallPolicy
	} else {
		firewall.FirewallPolicy = nil
	}

	// HubIPAddresses
	if source.HubIPAddresses != nil {
		var hubIPAddress HubIPAddresses
		err := hubIPAddress.Initialize_From_HubIPAddresses_STATUS(source.HubIPAddresses)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_HubIPAddresses_STATUS() to populate field HubIPAddresses")
		}
		firewall.HubIPAddresses = &hubIPAddress
	} else {
		firewall.HubIPAddresses = nil
	}

	// IpConfigurations
	if source.IpConfigurations != nil {
		ipConfigurationList := make([]AzureFirewallIPConfiguration, len(source.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration AzureFirewallIPConfiguration
			err := ipConfiguration.Initialize_From_AzureFirewallIPConfiguration_STATUS(&ipConfigurationItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_AzureFirewallIPConfiguration_STATUS() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		firewall.IpConfigurations = ipConfigurationList
	} else {
		firewall.IpConfigurations = nil
	}

	// Location
	firewall.Location = genruntime.ClonePointerToString(source.Location)

	// ManagementIpConfiguration
	if source.ManagementIpConfiguration != nil {
		var managementIpConfiguration AzureFirewallIPConfiguration
		err := managementIpConfiguration.Initialize_From_AzureFirewallIPConfiguration_STATUS(source.ManagementIpConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_AzureFirewallIPConfiguration_STATUS() to populate field ManagementIpConfiguration")
		}
		firewall.ManagementIpConfiguration = &managementIpConfiguration
	} else {
		firewall.ManagementIpConfiguration = nil
	}

	// NatRuleCollections
	if source.NatRuleCollections != nil {
		natRuleCollectionList := make([]AzureFirewallNatRuleCollection, len(source.NatRuleCollections))
		for natRuleCollectionIndex, natRuleCollectionItem := range source.NatRuleCollections {
			// Shadow the loop variable to avoid aliasing
			natRuleCollectionItem := natRuleCollectionItem
			var natRuleCollection AzureFirewallNatRuleCollection
			err := natRuleCollection.Initialize_From_AzureFirewallNatRuleCollection_STATUS(&natRuleCollectionItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_AzureFirewallNatRuleCollection_STATUS() to populate field NatRuleCollections")
			}
			natRuleCollectionList[natRuleCollectionIndex] = natRuleCollection
		}
		firewall.NatRuleCollections = natRuleCollectionList
	} else {
		firewall.NatRuleCollections = nil
	}

	// NetworkRuleCollections
	if source.NetworkRuleCollections != nil {
		networkRuleCollectionList := make([]AzureFirewallNetworkRuleCollection, len(source.NetworkRuleCollections))
		for networkRuleCollectionIndex, networkRuleCollectionItem := range source.NetworkRuleCollections {
			// Shadow the loop variable to avoid aliasing
			networkRuleCollectionItem := networkRuleCollectionItem
			var networkRuleCollection AzureFirewallNetworkRuleCollection
			err := networkRuleCollection.Initialize_From_AzureFirewallNetworkRuleCollection_STATUS(&networkRuleCollectionItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_AzureFirewallNetworkRuleCollection_STATUS() to populate field NetworkRuleCollections")
			}
			networkRuleCollectionList[networkRuleCollectionIndex] = networkRuleCollection
		}
		firewall.NetworkRuleCollections = networkRuleCollectionList
	} else {
		firewall.NetworkRuleCollections = nil
	}

	// Sku
	if source.Sku != nil {
		var sku AzureFirewallSku
		err := sku.Initialize_From_AzureFirewallSku_STATUS(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_AzureFirewallSku_STATUS() to populate field Sku")
		}
		firewall.Sku = &sku
	} else {
		firewall.Sku = nil
	}

	// Tags
	firewall.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// ThreatIntelMode
	if source.ThreatIntelMode != nil {
		threatIntelMode := genruntime.ToEnum(string(*source.ThreatIntelMode), azureFirewallThreatIntelMode_Values)
		firewall.ThreatIntelMode = &threatIntelMode
	} else {
		firewall.ThreatIntelMode = nil
	}

	// VirtualHub
	if source.VirtualHub != nil {
		var virtualHub SubResource
		err := virtualHub.Initialize_From_SubResource_STATUS(source.VirtualHub)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field VirtualHub")
		}
		firewall.VirtualHub = &virtualHub
	} else {
		firewall.VirtualHub = nil
	}

	// Zones
	firewall.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (firewall *AzureFirewall_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (firewall *AzureFirewall_Spec) SetAzureName(azureName string) { firewall.AzureName = azureName }

// Azure Firewall resource.
type AzureFirewall_STATUS struct {
	// AdditionalProperties: The additional properties used to further config this azure firewall.
	AdditionalProperties map[string]string `json:"additionalProperties,omitempty"`

	// ApplicationRuleCollections: Collection of application rule collections used by Azure Firewall.
	ApplicationRuleCollections []AzureFirewallApplicationRuleCollection_STATUS `json:"applicationRuleCollections,omitempty"`

	// AutoscaleConfiguration: Properties to provide a custom autoscale configuration to this azure firewall.
	AutoscaleConfiguration *AzureFirewallAutoscaleConfiguration_STATUS `json:"autoscaleConfiguration,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	// FirewallPolicy: The firewallPolicy associated with this azure firewall.
	FirewallPolicy *SubResource_STATUS `json:"firewallPolicy,omitempty"`

	// HubIPAddresses: IP addresses associated with AzureFirewall.
	HubIPAddresses *HubIPAddresses_STATUS `json:"hubIPAddresses,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// IpConfigurations: IP configuration of the Azure Firewall resource.
	IpConfigurations []AzureFirewallIPConfiguration_STATUS `json:"ipConfigurations,omitempty"`

	// IpGroups: IpGroups associated with AzureFirewall.
	IpGroups []AzureFirewallIpGroups_STATUS `json:"ipGroups,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// ManagementIpConfiguration: IP configuration of the Azure Firewall used for management traffic.
	ManagementIpConfiguration *AzureFirewallIPConfiguration_STATUS `json:"managementIpConfiguration,omitempty"`

	// Name: Resource name.
	Name *string `json:"name,omitempty"`

	// NatRuleCollections: Collection of NAT rule collections used by Azure Firewall.
	NatRuleCollections []AzureFirewallNatRuleCollection_STATUS `json:"natRuleCollections,omitempty"`

	// NetworkRuleCollections: Collection of network rule collections used by Azure Firewall.
	NetworkRuleCollections []AzureFirewallNetworkRuleCollection_STATUS `json:"networkRuleCollections,omitempty"`

	// ProvisioningState: The provisioning state of the Azure firewall resource.
	ProvisioningState *ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// Sku: The Azure Firewall Resource SKU.
	Sku *AzureFirewallSku_STATUS `json:"sku,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// ThreatIntelMode: The operation mode for Threat Intelligence.
	ThreatIntelMode *AzureFirewallThreatIntelMode_STATUS `json:"threatIntelMode,omitempty"`

	// Type: Resource type.
	Type *string `json:"type,omitempty"`

	// VirtualHub: The virtualHub to which the firewall belongs.
	VirtualHub *SubResource_STATUS `json:"virtualHub,omitempty"`

	// Zones: A list of availability zones denoting where the resource needs to come from.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ConvertibleStatus = &AzureFirewall_STATUS{}

// ConvertStatusFrom populates our AzureFirewall_STATUS from the provided source
func (firewall *AzureFirewall_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.AzureFirewall_STATUS)
	if ok {
		// Populate our instance from source
		return firewall.AssignProperties_From_AzureFirewall_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.AzureFirewall_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = firewall.AssignProperties_From_AzureFirewall_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our AzureFirewall_STATUS
func (firewall *AzureFirewall_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.AzureFirewall_STATUS)
	if ok {
		// Populate destination from our instance
		return firewall.AssignProperties_To_AzureFirewall_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.AzureFirewall_STATUS{}
	err := firewall.AssignProperties_To_AzureFirewall_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &AzureFirewall_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (firewall *AzureFirewall_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureFirewall_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (firewall *AzureFirewall_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureFirewall_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureFirewall_STATUS, got %T", armInput)
	}

	// Set property "AdditionalProperties":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AdditionalProperties != nil {
			firewall.AdditionalProperties = make(map[string]string, len(typedInput.Properties.AdditionalProperties))
			for key, value := range typedInput.Properties.AdditionalProperties {
				firewall.AdditionalProperties[key] = value
			}
		}
	}

	// Set property "ApplicationRuleCollections":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationRuleCollections {
			var item1 AzureFirewallApplicationRuleCollection_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			firewall.ApplicationRuleCollections = append(firewall.ApplicationRuleCollections, item1)
		}
	}

	// Set property "AutoscaleConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoscaleConfiguration != nil {
			var autoscaleConfiguration1 AzureFirewallAutoscaleConfiguration_STATUS
			err := autoscaleConfiguration1.PopulateFromARM(owner, *typedInput.Properties.AutoscaleConfiguration)
			if err != nil {
				return err
			}
			autoscaleConfiguration := autoscaleConfiguration1
			firewall.AutoscaleConfiguration = &autoscaleConfiguration
		}
	}

	// no assignment for property "Conditions"

	// Set property "Etag":
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		firewall.Etag = &etag
	}

	// Set property "FirewallPolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FirewallPolicy != nil {
			var firewallPolicy1 SubResource_STATUS
			err := firewallPolicy1.PopulateFromARM(owner, *typedInput.Properties.FirewallPolicy)
			if err != nil {
				return err
			}
			firewallPolicy := firewallPolicy1
			firewall.FirewallPolicy = &firewallPolicy
		}
	}

	// Set property "HubIPAddresses":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HubIPAddresses != nil {
			var hubIPAddresses1 HubIPAddresses_STATUS
			err := hubIPAddresses1.PopulateFromARM(owner, *typedInput.Properties.HubIPAddresses)
			if err != nil {
				return err
			}
			hubIPAddresses := hubIPAddresses1
			firewall.HubIPAddresses = &hubIPAddresses
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		firewall.Id = &id
	}

	// Set property "IpConfigurations":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpConfigurations {
			var item1 AzureFirewallIPConfiguration_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			firewall.IpConfigurations = append(firewall.IpConfigurations, item1)
		}
	}

	// Set property "IpGroups":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpGroups {
			var item1 AzureFirewallIpGroups_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			firewall.IpGroups = append(firewall.IpGroups, item1)
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		firewall.Location = &location
	}

	// Set property "ManagementIpConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ManagementIpConfiguration != nil {
			var managementIpConfiguration1 AzureFirewallIPConfiguration_STATUS
			err := managementIpConfiguration1.PopulateFromARM(owner, *typedInput.Properties.ManagementIpConfiguration)
			if err != nil {
				return err
			}
			managementIpConfiguration := managementIpConfiguration1
			firewall.ManagementIpConfiguration = &managementIpConfiguration
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		firewall.Name = &name
	}

	// Set property "NatRuleCollections":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.NatRuleCollections {
			var item1 AzureFirewallNatRuleCollection_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			firewall.NatRuleCollections = append(firewall.NatRuleCollections, item1)
		}
	}

	// Set property "NetworkRuleCollections":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.NetworkRuleCollections {
			var item1 AzureFirewallNetworkRuleCollection_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			firewall.NetworkRuleCollections = append(firewall.NetworkRuleCollections, item1)
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			var temp string
			temp = string(*typedInput.Properties.ProvisioningState)
			provisioningState := ProvisioningState_STATUS(temp)
			firewall.ProvisioningState = &provisioningState
		}
	}

	// Set property "Sku":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Sku != nil {
			var sku1 AzureFirewallSku_STATUS
			err := sku1.PopulateFromARM(owner, *typedInput.Properties.Sku)
			if err != nil {
				return err
			}
			sku := sku1
			firewall.Sku = &sku
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		firewall.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			firewall.Tags[key] = value
		}
	}

	// Set property "ThreatIntelMode":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ThreatIntelMode != nil {
			var temp string
			temp = string(*typedInput.Properties.ThreatIntelMode)
			threatIntelMode := AzureFirewallThreatIntelMode_STATUS(temp)
			firewall.ThreatIntelMode = &threatIntelMode
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		firewall.Type = &typeVar
	}

	// Set property "VirtualHub":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VirtualHub != nil {
			var virtualHub1 SubResource_STATUS
			err := virtualHub1.PopulateFromARM(owner, *typedInput.Properties.VirtualHub)
			if err != nil {
				return err
			}
			virtualHub := virtualHub1
			firewall.VirtualHub = &virtualHub
		}
	}

	// Set property "Zones":
	for _, item := range typedInput.Zones {
		firewall.Zones = append(firewall.Zones, item)
	}

	// No error
	return nil
}

// AssignProperties_From_AzureFirewall_STATUS populates our AzureFirewall_STATUS from the provided source AzureFirewall_STATUS
func (firewall *AzureFirewall_STATUS) AssignProperties_From_AzureFirewall_STATUS(source *storage.AzureFirewall_STATUS) error {

	// AdditionalProperties
	firewall.AdditionalProperties = genruntime.CloneMapOfStringToString(source.AdditionalProperties)

	// ApplicationRuleCollections
	if source.ApplicationRuleCollections != nil {
		applicationRuleCollectionList := make([]AzureFirewallApplicationRuleCollection_STATUS, len(source.ApplicationRuleCollections))
		for applicationRuleCollectionIndex, applicationRuleCollectionItem := range source.ApplicationRuleCollections {
			// Shadow the loop variable to avoid aliasing
			applicationRuleCollectionItem := applicationRuleCollectionItem
			var applicationRuleCollection AzureFirewallApplicationRuleCollection_STATUS
			err := applicationRuleCollection.AssignProperties_From_AzureFirewallApplicationRuleCollection_STATUS(&applicationRuleCollectionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_AzureFirewallApplicationRuleCollection_STATUS() to populate field ApplicationRuleCollections")
			}
			applicationRuleCollectionList[applicationRuleCollectionIndex] = applicationRuleCollection
		}
		firewall.ApplicationRuleCollections = applicationRuleCollectionList
	} else {
		firewall.ApplicationRuleCollections = nil
	}

	// AutoscaleConfiguration
	if source.AutoscaleConfiguration != nil {
		var autoscaleConfiguration AzureFirewallAutoscaleConfiguration_STATUS
		err := autoscaleConfiguration.AssignProperties_From_AzureFirewallAutoscaleConfiguration_STATUS(source.AutoscaleConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureFirewallAutoscaleConfiguration_STATUS() to populate field AutoscaleConfiguration")
		}
		firewall.AutoscaleConfiguration = &autoscaleConfiguration
	} else {
		firewall.AutoscaleConfiguration = nil
	}

	// Conditions
	firewall.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Etag
	firewall.Etag = genruntime.ClonePointerToString(source.Etag)

	// FirewallPolicy
	if source.FirewallPolicy != nil {
		var firewallPolicy SubResource_STATUS
		err := firewallPolicy.AssignProperties_From_SubResource_STATUS(source.FirewallPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field FirewallPolicy")
		}
		firewall.FirewallPolicy = &firewallPolicy
	} else {
		firewall.FirewallPolicy = nil
	}

	// HubIPAddresses
	if source.HubIPAddresses != nil {
		var hubIPAddress HubIPAddresses_STATUS
		err := hubIPAddress.AssignProperties_From_HubIPAddresses_STATUS(source.HubIPAddresses)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_HubIPAddresses_STATUS() to populate field HubIPAddresses")
		}
		firewall.HubIPAddresses = &hubIPAddress
	} else {
		firewall.HubIPAddresses = nil
	}

	// Id
	firewall.Id = genruntime.ClonePointerToString(source.Id)

	// IpConfigurations
	if source.IpConfigurations != nil {
		ipConfigurationList := make([]AzureFirewallIPConfiguration_STATUS, len(source.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration AzureFirewallIPConfiguration_STATUS
			err := ipConfiguration.AssignProperties_From_AzureFirewallIPConfiguration_STATUS(&ipConfigurationItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_AzureFirewallIPConfiguration_STATUS() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		firewall.IpConfigurations = ipConfigurationList
	} else {
		firewall.IpConfigurations = nil
	}

	// IpGroups
	if source.IpGroups != nil {
		ipGroupList := make([]AzureFirewallIpGroups_STATUS, len(source.IpGroups))
		for ipGroupIndex, ipGroupItem := range source.IpGroups {
			// Shadow the loop variable to avoid aliasing
			ipGroupItem := ipGroupItem
			var ipGroup AzureFirewallIpGroups_STATUS
			err := ipGroup.AssignProperties_From_AzureFirewallIpGroups_STATUS(&ipGroupItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_AzureFirewallIpGroups_STATUS() to populate field IpGroups")
			}
			ipGroupList[ipGroupIndex] = ipGroup
		}
		firewall.IpGroups = ipGroupList
	} else {
		firewall.IpGroups = nil
	}

	// Location
	firewall.Location = genruntime.ClonePointerToString(source.Location)

	// ManagementIpConfiguration
	if source.ManagementIpConfiguration != nil {
		var managementIpConfiguration AzureFirewallIPConfiguration_STATUS
		err := managementIpConfiguration.AssignProperties_From_AzureFirewallIPConfiguration_STATUS(source.ManagementIpConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureFirewallIPConfiguration_STATUS() to populate field ManagementIpConfiguration")
		}
		firewall.ManagementIpConfiguration = &managementIpConfiguration
	} else {
		firewall.ManagementIpConfiguration = nil
	}

	// Name
	firewall.Name = genruntime.ClonePointerToString(source.Name)

	// NatRuleCollections
	if source.NatRuleCollections != nil {
		natRuleCollectionList := make([]AzureFirewallNatRuleCollection_STATUS, len(source.NatRuleCollections))
		for natRuleCollectionIndex, natRuleCollectionItem := range source.NatRuleCollections {
			// Shadow the loop variable to avoid aliasing
			natRuleCollectionItem := natRuleCollectionItem
			var natRuleCollection AzureFirewallNatRuleCollection_STATUS
			err := natRuleCollection.AssignProperties_From_AzureFirewallNatRuleCollection_STATUS(&natRuleCollectionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_AzureFirewallNatRuleCollection_STATUS() to populate field NatRuleCollections")
			}
			natRuleCollectionList[natRuleCollectionIndex] = natRuleCollection
		}
		firewall.NatRuleCollections = natRuleCollectionList
	} else {
		firewall.NatRuleCollections = nil
	}

	// NetworkRuleCollections
	if source.NetworkRuleCollections != nil {
		networkRuleCollectionList := make([]AzureFirewallNetworkRuleCollection_STATUS, len(source.NetworkRuleCollections))
		for networkRuleCollectionIndex, networkRuleCollectionItem := range source.NetworkRuleCollections {
			// Shadow the loop variable to avoid aliasing
			networkRuleCollectionItem := networkRuleCollectionItem
			var networkRuleCollection AzureFirewallNetworkRuleCollection_STATUS
			err := networkRuleCollection.AssignProperties_From_AzureFirewallNetworkRuleCollection_STATUS(&networkRuleCollectionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_AzureFirewallNetworkRuleCollection_STATUS() to populate field NetworkRuleCollections")
			}
			networkRuleCollectionList[networkRuleCollectionIndex] = networkRuleCollection
		}
		firewall.NetworkRuleCollections = networkRuleCollectionList
	} else {
		firewall.NetworkRuleCollections = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, provisioningState_STATUS_Values)
		firewall.ProvisioningState = &provisioningStateTemp
	} else {
		firewall.ProvisioningState = nil
	}

	// Sku
	if source.Sku != nil {
		var sku AzureFirewallSku_STATUS
		err := sku.AssignProperties_From_AzureFirewallSku_STATUS(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureFirewallSku_STATUS() to populate field Sku")
		}
		firewall.Sku = &sku
	} else {
		firewall.Sku = nil
	}

	// Tags
	firewall.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// ThreatIntelMode
	if source.ThreatIntelMode != nil {
		threatIntelMode := *source.ThreatIntelMode
		threatIntelModeTemp := genruntime.ToEnum(threatIntelMode, azureFirewallThreatIntelMode_STATUS_Values)
		firewall.ThreatIntelMode = &threatIntelModeTemp
	} else {
		firewall.ThreatIntelMode = nil
	}

	// Type
	firewall.Type = genruntime.ClonePointerToString(source.Type)

	// VirtualHub
	if source.VirtualHub != nil {
		var virtualHub SubResource_STATUS
		err := virtualHub.AssignProperties_From_SubResource_STATUS(source.VirtualHub)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field VirtualHub")
		}
		firewall.VirtualHub = &virtualHub
	} else {
		firewall.VirtualHub = nil
	}

	// Zones
	firewall.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignProperties_To_AzureFirewall_STATUS populates the provided destination AzureFirewall_STATUS from our AzureFirewall_STATUS
func (firewall *AzureFirewall_STATUS) AssignProperties_To_AzureFirewall_STATUS(destination *storage.AzureFirewall_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalProperties
	destination.AdditionalProperties = genruntime.CloneMapOfStringToString(firewall.AdditionalProperties)

	// ApplicationRuleCollections
	if firewall.ApplicationRuleCollections != nil {
		applicationRuleCollectionList := make([]storage.AzureFirewallApplicationRuleCollection_STATUS, len(firewall.ApplicationRuleCollections))
		for applicationRuleCollectionIndex, applicationRuleCollectionItem := range firewall.ApplicationRuleCollections {
			// Shadow the loop variable to avoid aliasing
			applicationRuleCollectionItem := applicationRuleCollectionItem
			var applicationRuleCollection storage.AzureFirewallApplicationRuleCollection_STATUS
			err := applicationRuleCollectionItem.AssignProperties_To_AzureFirewallApplicationRuleCollection_STATUS(&applicationRuleCollection)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_AzureFirewallApplicationRuleCollection_STATUS() to populate field ApplicationRuleCollections")
			}
			applicationRuleCollectionList[applicationRuleCollectionIndex] = applicationRuleCollection
		}
		destination.ApplicationRuleCollections = applicationRuleCollectionList
	} else {
		destination.ApplicationRuleCollections = nil
	}

	// AutoscaleConfiguration
	if firewall.AutoscaleConfiguration != nil {
		var autoscaleConfiguration storage.AzureFirewallAutoscaleConfiguration_STATUS
		err := firewall.AutoscaleConfiguration.AssignProperties_To_AzureFirewallAutoscaleConfiguration_STATUS(&autoscaleConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureFirewallAutoscaleConfiguration_STATUS() to populate field AutoscaleConfiguration")
		}
		destination.AutoscaleConfiguration = &autoscaleConfiguration
	} else {
		destination.AutoscaleConfiguration = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(firewall.Conditions)

	// Etag
	destination.Etag = genruntime.ClonePointerToString(firewall.Etag)

	// FirewallPolicy
	if firewall.FirewallPolicy != nil {
		var firewallPolicy storage.SubResource_STATUS
		err := firewall.FirewallPolicy.AssignProperties_To_SubResource_STATUS(&firewallPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field FirewallPolicy")
		}
		destination.FirewallPolicy = &firewallPolicy
	} else {
		destination.FirewallPolicy = nil
	}

	// HubIPAddresses
	if firewall.HubIPAddresses != nil {
		var hubIPAddress storage.HubIPAddresses_STATUS
		err := firewall.HubIPAddresses.AssignProperties_To_HubIPAddresses_STATUS(&hubIPAddress)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_HubIPAddresses_STATUS() to populate field HubIPAddresses")
		}
		destination.HubIPAddresses = &hubIPAddress
	} else {
		destination.HubIPAddresses = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(firewall.Id)

	// IpConfigurations
	if firewall.IpConfigurations != nil {
		ipConfigurationList := make([]storage.AzureFirewallIPConfiguration_STATUS, len(firewall.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range firewall.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration storage.AzureFirewallIPConfiguration_STATUS
			err := ipConfigurationItem.AssignProperties_To_AzureFirewallIPConfiguration_STATUS(&ipConfiguration)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_AzureFirewallIPConfiguration_STATUS() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		destination.IpConfigurations = ipConfigurationList
	} else {
		destination.IpConfigurations = nil
	}

	// IpGroups
	if firewall.IpGroups != nil {
		ipGroupList := make([]storage.AzureFirewallIpGroups_STATUS, len(firewall.IpGroups))
		for ipGroupIndex, ipGroupItem := range firewall.IpGroups {
			// Shadow the loop variable to avoid aliasing
			ipGroupItem := ipGroupItem
			var ipGroup storage.AzureFirewallIpGroups_STATUS
			err := ipGroupItem.AssignProperties_To_AzureFirewallIpGroups_STATUS(&ipGroup)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_AzureFirewallIpGroups_STATUS() to populate field IpGroups")
			}
			ipGroupList[ipGroupIndex] = ipGroup
		}
		destination.IpGroups = ipGroupList
	} else {
		destination.IpGroups = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(firewall.Location)

	// ManagementIpConfiguration
	if firewall.ManagementIpConfiguration != nil {
		var managementIpConfiguration storage.AzureFirewallIPConfiguration_STATUS
		err := firewall.ManagementIpConfiguration.AssignProperties_To_AzureFirewallIPConfiguration_STATUS(&managementIpConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureFirewallIPConfiguration_STATUS() to populate field ManagementIpConfiguration")
		}
		destination.ManagementIpConfiguration = &managementIpConfiguration
	} else {
		destination.ManagementIpConfiguration = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(firewall.Name)

	// NatRuleCollections
	if firewall.NatRuleCollections != nil {
		natRuleCollectionList := make([]storage.AzureFirewallNatRuleCollection_STATUS, len(firewall.NatRuleCollections))
		for natRuleCollectionIndex, natRuleCollectionItem := range firewall.NatRuleCollections {
			// Shadow the loop variable to avoid aliasing
			natRuleCollectionItem := natRuleCollectionItem
			var natRuleCollection storage.AzureFirewallNatRuleCollection_STATUS
			err := natRuleCollectionItem.AssignProperties_To_AzureFirewallNatRuleCollection_STATUS(&natRuleCollection)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_AzureFirewallNatRuleCollection_STATUS() to populate field NatRuleCollections")
			}
			natRuleCollectionList[natRuleCollectionIndex] = natRuleCollection
		}
		destination.NatRuleCollections = natRuleCollectionList
	} else {
		destination.NatRuleCollections = nil
	}

	// NetworkRuleCollections
	if firewall.NetworkRuleCollections != nil {
		networkRuleCollectionList := make([]storage.AzureFirewallNetworkRuleCollection_STATUS, len(firewall.NetworkRuleCollections))
		for networkRuleCollectionIndex, networkRuleCollectionItem := range firewall.NetworkRuleCollections {
			// Shadow the loop variable to avoid aliasing
			networkRuleCollectionItem := networkRuleCollectionItem
			var networkRuleCollection storage.AzureFirewallNetworkRuleCollection_STATUS
			err := networkRuleCollectionItem.AssignProperties_To_AzureFirewallNetworkRuleCollection_STATUS(&networkRuleCollection)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_AzureFirewallNetworkRuleCollection_STATUS() to populate field NetworkRuleCollections")
			}
			networkRuleCollectionList[networkRuleCollectionIndex] = networkRuleCollection
		}
		destination.NetworkRuleCollections = networkRuleCollectionList
	} else {
		destination.NetworkRuleCollections = nil
	}

	// ProvisioningState
	if firewall.ProvisioningState != nil {
		provisioningState := string(*firewall.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Sku
	if firewall.Sku != nil {
		var sku storage.AzureFirewallSku_STATUS
		err := firewall.Sku.AssignProperties_To_AzureFirewallSku_STATUS(&sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureFirewallSku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(firewall.Tags)

	// ThreatIntelMode
	if firewall.ThreatIntelMode != nil {
		threatIntelMode := string(*firewall.ThreatIntelMode)
		destination.ThreatIntelMode = &threatIntelMode
	} else {
		destination.ThreatIntelMode = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(firewall.Type)

	// VirtualHub
	if firewall.VirtualHub != nil {
		var virtualHub storage.SubResource_STATUS
		err := firewall.VirtualHub.AssignProperties_To_SubResource_STATUS(&virtualHub)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field VirtualHub")
		}
		destination.VirtualHub = &virtualHub
	} else {
		destination.VirtualHub = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(firewall.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Application rule collection resource.
type AzureFirewallApplicationRuleCollection struct {
	// Action: The action type of a rule collection.
	Action *AzureFirewallRCAction `json:"action,omitempty"`

	// Name: The name of the resource that is unique within the Azure firewall. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Maximum=65000
	// +kubebuilder:validation:Minimum=100
	// Priority: Priority of the application rule collection resource.
	Priority *int `json:"priority,omitempty"`

	// Rules: Collection of rules used by a application rule collection.
	Rules []AzureFirewallApplicationRule `json:"rules,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureFirewallApplicationRuleCollection{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (collection *AzureFirewallApplicationRuleCollection) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if collection == nil {
		return nil, nil
	}
	result := &arm.AzureFirewallApplicationRuleCollection{}

	// Set property "Name":
	if collection.Name != nil {
		name := *collection.Name
		result.Name = &name
	}

	// Set property "Properties":
	if collection.Action != nil ||
		collection.Priority != nil ||
		collection.Rules != nil {
		result.Properties = &arm.AzureFirewallApplicationRuleCollectionPropertiesFormat{}
	}
	if collection.Action != nil {
		action_ARM, err := (*collection.Action).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		action := *action_ARM.(*arm.AzureFirewallRCAction)
		result.Properties.Action = &action
	}
	if collection.Priority != nil {
		priority := *collection.Priority
		result.Properties.Priority = &priority
	}
	for _, item := range collection.Rules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Rules = append(result.Properties.Rules, *item_ARM.(*arm.AzureFirewallApplicationRule))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (collection *AzureFirewallApplicationRuleCollection) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureFirewallApplicationRuleCollection{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (collection *AzureFirewallApplicationRuleCollection) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureFirewallApplicationRuleCollection)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureFirewallApplicationRuleCollection, got %T", armInput)
	}

	// Set property "Action":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Action != nil {
			var action1 AzureFirewallRCAction
			err := action1.PopulateFromARM(owner, *typedInput.Properties.Action)
			if err != nil {
				return err
			}
			action := action1
			collection.Action = &action
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		collection.Name = &name
	}

	// Set property "Priority":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Priority != nil {
			priority := *typedInput.Properties.Priority
			collection.Priority = &priority
		}
	}

	// Set property "Rules":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Rules {
			var item1 AzureFirewallApplicationRule
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			collection.Rules = append(collection.Rules, item1)
		}
	}

	// No error
	return nil
}

// AssignProperties_From_AzureFirewallApplicationRuleCollection populates our AzureFirewallApplicationRuleCollection from the provided source AzureFirewallApplicationRuleCollection
func (collection *AzureFirewallApplicationRuleCollection) AssignProperties_From_AzureFirewallApplicationRuleCollection(source *storage.AzureFirewallApplicationRuleCollection) error {

	// Action
	if source.Action != nil {
		var action AzureFirewallRCAction
		err := action.AssignProperties_From_AzureFirewallRCAction(source.Action)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureFirewallRCAction() to populate field Action")
		}
		collection.Action = &action
	} else {
		collection.Action = nil
	}

	// Name
	collection.Name = genruntime.ClonePointerToString(source.Name)

	// Priority
	collection.Priority = genruntime.ClonePointerToInt(source.Priority)

	// Rules
	if source.Rules != nil {
		ruleList := make([]AzureFirewallApplicationRule, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule AzureFirewallApplicationRule
			err := rule.AssignProperties_From_AzureFirewallApplicationRule(&ruleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_AzureFirewallApplicationRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		collection.Rules = ruleList
	} else {
		collection.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureFirewallApplicationRuleCollection populates the provided destination AzureFirewallApplicationRuleCollection from our AzureFirewallApplicationRuleCollection
func (collection *AzureFirewallApplicationRuleCollection) AssignProperties_To_AzureFirewallApplicationRuleCollection(destination *storage.AzureFirewallApplicationRuleCollection) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if collection.Action != nil {
		var action storage.AzureFirewallRCAction
		err := collection.Action.AssignProperties_To_AzureFirewallRCAction(&action)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureFirewallRCAction() to populate field Action")
		}
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(collection.Name)

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(collection.Priority)

	// Rules
	if collection.Rules != nil {
		ruleList := make([]storage.AzureFirewallApplicationRule, len(collection.Rules))
		for ruleIndex, ruleItem := range collection.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule storage.AzureFirewallApplicationRule
			err := ruleItem.AssignProperties_To_AzureFirewallApplicationRule(&rule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_AzureFirewallApplicationRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AzureFirewallApplicationRuleCollection_STATUS populates our AzureFirewallApplicationRuleCollection from the provided source AzureFirewallApplicationRuleCollection_STATUS
func (collection *AzureFirewallApplicationRuleCollection) Initialize_From_AzureFirewallApplicationRuleCollection_STATUS(source *AzureFirewallApplicationRuleCollection_STATUS) error {

	// No error
	return nil
}

// Application rule collection resource.
type AzureFirewallApplicationRuleCollection_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureFirewallApplicationRuleCollection_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (collection *AzureFirewallApplicationRuleCollection_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureFirewallApplicationRuleCollection_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (collection *AzureFirewallApplicationRuleCollection_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureFirewallApplicationRuleCollection_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureFirewallApplicationRuleCollection_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		collection.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_AzureFirewallApplicationRuleCollection_STATUS populates our AzureFirewallApplicationRuleCollection_STATUS from the provided source AzureFirewallApplicationRuleCollection_STATUS
func (collection *AzureFirewallApplicationRuleCollection_STATUS) AssignProperties_From_AzureFirewallApplicationRuleCollection_STATUS(source *storage.AzureFirewallApplicationRuleCollection_STATUS) error {

	// Id
	collection.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_AzureFirewallApplicationRuleCollection_STATUS populates the provided destination AzureFirewallApplicationRuleCollection_STATUS from our AzureFirewallApplicationRuleCollection_STATUS
func (collection *AzureFirewallApplicationRuleCollection_STATUS) AssignProperties_To_AzureFirewallApplicationRuleCollection_STATUS(destination *storage.AzureFirewallApplicationRuleCollection_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(collection.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Azure Firewall Autoscale Configuration parameters.
type AzureFirewallAutoscaleConfiguration struct {
	// +kubebuilder:validation:Minimum=2
	// MaxCapacity: The maximum number of capacity units for this azure firewall. Use null to reset the value to the service
	// default.
	MaxCapacity *int `json:"maxCapacity,omitempty"`

	// +kubebuilder:validation:Minimum=2
	// MinCapacity: The minimum number of capacity units for this azure firewall. Use null to reset the value to the service
	// default.
	MinCapacity *int `json:"minCapacity,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureFirewallAutoscaleConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *AzureFirewallAutoscaleConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.AzureFirewallAutoscaleConfiguration{}

	// Set property "MaxCapacity":
	if configuration.MaxCapacity != nil {
		maxCapacity := *configuration.MaxCapacity
		result.MaxCapacity = &maxCapacity
	}

	// Set property "MinCapacity":
	if configuration.MinCapacity != nil {
		minCapacity := *configuration.MinCapacity
		result.MinCapacity = &minCapacity
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *AzureFirewallAutoscaleConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureFirewallAutoscaleConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *AzureFirewallAutoscaleConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureFirewallAutoscaleConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureFirewallAutoscaleConfiguration, got %T", armInput)
	}

	// Set property "MaxCapacity":
	if typedInput.MaxCapacity != nil {
		maxCapacity := *typedInput.MaxCapacity
		configuration.MaxCapacity = &maxCapacity
	}

	// Set property "MinCapacity":
	if typedInput.MinCapacity != nil {
		minCapacity := *typedInput.MinCapacity
		configuration.MinCapacity = &minCapacity
	}

	// No error
	return nil
}

// AssignProperties_From_AzureFirewallAutoscaleConfiguration populates our AzureFirewallAutoscaleConfiguration from the provided source AzureFirewallAutoscaleConfiguration
func (configuration *AzureFirewallAutoscaleConfiguration) AssignProperties_From_AzureFirewallAutoscaleConfiguration(source *storage.AzureFirewallAutoscaleConfiguration) error {

	// MaxCapacity
	configuration.MaxCapacity = genruntime.ClonePointerToInt(source.MaxCapacity)

	// MinCapacity
	configuration.MinCapacity = genruntime.ClonePointerToInt(source.MinCapacity)

	// No error
	return nil
}

// AssignProperties_To_AzureFirewallAutoscaleConfiguration populates the provided destination AzureFirewallAutoscaleConfiguration from our AzureFirewallAutoscaleConfiguration
func (configuration *AzureFirewallAutoscaleConfiguration) AssignProperties_To_AzureFirewallAutoscaleConfiguration(destination *storage.AzureFirewallAutoscaleConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaxCapacity
	destination.MaxCapacity = genruntime.ClonePointerToInt(configuration.MaxCapacity)

	// MinCapacity
	destination.MinCapacity = genruntime.ClonePointerToInt(configuration.MinCapacity)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AzureFirewallAutoscaleConfiguration_STATUS populates our AzureFirewallAutoscaleConfiguration from the provided source AzureFirewallAutoscaleConfiguration_STATUS
func (configuration *AzureFirewallAutoscaleConfiguration) Initialize_From_AzureFirewallAutoscaleConfiguration_STATUS(source *AzureFirewallAutoscaleConfiguration_STATUS) error {

	// MaxCapacity
	configuration.MaxCapacity = genruntime.ClonePointerToInt(source.MaxCapacity)

	// MinCapacity
	configuration.MinCapacity = genruntime.ClonePointerToInt(source.MinCapacity)

	// No error
	return nil
}

// Azure Firewall Autoscale Configuration parameters.
type AzureFirewallAutoscaleConfiguration_STATUS struct {
	// MaxCapacity: The maximum number of capacity units for this azure firewall. Use null to reset the value to the service
	// default.
	MaxCapacity *int `json:"maxCapacity,omitempty"`

	// MinCapacity: The minimum number of capacity units for this azure firewall. Use null to reset the value to the service
	// default.
	MinCapacity *int `json:"minCapacity,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureFirewallAutoscaleConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *AzureFirewallAutoscaleConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureFirewallAutoscaleConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *AzureFirewallAutoscaleConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureFirewallAutoscaleConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureFirewallAutoscaleConfiguration_STATUS, got %T", armInput)
	}

	// Set property "MaxCapacity":
	if typedInput.MaxCapacity != nil {
		maxCapacity := *typedInput.MaxCapacity
		configuration.MaxCapacity = &maxCapacity
	}

	// Set property "MinCapacity":
	if typedInput.MinCapacity != nil {
		minCapacity := *typedInput.MinCapacity
		configuration.MinCapacity = &minCapacity
	}

	// No error
	return nil
}

// AssignProperties_From_AzureFirewallAutoscaleConfiguration_STATUS populates our AzureFirewallAutoscaleConfiguration_STATUS from the provided source AzureFirewallAutoscaleConfiguration_STATUS
func (configuration *AzureFirewallAutoscaleConfiguration_STATUS) AssignProperties_From_AzureFirewallAutoscaleConfiguration_STATUS(source *storage.AzureFirewallAutoscaleConfiguration_STATUS) error {

	// MaxCapacity
	configuration.MaxCapacity = genruntime.ClonePointerToInt(source.MaxCapacity)

	// MinCapacity
	configuration.MinCapacity = genruntime.ClonePointerToInt(source.MinCapacity)

	// No error
	return nil
}

// AssignProperties_To_AzureFirewallAutoscaleConfiguration_STATUS populates the provided destination AzureFirewallAutoscaleConfiguration_STATUS from our AzureFirewallAutoscaleConfiguration_STATUS
func (configuration *AzureFirewallAutoscaleConfiguration_STATUS) AssignProperties_To_AzureFirewallAutoscaleConfiguration_STATUS(destination *storage.AzureFirewallAutoscaleConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaxCapacity
	destination.MaxCapacity = genruntime.ClonePointerToInt(configuration.MaxCapacity)

	// MinCapacity
	destination.MinCapacity = genruntime.ClonePointerToInt(configuration.MinCapacity)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// IP configuration of an Azure Firewall.
type AzureFirewallIPConfiguration struct {
	// Name: Name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	// PublicIPAddress: Reference to the PublicIP resource. This field is a mandatory input if subnet is not null.
	PublicIPAddress *SubResource `json:"publicIPAddress,omitempty"`

	// Subnet: Reference to the subnet resource. This resource must be named 'AzureFirewallSubnet' or
	// 'AzureFirewallManagementSubnet'.
	Subnet *SubResource `json:"subnet,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureFirewallIPConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *AzureFirewallIPConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.AzureFirewallIPConfiguration{}

	// Set property "Name":
	if configuration.Name != nil {
		name := *configuration.Name
		result.Name = &name
	}

	// Set property "Properties":
	if configuration.PublicIPAddress != nil || configuration.Subnet != nil {
		result.Properties = &arm.AzureFirewallIPConfigurationPropertiesFormat{}
	}
	if configuration.PublicIPAddress != nil {
		publicIPAddress_ARM, err := (*configuration.PublicIPAddress).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		publicIPAddress := *publicIPAddress_ARM.(*arm.SubResource)
		result.Properties.PublicIPAddress = &publicIPAddress
	}
	if configuration.Subnet != nil {
		subnet_ARM, err := (*configuration.Subnet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		subnet := *subnet_ARM.(*arm.SubResource)
		result.Properties.Subnet = &subnet
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *AzureFirewallIPConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureFirewallIPConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *AzureFirewallIPConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureFirewallIPConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureFirewallIPConfiguration, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		configuration.Name = &name
	}

	// Set property "PublicIPAddress":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddress != nil {
			var publicIPAddress1 SubResource
			err := publicIPAddress1.PopulateFromARM(owner, *typedInput.Properties.PublicIPAddress)
			if err != nil {
				return err
			}
			publicIPAddress := publicIPAddress1
			configuration.PublicIPAddress = &publicIPAddress
		}
	}

	// Set property "Subnet":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 SubResource
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			configuration.Subnet = &subnet
		}
	}

	// No error
	return nil
}

// AssignProperties_From_AzureFirewallIPConfiguration populates our AzureFirewallIPConfiguration from the provided source AzureFirewallIPConfiguration
func (configuration *AzureFirewallIPConfiguration) AssignProperties_From_AzureFirewallIPConfiguration(source *storage.AzureFirewallIPConfiguration) error {

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// PublicIPAddress
	if source.PublicIPAddress != nil {
		var publicIPAddress SubResource
		err := publicIPAddress.AssignProperties_From_SubResource(source.PublicIPAddress)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SubResource() to populate field PublicIPAddress")
		}
		configuration.PublicIPAddress = &publicIPAddress
	} else {
		configuration.PublicIPAddress = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet SubResource
		err := subnet.AssignProperties_From_SubResource(source.Subnet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SubResource() to populate field Subnet")
		}
		configuration.Subnet = &subnet
	} else {
		configuration.Subnet = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureFirewallIPConfiguration populates the provided destination AzureFirewallIPConfiguration from our AzureFirewallIPConfiguration
func (configuration *AzureFirewallIPConfiguration) AssignProperties_To_AzureFirewallIPConfiguration(destination *storage.AzureFirewallIPConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// PublicIPAddress
	if configuration.PublicIPAddress != nil {
		var publicIPAddress storage.SubResource
		err := configuration.PublicIPAddress.AssignProperties_To_SubResource(&publicIPAddress)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SubResource() to populate field PublicIPAddress")
		}
		destination.PublicIPAddress = &publicIPAddress
	} else {
		destination.PublicIPAddress = nil
	}

	// Subnet
	if configuration.Subnet != nil {
		var subnet storage.SubResource
		err := configuration.Subnet.AssignProperties_To_SubResource(&subnet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SubResource() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AzureFirewallIPConfiguration_STATUS populates our AzureFirewallIPConfiguration from the provided source AzureFirewallIPConfiguration_STATUS
func (configuration *AzureFirewallIPConfiguration) Initialize_From_AzureFirewallIPConfiguration_STATUS(source *AzureFirewallIPConfiguration_STATUS) error {

	// No error
	return nil
}

// IP configuration of an Azure Firewall.
type AzureFirewallIPConfiguration_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureFirewallIPConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *AzureFirewallIPConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureFirewallIPConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *AzureFirewallIPConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureFirewallIPConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureFirewallIPConfiguration_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		configuration.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_AzureFirewallIPConfiguration_STATUS populates our AzureFirewallIPConfiguration_STATUS from the provided source AzureFirewallIPConfiguration_STATUS
func (configuration *AzureFirewallIPConfiguration_STATUS) AssignProperties_From_AzureFirewallIPConfiguration_STATUS(source *storage.AzureFirewallIPConfiguration_STATUS) error {

	// Id
	configuration.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_AzureFirewallIPConfiguration_STATUS populates the provided destination AzureFirewallIPConfiguration_STATUS from our AzureFirewallIPConfiguration_STATUS
func (configuration *AzureFirewallIPConfiguration_STATUS) AssignProperties_To_AzureFirewallIPConfiguration_STATUS(destination *storage.AzureFirewallIPConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(configuration.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// IpGroups associated with azure firewall.
type AzureFirewallIpGroups_STATUS struct {
	// ChangeNumber: The iteration number.
	ChangeNumber *string `json:"changeNumber,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureFirewallIpGroups_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (groups *AzureFirewallIpGroups_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureFirewallIpGroups_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (groups *AzureFirewallIpGroups_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureFirewallIpGroups_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureFirewallIpGroups_STATUS, got %T", armInput)
	}

	// Set property "ChangeNumber":
	if typedInput.ChangeNumber != nil {
		changeNumber := *typedInput.ChangeNumber
		groups.ChangeNumber = &changeNumber
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		groups.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_AzureFirewallIpGroups_STATUS populates our AzureFirewallIpGroups_STATUS from the provided source AzureFirewallIpGroups_STATUS
func (groups *AzureFirewallIpGroups_STATUS) AssignProperties_From_AzureFirewallIpGroups_STATUS(source *storage.AzureFirewallIpGroups_STATUS) error {

	// ChangeNumber
	groups.ChangeNumber = genruntime.ClonePointerToString(source.ChangeNumber)

	// Id
	groups.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_AzureFirewallIpGroups_STATUS populates the provided destination AzureFirewallIpGroups_STATUS from our AzureFirewallIpGroups_STATUS
func (groups *AzureFirewallIpGroups_STATUS) AssignProperties_To_AzureFirewallIpGroups_STATUS(destination *storage.AzureFirewallIpGroups_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ChangeNumber
	destination.ChangeNumber = genruntime.ClonePointerToString(groups.ChangeNumber)

	// Id
	destination.Id = genruntime.ClonePointerToString(groups.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// NAT rule collection resource.
type AzureFirewallNatRuleCollection struct {
	// Action: The action type of a NAT rule collection.
	Action *AzureFirewallNatRCAction `json:"action,omitempty"`

	// Name: The name of the resource that is unique within the Azure firewall. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Maximum=65000
	// +kubebuilder:validation:Minimum=100
	// Priority: Priority of the NAT rule collection resource.
	Priority *int `json:"priority,omitempty"`

	// Rules: Collection of rules used by a NAT rule collection.
	Rules []AzureFirewallNatRule `json:"rules,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureFirewallNatRuleCollection{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (collection *AzureFirewallNatRuleCollection) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if collection == nil {
		return nil, nil
	}
	result := &arm.AzureFirewallNatRuleCollection{}

	// Set property "Name":
	if collection.Name != nil {
		name := *collection.Name
		result.Name = &name
	}

	// Set property "Properties":
	if collection.Action != nil ||
		collection.Priority != nil ||
		collection.Rules != nil {
		result.Properties = &arm.AzureFirewallNatRuleCollectionProperties{}
	}
	if collection.Action != nil {
		action_ARM, err := (*collection.Action).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		action := *action_ARM.(*arm.AzureFirewallNatRCAction)
		result.Properties.Action = &action
	}
	if collection.Priority != nil {
		priority := *collection.Priority
		result.Properties.Priority = &priority
	}
	for _, item := range collection.Rules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Rules = append(result.Properties.Rules, *item_ARM.(*arm.AzureFirewallNatRule))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (collection *AzureFirewallNatRuleCollection) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureFirewallNatRuleCollection{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (collection *AzureFirewallNatRuleCollection) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureFirewallNatRuleCollection)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureFirewallNatRuleCollection, got %T", armInput)
	}

	// Set property "Action":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Action != nil {
			var action1 AzureFirewallNatRCAction
			err := action1.PopulateFromARM(owner, *typedInput.Properties.Action)
			if err != nil {
				return err
			}
			action := action1
			collection.Action = &action
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		collection.Name = &name
	}

	// Set property "Priority":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Priority != nil {
			priority := *typedInput.Properties.Priority
			collection.Priority = &priority
		}
	}

	// Set property "Rules":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Rules {
			var item1 AzureFirewallNatRule
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			collection.Rules = append(collection.Rules, item1)
		}
	}

	// No error
	return nil
}

// AssignProperties_From_AzureFirewallNatRuleCollection populates our AzureFirewallNatRuleCollection from the provided source AzureFirewallNatRuleCollection
func (collection *AzureFirewallNatRuleCollection) AssignProperties_From_AzureFirewallNatRuleCollection(source *storage.AzureFirewallNatRuleCollection) error {

	// Action
	if source.Action != nil {
		var action AzureFirewallNatRCAction
		err := action.AssignProperties_From_AzureFirewallNatRCAction(source.Action)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureFirewallNatRCAction() to populate field Action")
		}
		collection.Action = &action
	} else {
		collection.Action = nil
	}

	// Name
	collection.Name = genruntime.ClonePointerToString(source.Name)

	// Priority
	collection.Priority = genruntime.ClonePointerToInt(source.Priority)

	// Rules
	if source.Rules != nil {
		ruleList := make([]AzureFirewallNatRule, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule AzureFirewallNatRule
			err := rule.AssignProperties_From_AzureFirewallNatRule(&ruleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_AzureFirewallNatRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		collection.Rules = ruleList
	} else {
		collection.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureFirewallNatRuleCollection populates the provided destination AzureFirewallNatRuleCollection from our AzureFirewallNatRuleCollection
func (collection *AzureFirewallNatRuleCollection) AssignProperties_To_AzureFirewallNatRuleCollection(destination *storage.AzureFirewallNatRuleCollection) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if collection.Action != nil {
		var action storage.AzureFirewallNatRCAction
		err := collection.Action.AssignProperties_To_AzureFirewallNatRCAction(&action)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureFirewallNatRCAction() to populate field Action")
		}
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(collection.Name)

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(collection.Priority)

	// Rules
	if collection.Rules != nil {
		ruleList := make([]storage.AzureFirewallNatRule, len(collection.Rules))
		for ruleIndex, ruleItem := range collection.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule storage.AzureFirewallNatRule
			err := ruleItem.AssignProperties_To_AzureFirewallNatRule(&rule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_AzureFirewallNatRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AzureFirewallNatRuleCollection_STATUS populates our AzureFirewallNatRuleCollection from the provided source AzureFirewallNatRuleCollection_STATUS
func (collection *AzureFirewallNatRuleCollection) Initialize_From_AzureFirewallNatRuleCollection_STATUS(source *AzureFirewallNatRuleCollection_STATUS) error {

	// No error
	return nil
}

// NAT rule collection resource.
type AzureFirewallNatRuleCollection_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureFirewallNatRuleCollection_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (collection *AzureFirewallNatRuleCollection_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureFirewallNatRuleCollection_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (collection *AzureFirewallNatRuleCollection_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureFirewallNatRuleCollection_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureFirewallNatRuleCollection_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		collection.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_AzureFirewallNatRuleCollection_STATUS populates our AzureFirewallNatRuleCollection_STATUS from the provided source AzureFirewallNatRuleCollection_STATUS
func (collection *AzureFirewallNatRuleCollection_STATUS) AssignProperties_From_AzureFirewallNatRuleCollection_STATUS(source *storage.AzureFirewallNatRuleCollection_STATUS) error {

	// Id
	collection.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_AzureFirewallNatRuleCollection_STATUS populates the provided destination AzureFirewallNatRuleCollection_STATUS from our AzureFirewallNatRuleCollection_STATUS
func (collection *AzureFirewallNatRuleCollection_STATUS) AssignProperties_To_AzureFirewallNatRuleCollection_STATUS(destination *storage.AzureFirewallNatRuleCollection_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(collection.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Network rule collection resource.
type AzureFirewallNetworkRuleCollection struct {
	// Action: The action type of a rule collection.
	Action *AzureFirewallRCAction `json:"action,omitempty"`

	// Name: The name of the resource that is unique within the Azure firewall. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Maximum=65000
	// +kubebuilder:validation:Minimum=100
	// Priority: Priority of the network rule collection resource.
	Priority *int `json:"priority,omitempty"`

	// Rules: Collection of rules used by a network rule collection.
	Rules []AzureFirewallNetworkRule `json:"rules,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureFirewallNetworkRuleCollection{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (collection *AzureFirewallNetworkRuleCollection) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if collection == nil {
		return nil, nil
	}
	result := &arm.AzureFirewallNetworkRuleCollection{}

	// Set property "Name":
	if collection.Name != nil {
		name := *collection.Name
		result.Name = &name
	}

	// Set property "Properties":
	if collection.Action != nil ||
		collection.Priority != nil ||
		collection.Rules != nil {
		result.Properties = &arm.AzureFirewallNetworkRuleCollectionPropertiesFormat{}
	}
	if collection.Action != nil {
		action_ARM, err := (*collection.Action).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		action := *action_ARM.(*arm.AzureFirewallRCAction)
		result.Properties.Action = &action
	}
	if collection.Priority != nil {
		priority := *collection.Priority
		result.Properties.Priority = &priority
	}
	for _, item := range collection.Rules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Rules = append(result.Properties.Rules, *item_ARM.(*arm.AzureFirewallNetworkRule))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (collection *AzureFirewallNetworkRuleCollection) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureFirewallNetworkRuleCollection{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (collection *AzureFirewallNetworkRuleCollection) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureFirewallNetworkRuleCollection)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureFirewallNetworkRuleCollection, got %T", armInput)
	}

	// Set property "Action":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Action != nil {
			var action1 AzureFirewallRCAction
			err := action1.PopulateFromARM(owner, *typedInput.Properties.Action)
			if err != nil {
				return err
			}
			action := action1
			collection.Action = &action
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		collection.Name = &name
	}

	// Set property "Priority":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Priority != nil {
			priority := *typedInput.Properties.Priority
			collection.Priority = &priority
		}
	}

	// Set property "Rules":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Rules {
			var item1 AzureFirewallNetworkRule
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			collection.Rules = append(collection.Rules, item1)
		}
	}

	// No error
	return nil
}

// AssignProperties_From_AzureFirewallNetworkRuleCollection populates our AzureFirewallNetworkRuleCollection from the provided source AzureFirewallNetworkRuleCollection
func (collection *AzureFirewallNetworkRuleCollection) AssignProperties_From_AzureFirewallNetworkRuleCollection(source *storage.AzureFirewallNetworkRuleCollection) error {

	// Action
	if source.Action != nil {
		var action AzureFirewallRCAction
		err := action.AssignProperties_From_AzureFirewallRCAction(source.Action)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureFirewallRCAction() to populate field Action")
		}
		collection.Action = &action
	} else {
		collection.Action = nil
	}

	// Name
	collection.Name = genruntime.ClonePointerToString(source.Name)

	// Priority
	collection.Priority = genruntime.ClonePointerToInt(source.Priority)

	// Rules
	if source.Rules != nil {
		ruleList := make([]AzureFirewallNetworkRule, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule AzureFirewallNetworkRule
			err := rule.AssignProperties_From_AzureFirewallNetworkRule(&ruleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_AzureFirewallNetworkRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		collection.Rules = ruleList
	} else {
		collection.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureFirewallNetworkRuleCollection populates the provided destination AzureFirewallNetworkRuleCollection from our AzureFirewallNetworkRuleCollection
func (collection *AzureFirewallNetworkRuleCollection) AssignProperties_To_AzureFirewallNetworkRuleCollection(destination *storage.AzureFirewallNetworkRuleCollection) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if collection.Action != nil {
		var action storage.AzureFirewallRCAction
		err := collection.Action.AssignProperties_To_AzureFirewallRCAction(&action)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureFirewallRCAction() to populate field Action")
		}
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(collection.Name)

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(collection.Priority)

	// Rules
	if collection.Rules != nil {
		ruleList := make([]storage.AzureFirewallNetworkRule, len(collection.Rules))
		for ruleIndex, ruleItem := range collection.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule storage.AzureFirewallNetworkRule
			err := ruleItem.AssignProperties_To_AzureFirewallNetworkRule(&rule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_AzureFirewallNetworkRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AzureFirewallNetworkRuleCollection_STATUS populates our AzureFirewallNetworkRuleCollection from the provided source AzureFirewallNetworkRuleCollection_STATUS
func (collection *AzureFirewallNetworkRuleCollection) Initialize_From_AzureFirewallNetworkRuleCollection_STATUS(source *AzureFirewallNetworkRuleCollection_STATUS) error {

	// No error
	return nil
}

// Network rule collection resource.
type AzureFirewallNetworkRuleCollection_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureFirewallNetworkRuleCollection_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (collection *AzureFirewallNetworkRuleCollection_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureFirewallNetworkRuleCollection_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (collection *AzureFirewallNetworkRuleCollection_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureFirewallNetworkRuleCollection_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureFirewallNetworkRuleCollection_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		collection.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_AzureFirewallNetworkRuleCollection_STATUS populates our AzureFirewallNetworkRuleCollection_STATUS from the provided source AzureFirewallNetworkRuleCollection_STATUS
func (collection *AzureFirewallNetworkRuleCollection_STATUS) AssignProperties_From_AzureFirewallNetworkRuleCollection_STATUS(source *storage.AzureFirewallNetworkRuleCollection_STATUS) error {

	// Id
	collection.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_AzureFirewallNetworkRuleCollection_STATUS populates the provided destination AzureFirewallNetworkRuleCollection_STATUS from our AzureFirewallNetworkRuleCollection_STATUS
func (collection *AzureFirewallNetworkRuleCollection_STATUS) AssignProperties_To_AzureFirewallNetworkRuleCollection_STATUS(destination *storage.AzureFirewallNetworkRuleCollection_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(collection.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type AzureFirewallOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_AzureFirewallOperatorSpec populates our AzureFirewallOperatorSpec from the provided source AzureFirewallOperatorSpec
func (operator *AzureFirewallOperatorSpec) AssignProperties_From_AzureFirewallOperatorSpec(source *storage.AzureFirewallOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureFirewallOperatorSpec populates the provided destination AzureFirewallOperatorSpec from our AzureFirewallOperatorSpec
func (operator *AzureFirewallOperatorSpec) AssignProperties_To_AzureFirewallOperatorSpec(destination *storage.AzureFirewallOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// SKU of an Azure Firewall.
type AzureFirewallSku struct {
	// Name: Name of an Azure Firewall SKU.
	Name *AzureFirewallSku_Name `json:"name,omitempty"`

	// Tier: Tier of an Azure Firewall.
	Tier *AzureFirewallSku_Tier `json:"tier,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureFirewallSku{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (firewallSku *AzureFirewallSku) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if firewallSku == nil {
		return nil, nil
	}
	result := &arm.AzureFirewallSku{}

	// Set property "Name":
	if firewallSku.Name != nil {
		var temp string
		temp = string(*firewallSku.Name)
		name := arm.AzureFirewallSku_Name(temp)
		result.Name = &name
	}

	// Set property "Tier":
	if firewallSku.Tier != nil {
		var temp string
		temp = string(*firewallSku.Tier)
		tier := arm.AzureFirewallSku_Tier(temp)
		result.Tier = &tier
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (firewallSku *AzureFirewallSku) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureFirewallSku{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (firewallSku *AzureFirewallSku) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureFirewallSku)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureFirewallSku, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		var temp string
		temp = string(*typedInput.Name)
		name := AzureFirewallSku_Name(temp)
		firewallSku.Name = &name
	}

	// Set property "Tier":
	if typedInput.Tier != nil {
		var temp string
		temp = string(*typedInput.Tier)
		tier := AzureFirewallSku_Tier(temp)
		firewallSku.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_AzureFirewallSku populates our AzureFirewallSku from the provided source AzureFirewallSku
func (firewallSku *AzureFirewallSku) AssignProperties_From_AzureFirewallSku(source *storage.AzureFirewallSku) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, azureFirewallSku_Name_Values)
		firewallSku.Name = &nameTemp
	} else {
		firewallSku.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := *source.Tier
		tierTemp := genruntime.ToEnum(tier, azureFirewallSku_Tier_Values)
		firewallSku.Tier = &tierTemp
	} else {
		firewallSku.Tier = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureFirewallSku populates the provided destination AzureFirewallSku from our AzureFirewallSku
func (firewallSku *AzureFirewallSku) AssignProperties_To_AzureFirewallSku(destination *storage.AzureFirewallSku) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if firewallSku.Name != nil {
		name := string(*firewallSku.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Tier
	if firewallSku.Tier != nil {
		tier := string(*firewallSku.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AzureFirewallSku_STATUS populates our AzureFirewallSku from the provided source AzureFirewallSku_STATUS
func (firewallSku *AzureFirewallSku) Initialize_From_AzureFirewallSku_STATUS(source *AzureFirewallSku_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), azureFirewallSku_Name_Values)
		firewallSku.Name = &name
	} else {
		firewallSku.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := genruntime.ToEnum(string(*source.Tier), azureFirewallSku_Tier_Values)
		firewallSku.Tier = &tier
	} else {
		firewallSku.Tier = nil
	}

	// No error
	return nil
}

// SKU of an Azure Firewall.
type AzureFirewallSku_STATUS struct {
	// Name: Name of an Azure Firewall SKU.
	Name *AzureFirewallSku_Name_STATUS `json:"name,omitempty"`

	// Tier: Tier of an Azure Firewall.
	Tier *AzureFirewallSku_Tier_STATUS `json:"tier,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureFirewallSku_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (firewallSku *AzureFirewallSku_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureFirewallSku_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (firewallSku *AzureFirewallSku_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureFirewallSku_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureFirewallSku_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		var temp string
		temp = string(*typedInput.Name)
		name := AzureFirewallSku_Name_STATUS(temp)
		firewallSku.Name = &name
	}

	// Set property "Tier":
	if typedInput.Tier != nil {
		var temp string
		temp = string(*typedInput.Tier)
		tier := AzureFirewallSku_Tier_STATUS(temp)
		firewallSku.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_AzureFirewallSku_STATUS populates our AzureFirewallSku_STATUS from the provided source AzureFirewallSku_STATUS
func (firewallSku *AzureFirewallSku_STATUS) AssignProperties_From_AzureFirewallSku_STATUS(source *storage.AzureFirewallSku_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, azureFirewallSku_Name_STATUS_Values)
		firewallSku.Name = &nameTemp
	} else {
		firewallSku.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := *source.Tier
		tierTemp := genruntime.ToEnum(tier, azureFirewallSku_Tier_STATUS_Values)
		firewallSku.Tier = &tierTemp
	} else {
		firewallSku.Tier = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureFirewallSku_STATUS populates the provided destination AzureFirewallSku_STATUS from our AzureFirewallSku_STATUS
func (firewallSku *AzureFirewallSku_STATUS) AssignProperties_To_AzureFirewallSku_STATUS(destination *storage.AzureFirewallSku_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if firewallSku.Name != nil {
		name := string(*firewallSku.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Tier
	if firewallSku.Tier != nil {
		tier := string(*firewallSku.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The operation mode for Threat Intel.
// +kubebuilder:validation:Enum={"Alert","Deny","Off"}
type AzureFirewallThreatIntelMode string

const (
	AzureFirewallThreatIntelMode_Alert = AzureFirewallThreatIntelMode("Alert")
	AzureFirewallThreatIntelMode_Deny  = AzureFirewallThreatIntelMode("Deny")
	AzureFirewallThreatIntelMode_Off   = AzureFirewallThreatIntelMode("Off")
)

// Mapping from string to AzureFirewallThreatIntelMode
var azureFirewallThreatIntelMode_Values = map[string]AzureFirewallThreatIntelMode{
	"alert": AzureFirewallThreatIntelMode_Alert,
	"deny":  AzureFirewallThreatIntelMode_Deny,
	"off":   AzureFirewallThreatIntelMode_Off,
}

// The operation mode for Threat Intel.
type AzureFirewallThreatIntelMode_STATUS string

const (
	AzureFirewallThreatIntelMode_STATUS_Alert = AzureFirewallThreatIntelMode_STATUS("Alert")
	AzureFirewallThreatIntelMode_STATUS_Deny  = AzureFirewallThreatIntelMode_STATUS("Deny")
	AzureFirewallThreatIntelMode_STATUS_Off   = AzureFirewallThreatIntelMode_STATUS("Off")
)

// Mapping from string to AzureFirewallThreatIntelMode_STATUS
var azureFirewallThreatIntelMode_STATUS_Values = map[string]AzureFirewallThreatIntelMode_STATUS{
	"alert": AzureFirewallThreatIntelMode_STATUS_Alert,
	"deny":  AzureFirewallThreatIntelMode_STATUS_Deny,
	"off":   AzureFirewallThreatIntelMode_STATUS_Off,
}

// IP addresses associated with azure firewall.
type HubIPAddresses struct {
	// PrivateIPAddress: Private IP Address associated with azure firewall.
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`

	// PublicIPs: Public IP addresses associated with azure firewall.
	PublicIPs *HubPublicIPAddresses `json:"publicIPs,omitempty"`
}

var _ genruntime.ARMTransformer = &HubIPAddresses{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (addresses *HubIPAddresses) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if addresses == nil {
		return nil, nil
	}
	result := &arm.HubIPAddresses{}

	// Set property "PrivateIPAddress":
	if addresses.PrivateIPAddress != nil {
		privateIPAddress := *addresses.PrivateIPAddress
		result.PrivateIPAddress = &privateIPAddress
	}

	// Set property "PublicIPs":
	if addresses.PublicIPs != nil {
		publicIPs_ARM, err := (*addresses.PublicIPs).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		publicIPs := *publicIPs_ARM.(*arm.HubPublicIPAddresses)
		result.PublicIPs = &publicIPs
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (addresses *HubIPAddresses) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HubIPAddresses{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (addresses *HubIPAddresses) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HubIPAddresses)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HubIPAddresses, got %T", armInput)
	}

	// Set property "PrivateIPAddress":
	if typedInput.PrivateIPAddress != nil {
		privateIPAddress := *typedInput.PrivateIPAddress
		addresses.PrivateIPAddress = &privateIPAddress
	}

	// Set property "PublicIPs":
	if typedInput.PublicIPs != nil {
		var publicIPs1 HubPublicIPAddresses
		err := publicIPs1.PopulateFromARM(owner, *typedInput.PublicIPs)
		if err != nil {
			return err
		}
		publicIPs := publicIPs1
		addresses.PublicIPs = &publicIPs
	}

	// No error
	return nil
}

// AssignProperties_From_HubIPAddresses populates our HubIPAddresses from the provided source HubIPAddresses
func (addresses *HubIPAddresses) AssignProperties_From_HubIPAddresses(source *storage.HubIPAddresses) error {

	// PrivateIPAddress
	addresses.PrivateIPAddress = genruntime.ClonePointerToString(source.PrivateIPAddress)

	// PublicIPs
	if source.PublicIPs != nil {
		var publicIP HubPublicIPAddresses
		err := publicIP.AssignProperties_From_HubPublicIPAddresses(source.PublicIPs)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_HubPublicIPAddresses() to populate field PublicIPs")
		}
		addresses.PublicIPs = &publicIP
	} else {
		addresses.PublicIPs = nil
	}

	// No error
	return nil
}

// AssignProperties_To_HubIPAddresses populates the provided destination HubIPAddresses from our HubIPAddresses
func (addresses *HubIPAddresses) AssignProperties_To_HubIPAddresses(destination *storage.HubIPAddresses) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrivateIPAddress
	destination.PrivateIPAddress = genruntime.ClonePointerToString(addresses.PrivateIPAddress)

	// PublicIPs
	if addresses.PublicIPs != nil {
		var publicIP storage.HubPublicIPAddresses
		err := addresses.PublicIPs.AssignProperties_To_HubPublicIPAddresses(&publicIP)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_HubPublicIPAddresses() to populate field PublicIPs")
		}
		destination.PublicIPs = &publicIP
	} else {
		destination.PublicIPs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_HubIPAddresses_STATUS populates our HubIPAddresses from the provided source HubIPAddresses_STATUS
func (addresses *HubIPAddresses) Initialize_From_HubIPAddresses_STATUS(source *HubIPAddresses_STATUS) error {

	// PrivateIPAddress
	addresses.PrivateIPAddress = genruntime.ClonePointerToString(source.PrivateIPAddress)

	// PublicIPs
	if source.PublicIPs != nil {
		var publicIP HubPublicIPAddresses
		err := publicIP.Initialize_From_HubPublicIPAddresses_STATUS(source.PublicIPs)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_HubPublicIPAddresses_STATUS() to populate field PublicIPs")
		}
		addresses.PublicIPs = &publicIP
	} else {
		addresses.PublicIPs = nil
	}

	// No error
	return nil
}

// IP addresses associated with azure firewall.
type HubIPAddresses_STATUS struct {
	// PrivateIPAddress: Private IP Address associated with azure firewall.
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`

	// PublicIPs: Public IP addresses associated with azure firewall.
	PublicIPs *HubPublicIPAddresses_STATUS `json:"publicIPs,omitempty"`
}

var _ genruntime.FromARMConverter = &HubIPAddresses_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (addresses *HubIPAddresses_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HubIPAddresses_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (addresses *HubIPAddresses_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HubIPAddresses_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HubIPAddresses_STATUS, got %T", armInput)
	}

	// Set property "PrivateIPAddress":
	if typedInput.PrivateIPAddress != nil {
		privateIPAddress := *typedInput.PrivateIPAddress
		addresses.PrivateIPAddress = &privateIPAddress
	}

	// Set property "PublicIPs":
	if typedInput.PublicIPs != nil {
		var publicIPs1 HubPublicIPAddresses_STATUS
		err := publicIPs1.PopulateFromARM(owner, *typedInput.PublicIPs)
		if err != nil {
			return err
		}
		publicIPs := publicIPs1
		addresses.PublicIPs = &publicIPs
	}

	// No error
	return nil
}

// AssignProperties_From_HubIPAddresses_STATUS populates our HubIPAddresses_STATUS from the provided source HubIPAddresses_STATUS
func (addresses *HubIPAddresses_STATUS) AssignProperties_From_HubIPAddresses_STATUS(source *storage.HubIPAddresses_STATUS) error {

	// PrivateIPAddress
	addresses.PrivateIPAddress = genruntime.ClonePointerToString(source.PrivateIPAddress)

	// PublicIPs
	if source.PublicIPs != nil {
		var publicIP HubPublicIPAddresses_STATUS
		err := publicIP.AssignProperties_From_HubPublicIPAddresses_STATUS(source.PublicIPs)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_HubPublicIPAddresses_STATUS() to populate field PublicIPs")
		}
		addresses.PublicIPs = &publicIP
	} else {
		addresses.PublicIPs = nil
	}

	// No error
	return nil
}

// AssignProperties_To_HubIPAddresses_STATUS populates the provided destination HubIPAddresses_STATUS from our HubIPAddresses_STATUS
func (addresses *HubIPAddresses_STATUS) AssignProperties_To_HubIPAddresses_STATUS(destination *storage.HubIPAddresses_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrivateIPAddress
	destination.PrivateIPAddress = genruntime.ClonePointerToString(addresses.PrivateIPAddress)

	// PublicIPs
	if addresses.PublicIPs != nil {
		var publicIP storage.HubPublicIPAddresses_STATUS
		err := addresses.PublicIPs.AssignProperties_To_HubPublicIPAddresses_STATUS(&publicIP)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_HubPublicIPAddresses_STATUS() to populate field PublicIPs")
		}
		destination.PublicIPs = &publicIP
	} else {
		destination.PublicIPs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The current provisioning state.
type ProvisioningState_STATUS string

const (
	ProvisioningState_STATUS_Deleting  = ProvisioningState_STATUS("Deleting")
	ProvisioningState_STATUS_Failed    = ProvisioningState_STATUS("Failed")
	ProvisioningState_STATUS_Succeeded = ProvisioningState_STATUS("Succeeded")
	ProvisioningState_STATUS_Updating  = ProvisioningState_STATUS("Updating")
)

// Mapping from string to ProvisioningState_STATUS
var provisioningState_STATUS_Values = map[string]ProvisioningState_STATUS{
	"deleting":  ProvisioningState_STATUS_Deleting,
	"failed":    ProvisioningState_STATUS_Failed,
	"succeeded": ProvisioningState_STATUS_Succeeded,
	"updating":  ProvisioningState_STATUS_Updating,
}

// Reference to another subresource.
type SubResource struct {
	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &SubResource{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (resource *SubResource) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if resource == nil {
		return nil, nil
	}
	result := &arm.SubResource{}

	// Set property "Id":
	if resource.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*resource.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *SubResource) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SubResource{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *SubResource) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.SubResource)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SubResource, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_SubResource populates our SubResource from the provided source SubResource
func (resource *SubResource) AssignProperties_From_SubResource(source *storage.SubResource) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		resource.Reference = &reference
	} else {
		resource.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SubResource populates the provided destination SubResource from our SubResource
func (resource *SubResource) AssignProperties_To_SubResource(destination *storage.SubResource) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if resource.Reference != nil {
		reference := resource.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SubResource_STATUS populates our SubResource from the provided source SubResource_STATUS
func (resource *SubResource) Initialize_From_SubResource_STATUS(source *SubResource_STATUS) error {

	// Reference
	if source.Id != nil {
		reference := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		resource.Reference = &reference
	} else {
		resource.Reference = nil
	}

	// No error
	return nil
}

// Reference to another subresource.
type SubResource_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &SubResource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *SubResource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SubResource_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *SubResource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SubResource_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SubResource_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		resource.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_SubResource_STATUS populates our SubResource_STATUS from the provided source SubResource_STATUS
func (resource *SubResource_STATUS) AssignProperties_From_SubResource_STATUS(source *storage.SubResource_STATUS) error {

	// Id
	resource.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_SubResource_STATUS populates the provided destination SubResource_STATUS from our SubResource_STATUS
func (resource *SubResource_STATUS) AssignProperties_To_SubResource_STATUS(destination *storage.SubResource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(resource.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Properties of an application rule.
type AzureFirewallApplicationRule struct {
	// Description: Description of the rule.
	Description *string `json:"description,omitempty"`

	// FqdnTags: List of FQDN Tags for this rule.
	FqdnTags []string `json:"fqdnTags,omitempty"`

	// Name: Name of the application rule.
	Name *string `json:"name,omitempty"`

	// Protocols: Array of ApplicationRuleProtocols.
	Protocols []AzureFirewallApplicationRuleProtocol `json:"protocols,omitempty"`

	// SourceAddresses: List of source IP addresses for this rule.
	SourceAddresses []string `json:"sourceAddresses,omitempty"`

	// SourceIpGroups: List of source IpGroups for this rule.
	SourceIpGroups []string `json:"sourceIpGroups,omitempty"`

	// TargetFqdns: List of FQDNs for this rule.
	TargetFqdns []string `json:"targetFqdns,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureFirewallApplicationRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *AzureFirewallApplicationRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.AzureFirewallApplicationRule{}

	// Set property "Description":
	if rule.Description != nil {
		description := *rule.Description
		result.Description = &description
	}

	// Set property "FqdnTags":
	for _, item := range rule.FqdnTags {
		result.FqdnTags = append(result.FqdnTags, item)
	}

	// Set property "Name":
	if rule.Name != nil {
		name := *rule.Name
		result.Name = &name
	}

	// Set property "Protocols":
	for _, item := range rule.Protocols {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Protocols = append(result.Protocols, *item_ARM.(*arm.AzureFirewallApplicationRuleProtocol))
	}

	// Set property "SourceAddresses":
	for _, item := range rule.SourceAddresses {
		result.SourceAddresses = append(result.SourceAddresses, item)
	}

	// Set property "SourceIpGroups":
	for _, item := range rule.SourceIpGroups {
		result.SourceIpGroups = append(result.SourceIpGroups, item)
	}

	// Set property "TargetFqdns":
	for _, item := range rule.TargetFqdns {
		result.TargetFqdns = append(result.TargetFqdns, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *AzureFirewallApplicationRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureFirewallApplicationRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *AzureFirewallApplicationRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureFirewallApplicationRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureFirewallApplicationRule, got %T", armInput)
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		rule.Description = &description
	}

	// Set property "FqdnTags":
	for _, item := range typedInput.FqdnTags {
		rule.FqdnTags = append(rule.FqdnTags, item)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "Protocols":
	for _, item := range typedInput.Protocols {
		var item1 AzureFirewallApplicationRuleProtocol
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.Protocols = append(rule.Protocols, item1)
	}

	// Set property "SourceAddresses":
	for _, item := range typedInput.SourceAddresses {
		rule.SourceAddresses = append(rule.SourceAddresses, item)
	}

	// Set property "SourceIpGroups":
	for _, item := range typedInput.SourceIpGroups {
		rule.SourceIpGroups = append(rule.SourceIpGroups, item)
	}

	// Set property "TargetFqdns":
	for _, item := range typedInput.TargetFqdns {
		rule.TargetFqdns = append(rule.TargetFqdns, item)
	}

	// No error
	return nil
}

// AssignProperties_From_AzureFirewallApplicationRule populates our AzureFirewallApplicationRule from the provided source AzureFirewallApplicationRule
func (rule *AzureFirewallApplicationRule) AssignProperties_From_AzureFirewallApplicationRule(source *storage.AzureFirewallApplicationRule) error {

	// Description
	rule.Description = genruntime.ClonePointerToString(source.Description)

	// FqdnTags
	rule.FqdnTags = genruntime.CloneSliceOfString(source.FqdnTags)

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Protocols
	if source.Protocols != nil {
		protocolList := make([]AzureFirewallApplicationRuleProtocol, len(source.Protocols))
		for protocolIndex, protocolItem := range source.Protocols {
			// Shadow the loop variable to avoid aliasing
			protocolItem := protocolItem
			var protocol AzureFirewallApplicationRuleProtocol
			err := protocol.AssignProperties_From_AzureFirewallApplicationRuleProtocol(&protocolItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_AzureFirewallApplicationRuleProtocol() to populate field Protocols")
			}
			protocolList[protocolIndex] = protocol
		}
		rule.Protocols = protocolList
	} else {
		rule.Protocols = nil
	}

	// SourceAddresses
	rule.SourceAddresses = genruntime.CloneSliceOfString(source.SourceAddresses)

	// SourceIpGroups
	rule.SourceIpGroups = genruntime.CloneSliceOfString(source.SourceIpGroups)

	// TargetFqdns
	rule.TargetFqdns = genruntime.CloneSliceOfString(source.TargetFqdns)

	// No error
	return nil
}

// AssignProperties_To_AzureFirewallApplicationRule populates the provided destination AzureFirewallApplicationRule from our AzureFirewallApplicationRule
func (rule *AzureFirewallApplicationRule) AssignProperties_To_AzureFirewallApplicationRule(destination *storage.AzureFirewallApplicationRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Description
	destination.Description = genruntime.ClonePointerToString(rule.Description)

	// FqdnTags
	destination.FqdnTags = genruntime.CloneSliceOfString(rule.FqdnTags)

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Protocols
	if rule.Protocols != nil {
		protocolList := make([]storage.AzureFirewallApplicationRuleProtocol, len(rule.Protocols))
		for protocolIndex, protocolItem := range rule.Protocols {
			// Shadow the loop variable to avoid aliasing
			protocolItem := protocolItem
			var protocol storage.AzureFirewallApplicationRuleProtocol
			err := protocolItem.AssignProperties_To_AzureFirewallApplicationRuleProtocol(&protocol)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_AzureFirewallApplicationRuleProtocol() to populate field Protocols")
			}
			protocolList[protocolIndex] = protocol
		}
		destination.Protocols = protocolList
	} else {
		destination.Protocols = nil
	}

	// SourceAddresses
	destination.SourceAddresses = genruntime.CloneSliceOfString(rule.SourceAddresses)

	// SourceIpGroups
	destination.SourceIpGroups = genruntime.CloneSliceOfString(rule.SourceIpGroups)

	// TargetFqdns
	destination.TargetFqdns = genruntime.CloneSliceOfString(rule.TargetFqdns)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// AzureFirewall NAT Rule Collection Action.
type AzureFirewallNatRCAction struct {
	// Type: The type of action.
	Type *AzureFirewallNatRCActionType `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureFirewallNatRCAction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *AzureFirewallNatRCAction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &arm.AzureFirewallNatRCAction{}

	// Set property "Type":
	if action.Type != nil {
		var temp string
		temp = string(*action.Type)
		typeVar := arm.AzureFirewallNatRCActionType(temp)
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *AzureFirewallNatRCAction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureFirewallNatRCAction{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *AzureFirewallNatRCAction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureFirewallNatRCAction)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureFirewallNatRCAction, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := AzureFirewallNatRCActionType(temp)
		action.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_AzureFirewallNatRCAction populates our AzureFirewallNatRCAction from the provided source AzureFirewallNatRCAction
func (action *AzureFirewallNatRCAction) AssignProperties_From_AzureFirewallNatRCAction(source *storage.AzureFirewallNatRCAction) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, azureFirewallNatRCActionType_Values)
		action.Type = &typeTemp
	} else {
		action.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureFirewallNatRCAction populates the provided destination AzureFirewallNatRCAction from our AzureFirewallNatRCAction
func (action *AzureFirewallNatRCAction) AssignProperties_To_AzureFirewallNatRCAction(destination *storage.AzureFirewallNatRCAction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if action.Type != nil {
		typeVar := string(*action.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Properties of a NAT rule.
type AzureFirewallNatRule struct {
	// Description: Description of the rule.
	Description *string `json:"description,omitempty"`

	// DestinationAddresses: List of destination IP addresses for this rule. Supports IP ranges, prefixes, and service tags.
	DestinationAddresses []string `json:"destinationAddresses,omitempty"`

	// DestinationPorts: List of destination ports.
	DestinationPorts []string `json:"destinationPorts,omitempty"`

	// Name: Name of the NAT rule.
	Name *string `json:"name,omitempty"`

	// Protocols: Array of AzureFirewallNetworkRuleProtocols applicable to this NAT rule.
	Protocols []AzureFirewallNetworkRuleProtocol `json:"protocols,omitempty"`

	// SourceAddresses: List of source IP addresses for this rule.
	SourceAddresses []string `json:"sourceAddresses,omitempty"`

	// SourceIpGroups: List of source IpGroups for this rule.
	SourceIpGroups []string `json:"sourceIpGroups,omitempty"`

	// TranslatedAddress: The translated address for this NAT rule.
	TranslatedAddress *string `json:"translatedAddress,omitempty"`

	// TranslatedFqdn: The translated FQDN for this NAT rule.
	TranslatedFqdn *string `json:"translatedFqdn,omitempty"`

	// TranslatedPort: The translated port for this NAT rule.
	TranslatedPort *string `json:"translatedPort,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureFirewallNatRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *AzureFirewallNatRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.AzureFirewallNatRule{}

	// Set property "Description":
	if rule.Description != nil {
		description := *rule.Description
		result.Description = &description
	}

	// Set property "DestinationAddresses":
	for _, item := range rule.DestinationAddresses {
		result.DestinationAddresses = append(result.DestinationAddresses, item)
	}

	// Set property "DestinationPorts":
	for _, item := range rule.DestinationPorts {
		result.DestinationPorts = append(result.DestinationPorts, item)
	}

	// Set property "Name":
	if rule.Name != nil {
		name := *rule.Name
		result.Name = &name
	}

	// Set property "Protocols":
	for _, item := range rule.Protocols {
		var temp string
		temp = string(item)
		result.Protocols = append(result.Protocols, arm.AzureFirewallNetworkRuleProtocol(temp))
	}

	// Set property "SourceAddresses":
	for _, item := range rule.SourceAddresses {
		result.SourceAddresses = append(result.SourceAddresses, item)
	}

	// Set property "SourceIpGroups":
	for _, item := range rule.SourceIpGroups {
		result.SourceIpGroups = append(result.SourceIpGroups, item)
	}

	// Set property "TranslatedAddress":
	if rule.TranslatedAddress != nil {
		translatedAddress := *rule.TranslatedAddress
		result.TranslatedAddress = &translatedAddress
	}

	// Set property "TranslatedFqdn":
	if rule.TranslatedFqdn != nil {
		translatedFqdn := *rule.TranslatedFqdn
		result.TranslatedFqdn = &translatedFqdn
	}

	// Set property "TranslatedPort":
	if rule.TranslatedPort != nil {
		translatedPort := *rule.TranslatedPort
		result.TranslatedPort = &translatedPort
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *AzureFirewallNatRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureFirewallNatRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *AzureFirewallNatRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureFirewallNatRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureFirewallNatRule, got %T", armInput)
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		rule.Description = &description
	}

	// Set property "DestinationAddresses":
	for _, item := range typedInput.DestinationAddresses {
		rule.DestinationAddresses = append(rule.DestinationAddresses, item)
	}

	// Set property "DestinationPorts":
	for _, item := range typedInput.DestinationPorts {
		rule.DestinationPorts = append(rule.DestinationPorts, item)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "Protocols":
	for _, item := range typedInput.Protocols {
		var temp string
		temp = string(item)
		rule.Protocols = append(rule.Protocols, AzureFirewallNetworkRuleProtocol(temp))
	}

	// Set property "SourceAddresses":
	for _, item := range typedInput.SourceAddresses {
		rule.SourceAddresses = append(rule.SourceAddresses, item)
	}

	// Set property "SourceIpGroups":
	for _, item := range typedInput.SourceIpGroups {
		rule.SourceIpGroups = append(rule.SourceIpGroups, item)
	}

	// Set property "TranslatedAddress":
	if typedInput.TranslatedAddress != nil {
		translatedAddress := *typedInput.TranslatedAddress
		rule.TranslatedAddress = &translatedAddress
	}

	// Set property "TranslatedFqdn":
	if typedInput.TranslatedFqdn != nil {
		translatedFqdn := *typedInput.TranslatedFqdn
		rule.TranslatedFqdn = &translatedFqdn
	}

	// Set property "TranslatedPort":
	if typedInput.TranslatedPort != nil {
		translatedPort := *typedInput.TranslatedPort
		rule.TranslatedPort = &translatedPort
	}

	// No error
	return nil
}

// AssignProperties_From_AzureFirewallNatRule populates our AzureFirewallNatRule from the provided source AzureFirewallNatRule
func (rule *AzureFirewallNatRule) AssignProperties_From_AzureFirewallNatRule(source *storage.AzureFirewallNatRule) error {

	// Description
	rule.Description = genruntime.ClonePointerToString(source.Description)

	// DestinationAddresses
	rule.DestinationAddresses = genruntime.CloneSliceOfString(source.DestinationAddresses)

	// DestinationPorts
	rule.DestinationPorts = genruntime.CloneSliceOfString(source.DestinationPorts)

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Protocols
	if source.Protocols != nil {
		protocolList := make([]AzureFirewallNetworkRuleProtocol, len(source.Protocols))
		for protocolIndex, protocolItem := range source.Protocols {
			// Shadow the loop variable to avoid aliasing
			protocolItem := protocolItem
			protocolList[protocolIndex] = genruntime.ToEnum(protocolItem, azureFirewallNetworkRuleProtocol_Values)
		}
		rule.Protocols = protocolList
	} else {
		rule.Protocols = nil
	}

	// SourceAddresses
	rule.SourceAddresses = genruntime.CloneSliceOfString(source.SourceAddresses)

	// SourceIpGroups
	rule.SourceIpGroups = genruntime.CloneSliceOfString(source.SourceIpGroups)

	// TranslatedAddress
	rule.TranslatedAddress = genruntime.ClonePointerToString(source.TranslatedAddress)

	// TranslatedFqdn
	rule.TranslatedFqdn = genruntime.ClonePointerToString(source.TranslatedFqdn)

	// TranslatedPort
	rule.TranslatedPort = genruntime.ClonePointerToString(source.TranslatedPort)

	// No error
	return nil
}

// AssignProperties_To_AzureFirewallNatRule populates the provided destination AzureFirewallNatRule from our AzureFirewallNatRule
func (rule *AzureFirewallNatRule) AssignProperties_To_AzureFirewallNatRule(destination *storage.AzureFirewallNatRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Description
	destination.Description = genruntime.ClonePointerToString(rule.Description)

	// DestinationAddresses
	destination.DestinationAddresses = genruntime.CloneSliceOfString(rule.DestinationAddresses)

	// DestinationPorts
	destination.DestinationPorts = genruntime.CloneSliceOfString(rule.DestinationPorts)

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Protocols
	if rule.Protocols != nil {
		protocolList := make([]string, len(rule.Protocols))
		for protocolIndex, protocolItem := range rule.Protocols {
			// Shadow the loop variable to avoid aliasing
			protocolItem := protocolItem
			protocolList[protocolIndex] = string(protocolItem)
		}
		destination.Protocols = protocolList
	} else {
		destination.Protocols = nil
	}

	// SourceAddresses
	destination.SourceAddresses = genruntime.CloneSliceOfString(rule.SourceAddresses)

	// SourceIpGroups
	destination.SourceIpGroups = genruntime.CloneSliceOfString(rule.SourceIpGroups)

	// TranslatedAddress
	destination.TranslatedAddress = genruntime.ClonePointerToString(rule.TranslatedAddress)

	// TranslatedFqdn
	destination.TranslatedFqdn = genruntime.ClonePointerToString(rule.TranslatedFqdn)

	// TranslatedPort
	destination.TranslatedPort = genruntime.ClonePointerToString(rule.TranslatedPort)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Properties of the network rule.
type AzureFirewallNetworkRule struct {
	// Description: Description of the rule.
	Description *string `json:"description,omitempty"`

	// DestinationAddresses: List of destination IP addresses.
	DestinationAddresses []string `json:"destinationAddresses,omitempty"`

	// DestinationFqdns: List of destination FQDNs.
	DestinationFqdns []string `json:"destinationFqdns,omitempty"`

	// DestinationIpGroups: List of destination IpGroups for this rule.
	DestinationIpGroups []string `json:"destinationIpGroups,omitempty"`

	// DestinationPorts: List of destination ports.
	DestinationPorts []string `json:"destinationPorts,omitempty"`

	// Name: Name of the network rule.
	Name *string `json:"name,omitempty"`

	// Protocols: Array of AzureFirewallNetworkRuleProtocols.
	Protocols []AzureFirewallNetworkRuleProtocol `json:"protocols,omitempty"`

	// SourceAddresses: List of source IP addresses for this rule.
	SourceAddresses []string `json:"sourceAddresses,omitempty"`

	// SourceIpGroups: List of source IpGroups for this rule.
	SourceIpGroups []string `json:"sourceIpGroups,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureFirewallNetworkRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *AzureFirewallNetworkRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.AzureFirewallNetworkRule{}

	// Set property "Description":
	if rule.Description != nil {
		description := *rule.Description
		result.Description = &description
	}

	// Set property "DestinationAddresses":
	for _, item := range rule.DestinationAddresses {
		result.DestinationAddresses = append(result.DestinationAddresses, item)
	}

	// Set property "DestinationFqdns":
	for _, item := range rule.DestinationFqdns {
		result.DestinationFqdns = append(result.DestinationFqdns, item)
	}

	// Set property "DestinationIpGroups":
	for _, item := range rule.DestinationIpGroups {
		result.DestinationIpGroups = append(result.DestinationIpGroups, item)
	}

	// Set property "DestinationPorts":
	for _, item := range rule.DestinationPorts {
		result.DestinationPorts = append(result.DestinationPorts, item)
	}

	// Set property "Name":
	if rule.Name != nil {
		name := *rule.Name
		result.Name = &name
	}

	// Set property "Protocols":
	for _, item := range rule.Protocols {
		var temp string
		temp = string(item)
		result.Protocols = append(result.Protocols, arm.AzureFirewallNetworkRuleProtocol(temp))
	}

	// Set property "SourceAddresses":
	for _, item := range rule.SourceAddresses {
		result.SourceAddresses = append(result.SourceAddresses, item)
	}

	// Set property "SourceIpGroups":
	for _, item := range rule.SourceIpGroups {
		result.SourceIpGroups = append(result.SourceIpGroups, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *AzureFirewallNetworkRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureFirewallNetworkRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *AzureFirewallNetworkRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureFirewallNetworkRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureFirewallNetworkRule, got %T", armInput)
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		rule.Description = &description
	}

	// Set property "DestinationAddresses":
	for _, item := range typedInput.DestinationAddresses {
		rule.DestinationAddresses = append(rule.DestinationAddresses, item)
	}

	// Set property "DestinationFqdns":
	for _, item := range typedInput.DestinationFqdns {
		rule.DestinationFqdns = append(rule.DestinationFqdns, item)
	}

	// Set property "DestinationIpGroups":
	for _, item := range typedInput.DestinationIpGroups {
		rule.DestinationIpGroups = append(rule.DestinationIpGroups, item)
	}

	// Set property "DestinationPorts":
	for _, item := range typedInput.DestinationPorts {
		rule.DestinationPorts = append(rule.DestinationPorts, item)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "Protocols":
	for _, item := range typedInput.Protocols {
		var temp string
		temp = string(item)
		rule.Protocols = append(rule.Protocols, AzureFirewallNetworkRuleProtocol(temp))
	}

	// Set property "SourceAddresses":
	for _, item := range typedInput.SourceAddresses {
		rule.SourceAddresses = append(rule.SourceAddresses, item)
	}

	// Set property "SourceIpGroups":
	for _, item := range typedInput.SourceIpGroups {
		rule.SourceIpGroups = append(rule.SourceIpGroups, item)
	}

	// No error
	return nil
}

// AssignProperties_From_AzureFirewallNetworkRule populates our AzureFirewallNetworkRule from the provided source AzureFirewallNetworkRule
func (rule *AzureFirewallNetworkRule) AssignProperties_From_AzureFirewallNetworkRule(source *storage.AzureFirewallNetworkRule) error {

	// Description
	rule.Description = genruntime.ClonePointerToString(source.Description)

	// DestinationAddresses
	rule.DestinationAddresses = genruntime.CloneSliceOfString(source.DestinationAddresses)

	// DestinationFqdns
	rule.DestinationFqdns = genruntime.CloneSliceOfString(source.DestinationFqdns)

	// DestinationIpGroups
	rule.DestinationIpGroups = genruntime.CloneSliceOfString(source.DestinationIpGroups)

	// DestinationPorts
	rule.DestinationPorts = genruntime.CloneSliceOfString(source.DestinationPorts)

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Protocols
	if source.Protocols != nil {
		protocolList := make([]AzureFirewallNetworkRuleProtocol, len(source.Protocols))
		for protocolIndex, protocolItem := range source.Protocols {
			// Shadow the loop variable to avoid aliasing
			protocolItem := protocolItem
			protocolList[protocolIndex] = genruntime.ToEnum(protocolItem, azureFirewallNetworkRuleProtocol_Values)
		}
		rule.Protocols = protocolList
	} else {
		rule.Protocols = nil
	}

	// SourceAddresses
	rule.SourceAddresses = genruntime.CloneSliceOfString(source.SourceAddresses)

	// SourceIpGroups
	rule.SourceIpGroups = genruntime.CloneSliceOfString(source.SourceIpGroups)

	// No error
	return nil
}

// AssignProperties_To_AzureFirewallNetworkRule populates the provided destination AzureFirewallNetworkRule from our AzureFirewallNetworkRule
func (rule *AzureFirewallNetworkRule) AssignProperties_To_AzureFirewallNetworkRule(destination *storage.AzureFirewallNetworkRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Description
	destination.Description = genruntime.ClonePointerToString(rule.Description)

	// DestinationAddresses
	destination.DestinationAddresses = genruntime.CloneSliceOfString(rule.DestinationAddresses)

	// DestinationFqdns
	destination.DestinationFqdns = genruntime.CloneSliceOfString(rule.DestinationFqdns)

	// DestinationIpGroups
	destination.DestinationIpGroups = genruntime.CloneSliceOfString(rule.DestinationIpGroups)

	// DestinationPorts
	destination.DestinationPorts = genruntime.CloneSliceOfString(rule.DestinationPorts)

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Protocols
	if rule.Protocols != nil {
		protocolList := make([]string, len(rule.Protocols))
		for protocolIndex, protocolItem := range rule.Protocols {
			// Shadow the loop variable to avoid aliasing
			protocolItem := protocolItem
			protocolList[protocolIndex] = string(protocolItem)
		}
		destination.Protocols = protocolList
	} else {
		destination.Protocols = nil
	}

	// SourceAddresses
	destination.SourceAddresses = genruntime.CloneSliceOfString(rule.SourceAddresses)

	// SourceIpGroups
	destination.SourceIpGroups = genruntime.CloneSliceOfString(rule.SourceIpGroups)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Properties of the AzureFirewallRCAction.
type AzureFirewallRCAction struct {
	// Type: The type of action.
	Type *AzureFirewallRCActionType `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureFirewallRCAction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *AzureFirewallRCAction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &arm.AzureFirewallRCAction{}

	// Set property "Type":
	if action.Type != nil {
		var temp string
		temp = string(*action.Type)
		typeVar := arm.AzureFirewallRCActionType(temp)
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *AzureFirewallRCAction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureFirewallRCAction{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *AzureFirewallRCAction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureFirewallRCAction)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureFirewallRCAction, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := AzureFirewallRCActionType(temp)
		action.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_AzureFirewallRCAction populates our AzureFirewallRCAction from the provided source AzureFirewallRCAction
func (action *AzureFirewallRCAction) AssignProperties_From_AzureFirewallRCAction(source *storage.AzureFirewallRCAction) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, azureFirewallRCActionType_Values)
		action.Type = &typeTemp
	} else {
		action.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureFirewallRCAction populates the provided destination AzureFirewallRCAction from our AzureFirewallRCAction
func (action *AzureFirewallRCAction) AssignProperties_To_AzureFirewallRCAction(destination *storage.AzureFirewallRCAction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if action.Type != nil {
		typeVar := string(*action.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"AZFW_Hub","AZFW_VNet"}
type AzureFirewallSku_Name string

const (
	AzureFirewallSku_Name_AZFW_Hub  = AzureFirewallSku_Name("AZFW_Hub")
	AzureFirewallSku_Name_AZFW_VNet = AzureFirewallSku_Name("AZFW_VNet")
)

// Mapping from string to AzureFirewallSku_Name
var azureFirewallSku_Name_Values = map[string]AzureFirewallSku_Name{
	"azfw_hub":  AzureFirewallSku_Name_AZFW_Hub,
	"azfw_vnet": AzureFirewallSku_Name_AZFW_VNet,
}

type AzureFirewallSku_Name_STATUS string

const (
	AzureFirewallSku_Name_STATUS_AZFW_Hub  = AzureFirewallSku_Name_STATUS("AZFW_Hub")
	AzureFirewallSku_Name_STATUS_AZFW_VNet = AzureFirewallSku_Name_STATUS("AZFW_VNet")
)

// Mapping from string to AzureFirewallSku_Name_STATUS
var azureFirewallSku_Name_STATUS_Values = map[string]AzureFirewallSku_Name_STATUS{
	"azfw_hub":  AzureFirewallSku_Name_STATUS_AZFW_Hub,
	"azfw_vnet": AzureFirewallSku_Name_STATUS_AZFW_VNet,
}

// +kubebuilder:validation:Enum={"Basic","Premium","Standard"}
type AzureFirewallSku_Tier string

const (
	AzureFirewallSku_Tier_Basic    = AzureFirewallSku_Tier("Basic")
	AzureFirewallSku_Tier_Premium  = AzureFirewallSku_Tier("Premium")
	AzureFirewallSku_Tier_Standard = AzureFirewallSku_Tier("Standard")
)

// Mapping from string to AzureFirewallSku_Tier
var azureFirewallSku_Tier_Values = map[string]AzureFirewallSku_Tier{
	"basic":    AzureFirewallSku_Tier_Basic,
	"premium":  AzureFirewallSku_Tier_Premium,
	"standard": AzureFirewallSku_Tier_Standard,
}

type AzureFirewallSku_Tier_STATUS string

const (
	AzureFirewallSku_Tier_STATUS_Basic    = AzureFirewallSku_Tier_STATUS("Basic")
	AzureFirewallSku_Tier_STATUS_Premium  = AzureFirewallSku_Tier_STATUS("Premium")
	AzureFirewallSku_Tier_STATUS_Standard = AzureFirewallSku_Tier_STATUS("Standard")
)

// Mapping from string to AzureFirewallSku_Tier_STATUS
var azureFirewallSku_Tier_STATUS_Values = map[string]AzureFirewallSku_Tier_STATUS{
	"basic":    AzureFirewallSku_Tier_STATUS_Basic,
	"premium":  AzureFirewallSku_Tier_STATUS_Premium,
	"standard": AzureFirewallSku_Tier_STATUS_Standard,
}

// Public IP addresses associated with azure firewall.
type HubPublicIPAddresses struct {
	// Addresses: The list of Public IP addresses associated with azure firewall or IP addresses to be retained.
	Addresses []AzureFirewallPublicIPAddress `json:"addresses,omitempty"`

	// Count: The number of Public IP addresses associated with azure firewall.
	Count *int `json:"count,omitempty"`
}

var _ genruntime.ARMTransformer = &HubPublicIPAddresses{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (addresses *HubPublicIPAddresses) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if addresses == nil {
		return nil, nil
	}
	result := &arm.HubPublicIPAddresses{}

	// Set property "Addresses":
	for _, item := range addresses.Addresses {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Addresses = append(result.Addresses, *item_ARM.(*arm.AzureFirewallPublicIPAddress))
	}

	// Set property "Count":
	if addresses.Count != nil {
		count := *addresses.Count
		result.Count = &count
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (addresses *HubPublicIPAddresses) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HubPublicIPAddresses{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (addresses *HubPublicIPAddresses) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HubPublicIPAddresses)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HubPublicIPAddresses, got %T", armInput)
	}

	// Set property "Addresses":
	for _, item := range typedInput.Addresses {
		var item1 AzureFirewallPublicIPAddress
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		addresses.Addresses = append(addresses.Addresses, item1)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		addresses.Count = &count
	}

	// No error
	return nil
}

// AssignProperties_From_HubPublicIPAddresses populates our HubPublicIPAddresses from the provided source HubPublicIPAddresses
func (addresses *HubPublicIPAddresses) AssignProperties_From_HubPublicIPAddresses(source *storage.HubPublicIPAddresses) error {

	// Addresses
	if source.Addresses != nil {
		addressList := make([]AzureFirewallPublicIPAddress, len(source.Addresses))
		for addressIndex, addressItem := range source.Addresses {
			// Shadow the loop variable to avoid aliasing
			addressItem := addressItem
			var address AzureFirewallPublicIPAddress
			err := address.AssignProperties_From_AzureFirewallPublicIPAddress(&addressItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_AzureFirewallPublicIPAddress() to populate field Addresses")
			}
			addressList[addressIndex] = address
		}
		addresses.Addresses = addressList
	} else {
		addresses.Addresses = nil
	}

	// Count
	addresses.Count = genruntime.ClonePointerToInt(source.Count)

	// No error
	return nil
}

// AssignProperties_To_HubPublicIPAddresses populates the provided destination HubPublicIPAddresses from our HubPublicIPAddresses
func (addresses *HubPublicIPAddresses) AssignProperties_To_HubPublicIPAddresses(destination *storage.HubPublicIPAddresses) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Addresses
	if addresses.Addresses != nil {
		addressList := make([]storage.AzureFirewallPublicIPAddress, len(addresses.Addresses))
		for addressIndex, addressItem := range addresses.Addresses {
			// Shadow the loop variable to avoid aliasing
			addressItem := addressItem
			var address storage.AzureFirewallPublicIPAddress
			err := addressItem.AssignProperties_To_AzureFirewallPublicIPAddress(&address)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_AzureFirewallPublicIPAddress() to populate field Addresses")
			}
			addressList[addressIndex] = address
		}
		destination.Addresses = addressList
	} else {
		destination.Addresses = nil
	}

	// Count
	destination.Count = genruntime.ClonePointerToInt(addresses.Count)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_HubPublicIPAddresses_STATUS populates our HubPublicIPAddresses from the provided source HubPublicIPAddresses_STATUS
func (addresses *HubPublicIPAddresses) Initialize_From_HubPublicIPAddresses_STATUS(source *HubPublicIPAddresses_STATUS) error {

	// Addresses
	if source.Addresses != nil {
		addressList := make([]AzureFirewallPublicIPAddress, len(source.Addresses))
		for addressIndex, addressItem := range source.Addresses {
			// Shadow the loop variable to avoid aliasing
			addressItem := addressItem
			var address AzureFirewallPublicIPAddress
			err := address.Initialize_From_AzureFirewallPublicIPAddress_STATUS(&addressItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_AzureFirewallPublicIPAddress_STATUS() to populate field Addresses")
			}
			addressList[addressIndex] = address
		}
		addresses.Addresses = addressList
	} else {
		addresses.Addresses = nil
	}

	// Count
	addresses.Count = genruntime.ClonePointerToInt(source.Count)

	// No error
	return nil
}

// Public IP addresses associated with azure firewall.
type HubPublicIPAddresses_STATUS struct {
	// Addresses: The list of Public IP addresses associated with azure firewall or IP addresses to be retained.
	Addresses []AzureFirewallPublicIPAddress_STATUS `json:"addresses,omitempty"`

	// Count: The number of Public IP addresses associated with azure firewall.
	Count *int `json:"count,omitempty"`
}

var _ genruntime.FromARMConverter = &HubPublicIPAddresses_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (addresses *HubPublicIPAddresses_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HubPublicIPAddresses_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (addresses *HubPublicIPAddresses_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HubPublicIPAddresses_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HubPublicIPAddresses_STATUS, got %T", armInput)
	}

	// Set property "Addresses":
	for _, item := range typedInput.Addresses {
		var item1 AzureFirewallPublicIPAddress_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		addresses.Addresses = append(addresses.Addresses, item1)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		addresses.Count = &count
	}

	// No error
	return nil
}

// AssignProperties_From_HubPublicIPAddresses_STATUS populates our HubPublicIPAddresses_STATUS from the provided source HubPublicIPAddresses_STATUS
func (addresses *HubPublicIPAddresses_STATUS) AssignProperties_From_HubPublicIPAddresses_STATUS(source *storage.HubPublicIPAddresses_STATUS) error {

	// Addresses
	if source.Addresses != nil {
		addressList := make([]AzureFirewallPublicIPAddress_STATUS, len(source.Addresses))
		for addressIndex, addressItem := range source.Addresses {
			// Shadow the loop variable to avoid aliasing
			addressItem := addressItem
			var address AzureFirewallPublicIPAddress_STATUS
			err := address.AssignProperties_From_AzureFirewallPublicIPAddress_STATUS(&addressItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_AzureFirewallPublicIPAddress_STATUS() to populate field Addresses")
			}
			addressList[addressIndex] = address
		}
		addresses.Addresses = addressList
	} else {
		addresses.Addresses = nil
	}

	// Count
	addresses.Count = genruntime.ClonePointerToInt(source.Count)

	// No error
	return nil
}

// AssignProperties_To_HubPublicIPAddresses_STATUS populates the provided destination HubPublicIPAddresses_STATUS from our HubPublicIPAddresses_STATUS
func (addresses *HubPublicIPAddresses_STATUS) AssignProperties_To_HubPublicIPAddresses_STATUS(destination *storage.HubPublicIPAddresses_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Addresses
	if addresses.Addresses != nil {
		addressList := make([]storage.AzureFirewallPublicIPAddress_STATUS, len(addresses.Addresses))
		for addressIndex, addressItem := range addresses.Addresses {
			// Shadow the loop variable to avoid aliasing
			addressItem := addressItem
			var address storage.AzureFirewallPublicIPAddress_STATUS
			err := addressItem.AssignProperties_To_AzureFirewallPublicIPAddress_STATUS(&address)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_AzureFirewallPublicIPAddress_STATUS() to populate field Addresses")
			}
			addressList[addressIndex] = address
		}
		destination.Addresses = addressList
	} else {
		destination.Addresses = nil
	}

	// Count
	destination.Count = genruntime.ClonePointerToInt(addresses.Count)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Properties of the application rule protocol.
type AzureFirewallApplicationRuleProtocol struct {
	// +kubebuilder:validation:Maximum=64000
	// +kubebuilder:validation:Minimum=0
	// Port: Port number for the protocol, cannot be greater than 64000. This field is optional.
	Port *int `json:"port,omitempty"`

	// ProtocolType: Protocol type.
	ProtocolType *AzureFirewallApplicationRuleProtocolType `json:"protocolType,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureFirewallApplicationRuleProtocol{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (protocol *AzureFirewallApplicationRuleProtocol) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if protocol == nil {
		return nil, nil
	}
	result := &arm.AzureFirewallApplicationRuleProtocol{}

	// Set property "Port":
	if protocol.Port != nil {
		port := *protocol.Port
		result.Port = &port
	}

	// Set property "ProtocolType":
	if protocol.ProtocolType != nil {
		var temp string
		temp = string(*protocol.ProtocolType)
		protocolType := arm.AzureFirewallApplicationRuleProtocolType(temp)
		result.ProtocolType = &protocolType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (protocol *AzureFirewallApplicationRuleProtocol) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureFirewallApplicationRuleProtocol{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (protocol *AzureFirewallApplicationRuleProtocol) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureFirewallApplicationRuleProtocol)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureFirewallApplicationRuleProtocol, got %T", armInput)
	}

	// Set property "Port":
	if typedInput.Port != nil {
		port := *typedInput.Port
		protocol.Port = &port
	}

	// Set property "ProtocolType":
	if typedInput.ProtocolType != nil {
		var temp string
		temp = string(*typedInput.ProtocolType)
		protocolType := AzureFirewallApplicationRuleProtocolType(temp)
		protocol.ProtocolType = &protocolType
	}

	// No error
	return nil
}

// AssignProperties_From_AzureFirewallApplicationRuleProtocol populates our AzureFirewallApplicationRuleProtocol from the provided source AzureFirewallApplicationRuleProtocol
func (protocol *AzureFirewallApplicationRuleProtocol) AssignProperties_From_AzureFirewallApplicationRuleProtocol(source *storage.AzureFirewallApplicationRuleProtocol) error {

	// Port
	protocol.Port = genruntime.ClonePointerToInt(source.Port)

	// ProtocolType
	if source.ProtocolType != nil {
		protocolType := *source.ProtocolType
		protocolTypeTemp := genruntime.ToEnum(protocolType, azureFirewallApplicationRuleProtocolType_Values)
		protocol.ProtocolType = &protocolTypeTemp
	} else {
		protocol.ProtocolType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureFirewallApplicationRuleProtocol populates the provided destination AzureFirewallApplicationRuleProtocol from our AzureFirewallApplicationRuleProtocol
func (protocol *AzureFirewallApplicationRuleProtocol) AssignProperties_To_AzureFirewallApplicationRuleProtocol(destination *storage.AzureFirewallApplicationRuleProtocol) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Port
	destination.Port = genruntime.ClonePointerToInt(protocol.Port)

	// ProtocolType
	if protocol.ProtocolType != nil {
		protocolType := string(*protocol.ProtocolType)
		destination.ProtocolType = &protocolType
	} else {
		destination.ProtocolType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The action type of a NAT rule collection.
// +kubebuilder:validation:Enum={"Dnat","Snat"}
type AzureFirewallNatRCActionType string

const (
	AzureFirewallNatRCActionType_Dnat = AzureFirewallNatRCActionType("Dnat")
	AzureFirewallNatRCActionType_Snat = AzureFirewallNatRCActionType("Snat")
)

// Mapping from string to AzureFirewallNatRCActionType
var azureFirewallNatRCActionType_Values = map[string]AzureFirewallNatRCActionType{
	"dnat": AzureFirewallNatRCActionType_Dnat,
	"snat": AzureFirewallNatRCActionType_Snat,
}

// The protocol of a Network Rule resource.
// +kubebuilder:validation:Enum={"Any","ICMP","TCP","UDP"}
type AzureFirewallNetworkRuleProtocol string

const (
	AzureFirewallNetworkRuleProtocol_Any  = AzureFirewallNetworkRuleProtocol("Any")
	AzureFirewallNetworkRuleProtocol_ICMP = AzureFirewallNetworkRuleProtocol("ICMP")
	AzureFirewallNetworkRuleProtocol_TCP  = AzureFirewallNetworkRuleProtocol("TCP")
	AzureFirewallNetworkRuleProtocol_UDP  = AzureFirewallNetworkRuleProtocol("UDP")
)

// Mapping from string to AzureFirewallNetworkRuleProtocol
var azureFirewallNetworkRuleProtocol_Values = map[string]AzureFirewallNetworkRuleProtocol{
	"any":  AzureFirewallNetworkRuleProtocol_Any,
	"icmp": AzureFirewallNetworkRuleProtocol_ICMP,
	"tcp":  AzureFirewallNetworkRuleProtocol_TCP,
	"udp":  AzureFirewallNetworkRuleProtocol_UDP,
}

// Public IP Address associated with azure firewall.
type AzureFirewallPublicIPAddress struct {
	// Address: Public IP Address value.
	Address *string `json:"address,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureFirewallPublicIPAddress{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (address *AzureFirewallPublicIPAddress) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if address == nil {
		return nil, nil
	}
	result := &arm.AzureFirewallPublicIPAddress{}

	// Set property "Address":
	if address.Address != nil {
		address1 := *address.Address
		result.Address = &address1
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (address *AzureFirewallPublicIPAddress) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureFirewallPublicIPAddress{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (address *AzureFirewallPublicIPAddress) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureFirewallPublicIPAddress)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureFirewallPublicIPAddress, got %T", armInput)
	}

	// Set property "Address":
	if typedInput.Address != nil {
		address1 := *typedInput.Address
		address.Address = &address1
	}

	// No error
	return nil
}

// AssignProperties_From_AzureFirewallPublicIPAddress populates our AzureFirewallPublicIPAddress from the provided source AzureFirewallPublicIPAddress
func (address *AzureFirewallPublicIPAddress) AssignProperties_From_AzureFirewallPublicIPAddress(source *storage.AzureFirewallPublicIPAddress) error {

	// Address
	address.Address = genruntime.ClonePointerToString(source.Address)

	// No error
	return nil
}

// AssignProperties_To_AzureFirewallPublicIPAddress populates the provided destination AzureFirewallPublicIPAddress from our AzureFirewallPublicIPAddress
func (address *AzureFirewallPublicIPAddress) AssignProperties_To_AzureFirewallPublicIPAddress(destination *storage.AzureFirewallPublicIPAddress) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Address
	destination.Address = genruntime.ClonePointerToString(address.Address)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AzureFirewallPublicIPAddress_STATUS populates our AzureFirewallPublicIPAddress from the provided source AzureFirewallPublicIPAddress_STATUS
func (address *AzureFirewallPublicIPAddress) Initialize_From_AzureFirewallPublicIPAddress_STATUS(source *AzureFirewallPublicIPAddress_STATUS) error {

	// Address
	address.Address = genruntime.ClonePointerToString(source.Address)

	// No error
	return nil
}

// Public IP Address associated with azure firewall.
type AzureFirewallPublicIPAddress_STATUS struct {
	// Address: Public IP Address value.
	Address *string `json:"address,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureFirewallPublicIPAddress_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (address *AzureFirewallPublicIPAddress_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureFirewallPublicIPAddress_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (address *AzureFirewallPublicIPAddress_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureFirewallPublicIPAddress_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureFirewallPublicIPAddress_STATUS, got %T", armInput)
	}

	// Set property "Address":
	if typedInput.Address != nil {
		address1 := *typedInput.Address
		address.Address = &address1
	}

	// No error
	return nil
}

// AssignProperties_From_AzureFirewallPublicIPAddress_STATUS populates our AzureFirewallPublicIPAddress_STATUS from the provided source AzureFirewallPublicIPAddress_STATUS
func (address *AzureFirewallPublicIPAddress_STATUS) AssignProperties_From_AzureFirewallPublicIPAddress_STATUS(source *storage.AzureFirewallPublicIPAddress_STATUS) error {

	// Address
	address.Address = genruntime.ClonePointerToString(source.Address)

	// No error
	return nil
}

// AssignProperties_To_AzureFirewallPublicIPAddress_STATUS populates the provided destination AzureFirewallPublicIPAddress_STATUS from our AzureFirewallPublicIPAddress_STATUS
func (address *AzureFirewallPublicIPAddress_STATUS) AssignProperties_To_AzureFirewallPublicIPAddress_STATUS(destination *storage.AzureFirewallPublicIPAddress_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Address
	destination.Address = genruntime.ClonePointerToString(address.Address)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The action type of a rule collection.
// +kubebuilder:validation:Enum={"Allow","Deny"}
type AzureFirewallRCActionType string

const (
	AzureFirewallRCActionType_Allow = AzureFirewallRCActionType("Allow")
	AzureFirewallRCActionType_Deny  = AzureFirewallRCActionType("Deny")
)

// Mapping from string to AzureFirewallRCActionType
var azureFirewallRCActionType_Values = map[string]AzureFirewallRCActionType{
	"allow": AzureFirewallRCActionType_Allow,
	"deny":  AzureFirewallRCActionType_Deny,
}

// The protocol type of a Application Rule resource.
// +kubebuilder:validation:Enum={"Http","Https","Mssql"}
type AzureFirewallApplicationRuleProtocolType string

const (
	AzureFirewallApplicationRuleProtocolType_Http  = AzureFirewallApplicationRuleProtocolType("Http")
	AzureFirewallApplicationRuleProtocolType_Https = AzureFirewallApplicationRuleProtocolType("Https")
	AzureFirewallApplicationRuleProtocolType_Mssql = AzureFirewallApplicationRuleProtocolType("Mssql")
)

// Mapping from string to AzureFirewallApplicationRuleProtocolType
var azureFirewallApplicationRuleProtocolType_Values = map[string]AzureFirewallApplicationRuleProtocolType{
	"http":  AzureFirewallApplicationRuleProtocolType_Http,
	"https": AzureFirewallApplicationRuleProtocolType_Https,
	"mssql": AzureFirewallApplicationRuleProtocolType_Mssql,
}

func init() {
	SchemeBuilder.Register(&AzureFirewall{}, &AzureFirewallList{})
}
