// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_DnsSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DnsSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDnsSettings, DnsSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDnsSettings runs a test to see if a specific instance of DnsSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForDnsSettings(subject DnsSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DnsSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DnsSettings instances for property testing - lazily instantiated by DnsSettingsGenerator()
var dnsSettingsGenerator gopter.Gen

// DnsSettingsGenerator returns a generator of DnsSettings instances for property testing.
func DnsSettingsGenerator() gopter.Gen {
	if dnsSettingsGenerator != nil {
		return dnsSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDnsSettings(generators)
	dnsSettingsGenerator = gen.Struct(reflect.TypeOf(DnsSettings{}), generators)

	return dnsSettingsGenerator
}

// AddIndependentPropertyGeneratorsForDnsSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDnsSettings(gens map[string]gopter.Gen) {
	gens["EnableProxy"] = gen.PtrOf(gen.Bool())
	gens["RequireProxyForNetworkRules"] = gen.PtrOf(gen.Bool())
	gens["Servers"] = gen.SliceOf(gen.AlphaString())
}

func Test_DnsSettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DnsSettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDnsSettings_STATUS, DnsSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDnsSettings_STATUS runs a test to see if a specific instance of DnsSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDnsSettings_STATUS(subject DnsSettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DnsSettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DnsSettings_STATUS instances for property testing - lazily instantiated by DnsSettings_STATUSGenerator()
var dnsSettings_STATUSGenerator gopter.Gen

// DnsSettings_STATUSGenerator returns a generator of DnsSettings_STATUS instances for property testing.
func DnsSettings_STATUSGenerator() gopter.Gen {
	if dnsSettings_STATUSGenerator != nil {
		return dnsSettings_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDnsSettings_STATUS(generators)
	dnsSettings_STATUSGenerator = gen.Struct(reflect.TypeOf(DnsSettings_STATUS{}), generators)

	return dnsSettings_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDnsSettings_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDnsSettings_STATUS(gens map[string]gopter.Gen) {
	gens["EnableProxy"] = gen.PtrOf(gen.Bool())
	gens["RequireProxyForNetworkRules"] = gen.PtrOf(gen.Bool())
	gens["Servers"] = gen.SliceOf(gen.AlphaString())
}

func Test_ExplicitProxy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExplicitProxy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExplicitProxy, ExplicitProxyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExplicitProxy runs a test to see if a specific instance of ExplicitProxy round trips to JSON and back losslessly
func RunJSONSerializationTestForExplicitProxy(subject ExplicitProxy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExplicitProxy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExplicitProxy instances for property testing - lazily instantiated by ExplicitProxyGenerator()
var explicitProxyGenerator gopter.Gen

// ExplicitProxyGenerator returns a generator of ExplicitProxy instances for property testing.
func ExplicitProxyGenerator() gopter.Gen {
	if explicitProxyGenerator != nil {
		return explicitProxyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExplicitProxy(generators)
	explicitProxyGenerator = gen.Struct(reflect.TypeOf(ExplicitProxy{}), generators)

	return explicitProxyGenerator
}

// AddIndependentPropertyGeneratorsForExplicitProxy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExplicitProxy(gens map[string]gopter.Gen) {
	gens["EnableExplicitProxy"] = gen.PtrOf(gen.Bool())
	gens["EnablePacFile"] = gen.PtrOf(gen.Bool())
	gens["HttpPort"] = gen.PtrOf(gen.Int())
	gens["HttpsPort"] = gen.PtrOf(gen.Int())
	gens["PacFile"] = gen.PtrOf(gen.AlphaString())
	gens["PacFilePort"] = gen.PtrOf(gen.Int())
}

func Test_ExplicitProxy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExplicitProxy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExplicitProxy_STATUS, ExplicitProxy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExplicitProxy_STATUS runs a test to see if a specific instance of ExplicitProxy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForExplicitProxy_STATUS(subject ExplicitProxy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExplicitProxy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExplicitProxy_STATUS instances for property testing - lazily instantiated by
// ExplicitProxy_STATUSGenerator()
var explicitProxy_STATUSGenerator gopter.Gen

// ExplicitProxy_STATUSGenerator returns a generator of ExplicitProxy_STATUS instances for property testing.
func ExplicitProxy_STATUSGenerator() gopter.Gen {
	if explicitProxy_STATUSGenerator != nil {
		return explicitProxy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExplicitProxy_STATUS(generators)
	explicitProxy_STATUSGenerator = gen.Struct(reflect.TypeOf(ExplicitProxy_STATUS{}), generators)

	return explicitProxy_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForExplicitProxy_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExplicitProxy_STATUS(gens map[string]gopter.Gen) {
	gens["EnableExplicitProxy"] = gen.PtrOf(gen.Bool())
	gens["EnablePacFile"] = gen.PtrOf(gen.Bool())
	gens["HttpPort"] = gen.PtrOf(gen.Int())
	gens["HttpsPort"] = gen.PtrOf(gen.Int())
	gens["PacFile"] = gen.PtrOf(gen.AlphaString())
	gens["PacFilePort"] = gen.PtrOf(gen.Int())
}

func Test_FirewallPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicy, FirewallPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicy runs a test to see if a specific instance of FirewallPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicy(subject FirewallPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicy instances for property testing - lazily instantiated by FirewallPolicyGenerator()
var firewallPolicyGenerator gopter.Gen

// FirewallPolicyGenerator returns a generator of FirewallPolicy instances for property testing.
func FirewallPolicyGenerator() gopter.Gen {
	if firewallPolicyGenerator != nil {
		return firewallPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForFirewallPolicy(generators)
	firewallPolicyGenerator = gen.Struct(reflect.TypeOf(FirewallPolicy{}), generators)

	return firewallPolicyGenerator
}

// AddRelatedPropertyGeneratorsForFirewallPolicy is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicy(gens map[string]gopter.Gen) {
	gens["Spec"] = FirewallPolicy_SpecGenerator()
	gens["Status"] = FirewallPolicy_STATUSGenerator()
}

func Test_FirewallPolicyCertificateAuthority_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyCertificateAuthority via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyCertificateAuthority, FirewallPolicyCertificateAuthorityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyCertificateAuthority runs a test to see if a specific instance of FirewallPolicyCertificateAuthority round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyCertificateAuthority(subject FirewallPolicyCertificateAuthority) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyCertificateAuthority
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyCertificateAuthority instances for property testing - lazily instantiated by
// FirewallPolicyCertificateAuthorityGenerator()
var firewallPolicyCertificateAuthorityGenerator gopter.Gen

// FirewallPolicyCertificateAuthorityGenerator returns a generator of FirewallPolicyCertificateAuthority instances for property testing.
func FirewallPolicyCertificateAuthorityGenerator() gopter.Gen {
	if firewallPolicyCertificateAuthorityGenerator != nil {
		return firewallPolicyCertificateAuthorityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyCertificateAuthority(generators)
	firewallPolicyCertificateAuthorityGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyCertificateAuthority{}), generators)

	return firewallPolicyCertificateAuthorityGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyCertificateAuthority is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyCertificateAuthority(gens map[string]gopter.Gen) {
	gens["KeyVaultSecretId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_FirewallPolicyCertificateAuthority_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyCertificateAuthority_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyCertificateAuthority_STATUS, FirewallPolicyCertificateAuthority_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyCertificateAuthority_STATUS runs a test to see if a specific instance of FirewallPolicyCertificateAuthority_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyCertificateAuthority_STATUS(subject FirewallPolicyCertificateAuthority_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyCertificateAuthority_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyCertificateAuthority_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyCertificateAuthority_STATUSGenerator()
var firewallPolicyCertificateAuthority_STATUSGenerator gopter.Gen

// FirewallPolicyCertificateAuthority_STATUSGenerator returns a generator of FirewallPolicyCertificateAuthority_STATUS instances for property testing.
func FirewallPolicyCertificateAuthority_STATUSGenerator() gopter.Gen {
	if firewallPolicyCertificateAuthority_STATUSGenerator != nil {
		return firewallPolicyCertificateAuthority_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyCertificateAuthority_STATUS(generators)
	firewallPolicyCertificateAuthority_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyCertificateAuthority_STATUS{}), generators)

	return firewallPolicyCertificateAuthority_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyCertificateAuthority_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyCertificateAuthority_STATUS(gens map[string]gopter.Gen) {
	gens["KeyVaultSecretId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_FirewallPolicyInsights_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyInsights via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyInsights, FirewallPolicyInsightsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyInsights runs a test to see if a specific instance of FirewallPolicyInsights round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyInsights(subject FirewallPolicyInsights) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyInsights
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyInsights instances for property testing - lazily instantiated by
// FirewallPolicyInsightsGenerator()
var firewallPolicyInsightsGenerator gopter.Gen

// FirewallPolicyInsightsGenerator returns a generator of FirewallPolicyInsights instances for property testing.
// We first initialize firewallPolicyInsightsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyInsightsGenerator() gopter.Gen {
	if firewallPolicyInsightsGenerator != nil {
		return firewallPolicyInsightsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyInsights(generators)
	firewallPolicyInsightsGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyInsights{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyInsights(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyInsights(generators)
	firewallPolicyInsightsGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyInsights{}), generators)

	return firewallPolicyInsightsGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyInsights is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyInsights(gens map[string]gopter.Gen) {
	gens["IsEnabled"] = gen.PtrOf(gen.Bool())
	gens["RetentionDays"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForFirewallPolicyInsights is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyInsights(gens map[string]gopter.Gen) {
	gens["LogAnalyticsResources"] = gen.PtrOf(FirewallPolicyLogAnalyticsResourcesGenerator())
}

func Test_FirewallPolicyInsights_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyInsights_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyInsights_STATUS, FirewallPolicyInsights_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyInsights_STATUS runs a test to see if a specific instance of FirewallPolicyInsights_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyInsights_STATUS(subject FirewallPolicyInsights_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyInsights_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyInsights_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyInsights_STATUSGenerator()
var firewallPolicyInsights_STATUSGenerator gopter.Gen

// FirewallPolicyInsights_STATUSGenerator returns a generator of FirewallPolicyInsights_STATUS instances for property testing.
// We first initialize firewallPolicyInsights_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyInsights_STATUSGenerator() gopter.Gen {
	if firewallPolicyInsights_STATUSGenerator != nil {
		return firewallPolicyInsights_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyInsights_STATUS(generators)
	firewallPolicyInsights_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyInsights_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyInsights_STATUS(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyInsights_STATUS(generators)
	firewallPolicyInsights_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyInsights_STATUS{}), generators)

	return firewallPolicyInsights_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyInsights_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyInsights_STATUS(gens map[string]gopter.Gen) {
	gens["IsEnabled"] = gen.PtrOf(gen.Bool())
	gens["RetentionDays"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForFirewallPolicyInsights_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyInsights_STATUS(gens map[string]gopter.Gen) {
	gens["LogAnalyticsResources"] = gen.PtrOf(FirewallPolicyLogAnalyticsResources_STATUSGenerator())
}

func Test_FirewallPolicyIntrusionDetection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyIntrusionDetection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyIntrusionDetection, FirewallPolicyIntrusionDetectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyIntrusionDetection runs a test to see if a specific instance of FirewallPolicyIntrusionDetection round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyIntrusionDetection(subject FirewallPolicyIntrusionDetection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyIntrusionDetection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyIntrusionDetection instances for property testing - lazily instantiated by
// FirewallPolicyIntrusionDetectionGenerator()
var firewallPolicyIntrusionDetectionGenerator gopter.Gen

// FirewallPolicyIntrusionDetectionGenerator returns a generator of FirewallPolicyIntrusionDetection instances for property testing.
// We first initialize firewallPolicyIntrusionDetectionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyIntrusionDetectionGenerator() gopter.Gen {
	if firewallPolicyIntrusionDetectionGenerator != nil {
		return firewallPolicyIntrusionDetectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetection(generators)
	firewallPolicyIntrusionDetectionGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetection{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetection(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetection(generators)
	firewallPolicyIntrusionDetectionGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetection{}), generators)

	return firewallPolicyIntrusionDetectionGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetection is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetection(gens map[string]gopter.Gen) {
	gens["Mode"] = gen.PtrOf(gen.AlphaString())
	gens["Profile"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetection is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetection(gens map[string]gopter.Gen) {
	gens["Configuration"] = gen.PtrOf(FirewallPolicyIntrusionDetectionConfigurationGenerator())
}

func Test_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyIntrusionDetectionBypassTrafficSpecifications via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications, FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications runs a test to see if a specific instance of FirewallPolicyIntrusionDetectionBypassTrafficSpecifications round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications(subject FirewallPolicyIntrusionDetectionBypassTrafficSpecifications) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyIntrusionDetectionBypassTrafficSpecifications
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyIntrusionDetectionBypassTrafficSpecifications instances for property testing - lazily
// instantiated by FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator()
var firewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator gopter.Gen

// FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator returns a generator of FirewallPolicyIntrusionDetectionBypassTrafficSpecifications instances for property testing.
func FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator() gopter.Gen {
	if firewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator != nil {
		return firewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications(generators)
	firewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetectionBypassTrafficSpecifications{}), generators)

	return firewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DestinationAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationIpGroups"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationPorts"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.AlphaString())
	gens["SourceAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["SourceIpGroups"] = gen.SliceOf(gen.AlphaString())
}

func Test_FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS, FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS runs a test to see if a specific instance of FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS(subject FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS instances for property testing -
// lazily instantiated by FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator()
var firewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator gopter.Gen

// FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator returns a generator of FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS instances for property testing.
func FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator() gopter.Gen {
	if firewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator != nil {
		return firewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS(generators)
	firewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS{}), generators)

	return firewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUS(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["DestinationAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationIpGroups"] = gen.SliceOf(gen.AlphaString())
	gens["DestinationPorts"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.AlphaString())
	gens["SourceAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["SourceIpGroups"] = gen.SliceOf(gen.AlphaString())
}

func Test_FirewallPolicyIntrusionDetectionConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyIntrusionDetectionConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyIntrusionDetectionConfiguration, FirewallPolicyIntrusionDetectionConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyIntrusionDetectionConfiguration runs a test to see if a specific instance of FirewallPolicyIntrusionDetectionConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyIntrusionDetectionConfiguration(subject FirewallPolicyIntrusionDetectionConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyIntrusionDetectionConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyIntrusionDetectionConfiguration instances for property testing - lazily instantiated by
// FirewallPolicyIntrusionDetectionConfigurationGenerator()
var firewallPolicyIntrusionDetectionConfigurationGenerator gopter.Gen

// FirewallPolicyIntrusionDetectionConfigurationGenerator returns a generator of FirewallPolicyIntrusionDetectionConfiguration instances for property testing.
// We first initialize firewallPolicyIntrusionDetectionConfigurationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyIntrusionDetectionConfigurationGenerator() gopter.Gen {
	if firewallPolicyIntrusionDetectionConfigurationGenerator != nil {
		return firewallPolicyIntrusionDetectionConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration(generators)
	firewallPolicyIntrusionDetectionConfigurationGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetectionConfiguration{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration(generators)
	firewallPolicyIntrusionDetectionConfigurationGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetectionConfiguration{}), generators)

	return firewallPolicyIntrusionDetectionConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration(gens map[string]gopter.Gen) {
	gens["PrivateRanges"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration(gens map[string]gopter.Gen) {
	gens["BypassTrafficSettings"] = gen.SliceOf(FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsGenerator())
	gens["SignatureOverrides"] = gen.SliceOf(FirewallPolicyIntrusionDetectionSignatureSpecificationGenerator())
}

func Test_FirewallPolicyIntrusionDetectionConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyIntrusionDetectionConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyIntrusionDetectionConfiguration_STATUS, FirewallPolicyIntrusionDetectionConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyIntrusionDetectionConfiguration_STATUS runs a test to see if a specific instance of FirewallPolicyIntrusionDetectionConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyIntrusionDetectionConfiguration_STATUS(subject FirewallPolicyIntrusionDetectionConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyIntrusionDetectionConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyIntrusionDetectionConfiguration_STATUS instances for property testing - lazily
// instantiated by FirewallPolicyIntrusionDetectionConfiguration_STATUSGenerator()
var firewallPolicyIntrusionDetectionConfiguration_STATUSGenerator gopter.Gen

// FirewallPolicyIntrusionDetectionConfiguration_STATUSGenerator returns a generator of FirewallPolicyIntrusionDetectionConfiguration_STATUS instances for property testing.
// We first initialize firewallPolicyIntrusionDetectionConfiguration_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyIntrusionDetectionConfiguration_STATUSGenerator() gopter.Gen {
	if firewallPolicyIntrusionDetectionConfiguration_STATUSGenerator != nil {
		return firewallPolicyIntrusionDetectionConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration_STATUS(generators)
	firewallPolicyIntrusionDetectionConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetectionConfiguration_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration_STATUS(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration_STATUS(generators)
	firewallPolicyIntrusionDetectionConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetectionConfiguration_STATUS{}), generators)

	return firewallPolicyIntrusionDetectionConfiguration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["PrivateRanges"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetectionConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["BypassTrafficSettings"] = gen.SliceOf(FirewallPolicyIntrusionDetectionBypassTrafficSpecifications_STATUSGenerator())
	gens["SignatureOverrides"] = gen.SliceOf(FirewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator())
}

func Test_FirewallPolicyIntrusionDetectionSignatureSpecification_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyIntrusionDetectionSignatureSpecification via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyIntrusionDetectionSignatureSpecification, FirewallPolicyIntrusionDetectionSignatureSpecificationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyIntrusionDetectionSignatureSpecification runs a test to see if a specific instance of FirewallPolicyIntrusionDetectionSignatureSpecification round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyIntrusionDetectionSignatureSpecification(subject FirewallPolicyIntrusionDetectionSignatureSpecification) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyIntrusionDetectionSignatureSpecification
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyIntrusionDetectionSignatureSpecification instances for property testing - lazily
// instantiated by FirewallPolicyIntrusionDetectionSignatureSpecificationGenerator()
var firewallPolicyIntrusionDetectionSignatureSpecificationGenerator gopter.Gen

// FirewallPolicyIntrusionDetectionSignatureSpecificationGenerator returns a generator of FirewallPolicyIntrusionDetectionSignatureSpecification instances for property testing.
func FirewallPolicyIntrusionDetectionSignatureSpecificationGenerator() gopter.Gen {
	if firewallPolicyIntrusionDetectionSignatureSpecificationGenerator != nil {
		return firewallPolicyIntrusionDetectionSignatureSpecificationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionSignatureSpecification(generators)
	firewallPolicyIntrusionDetectionSignatureSpecificationGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetectionSignatureSpecification{}), generators)

	return firewallPolicyIntrusionDetectionSignatureSpecificationGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionSignatureSpecification is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionSignatureSpecification(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Mode"] = gen.PtrOf(gen.AlphaString())
}

func Test_FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyIntrusionDetectionSignatureSpecification_STATUS, FirewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyIntrusionDetectionSignatureSpecification_STATUS runs a test to see if a specific instance of FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyIntrusionDetectionSignatureSpecification_STATUS(subject FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS instances for property testing - lazily
// instantiated by FirewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator()
var firewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator gopter.Gen

// FirewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator returns a generator of FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS instances for property testing.
func FirewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator() gopter.Gen {
	if firewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator != nil {
		return firewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionSignatureSpecification_STATUS(generators)
	firewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetectionSignatureSpecification_STATUS{}), generators)

	return firewallPolicyIntrusionDetectionSignatureSpecification_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionSignatureSpecification_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetectionSignatureSpecification_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Mode"] = gen.PtrOf(gen.AlphaString())
}

func Test_FirewallPolicyIntrusionDetection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyIntrusionDetection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyIntrusionDetection_STATUS, FirewallPolicyIntrusionDetection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyIntrusionDetection_STATUS runs a test to see if a specific instance of FirewallPolicyIntrusionDetection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyIntrusionDetection_STATUS(subject FirewallPolicyIntrusionDetection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyIntrusionDetection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyIntrusionDetection_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyIntrusionDetection_STATUSGenerator()
var firewallPolicyIntrusionDetection_STATUSGenerator gopter.Gen

// FirewallPolicyIntrusionDetection_STATUSGenerator returns a generator of FirewallPolicyIntrusionDetection_STATUS instances for property testing.
// We first initialize firewallPolicyIntrusionDetection_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyIntrusionDetection_STATUSGenerator() gopter.Gen {
	if firewallPolicyIntrusionDetection_STATUSGenerator != nil {
		return firewallPolicyIntrusionDetection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetection_STATUS(generators)
	firewallPolicyIntrusionDetection_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetection_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetection_STATUS(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetection_STATUS(generators)
	firewallPolicyIntrusionDetection_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyIntrusionDetection_STATUS{}), generators)

	return firewallPolicyIntrusionDetection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyIntrusionDetection_STATUS(gens map[string]gopter.Gen) {
	gens["Mode"] = gen.PtrOf(gen.AlphaString())
	gens["Profile"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetection_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyIntrusionDetection_STATUS(gens map[string]gopter.Gen) {
	gens["Configuration"] = gen.PtrOf(FirewallPolicyIntrusionDetectionConfiguration_STATUSGenerator())
}

func Test_FirewallPolicyLogAnalyticsResources_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyLogAnalyticsResources via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyLogAnalyticsResources, FirewallPolicyLogAnalyticsResourcesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyLogAnalyticsResources runs a test to see if a specific instance of FirewallPolicyLogAnalyticsResources round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyLogAnalyticsResources(subject FirewallPolicyLogAnalyticsResources) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyLogAnalyticsResources
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyLogAnalyticsResources instances for property testing - lazily instantiated by
// FirewallPolicyLogAnalyticsResourcesGenerator()
var firewallPolicyLogAnalyticsResourcesGenerator gopter.Gen

// FirewallPolicyLogAnalyticsResourcesGenerator returns a generator of FirewallPolicyLogAnalyticsResources instances for property testing.
func FirewallPolicyLogAnalyticsResourcesGenerator() gopter.Gen {
	if firewallPolicyLogAnalyticsResourcesGenerator != nil {
		return firewallPolicyLogAnalyticsResourcesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsResources(generators)
	firewallPolicyLogAnalyticsResourcesGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyLogAnalyticsResources{}), generators)

	return firewallPolicyLogAnalyticsResourcesGenerator
}

// AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsResources is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsResources(gens map[string]gopter.Gen) {
	gens["DefaultWorkspaceId"] = gen.PtrOf(SubResourceGenerator())
	gens["Workspaces"] = gen.SliceOf(FirewallPolicyLogAnalyticsWorkspaceGenerator())
}

func Test_FirewallPolicyLogAnalyticsResources_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyLogAnalyticsResources_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyLogAnalyticsResources_STATUS, FirewallPolicyLogAnalyticsResources_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyLogAnalyticsResources_STATUS runs a test to see if a specific instance of FirewallPolicyLogAnalyticsResources_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyLogAnalyticsResources_STATUS(subject FirewallPolicyLogAnalyticsResources_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyLogAnalyticsResources_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyLogAnalyticsResources_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyLogAnalyticsResources_STATUSGenerator()
var firewallPolicyLogAnalyticsResources_STATUSGenerator gopter.Gen

// FirewallPolicyLogAnalyticsResources_STATUSGenerator returns a generator of FirewallPolicyLogAnalyticsResources_STATUS instances for property testing.
func FirewallPolicyLogAnalyticsResources_STATUSGenerator() gopter.Gen {
	if firewallPolicyLogAnalyticsResources_STATUSGenerator != nil {
		return firewallPolicyLogAnalyticsResources_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsResources_STATUS(generators)
	firewallPolicyLogAnalyticsResources_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyLogAnalyticsResources_STATUS{}), generators)

	return firewallPolicyLogAnalyticsResources_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsResources_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsResources_STATUS(gens map[string]gopter.Gen) {
	gens["DefaultWorkspaceId"] = gen.PtrOf(SubResource_STATUSGenerator())
	gens["Workspaces"] = gen.SliceOf(FirewallPolicyLogAnalyticsWorkspace_STATUSGenerator())
}

func Test_FirewallPolicyLogAnalyticsWorkspace_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyLogAnalyticsWorkspace via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyLogAnalyticsWorkspace, FirewallPolicyLogAnalyticsWorkspaceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyLogAnalyticsWorkspace runs a test to see if a specific instance of FirewallPolicyLogAnalyticsWorkspace round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyLogAnalyticsWorkspace(subject FirewallPolicyLogAnalyticsWorkspace) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyLogAnalyticsWorkspace
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyLogAnalyticsWorkspace instances for property testing - lazily instantiated by
// FirewallPolicyLogAnalyticsWorkspaceGenerator()
var firewallPolicyLogAnalyticsWorkspaceGenerator gopter.Gen

// FirewallPolicyLogAnalyticsWorkspaceGenerator returns a generator of FirewallPolicyLogAnalyticsWorkspace instances for property testing.
// We first initialize firewallPolicyLogAnalyticsWorkspaceGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyLogAnalyticsWorkspaceGenerator() gopter.Gen {
	if firewallPolicyLogAnalyticsWorkspaceGenerator != nil {
		return firewallPolicyLogAnalyticsWorkspaceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace(generators)
	firewallPolicyLogAnalyticsWorkspaceGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyLogAnalyticsWorkspace{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace(generators)
	firewallPolicyLogAnalyticsWorkspaceGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyLogAnalyticsWorkspace{}), generators)

	return firewallPolicyLogAnalyticsWorkspaceGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace(gens map[string]gopter.Gen) {
	gens["Region"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace(gens map[string]gopter.Gen) {
	gens["WorkspaceId"] = gen.PtrOf(SubResourceGenerator())
}

func Test_FirewallPolicyLogAnalyticsWorkspace_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyLogAnalyticsWorkspace_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyLogAnalyticsWorkspace_STATUS, FirewallPolicyLogAnalyticsWorkspace_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyLogAnalyticsWorkspace_STATUS runs a test to see if a specific instance of FirewallPolicyLogAnalyticsWorkspace_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyLogAnalyticsWorkspace_STATUS(subject FirewallPolicyLogAnalyticsWorkspace_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyLogAnalyticsWorkspace_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyLogAnalyticsWorkspace_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyLogAnalyticsWorkspace_STATUSGenerator()
var firewallPolicyLogAnalyticsWorkspace_STATUSGenerator gopter.Gen

// FirewallPolicyLogAnalyticsWorkspace_STATUSGenerator returns a generator of FirewallPolicyLogAnalyticsWorkspace_STATUS instances for property testing.
// We first initialize firewallPolicyLogAnalyticsWorkspace_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicyLogAnalyticsWorkspace_STATUSGenerator() gopter.Gen {
	if firewallPolicyLogAnalyticsWorkspace_STATUSGenerator != nil {
		return firewallPolicyLogAnalyticsWorkspace_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace_STATUS(generators)
	firewallPolicyLogAnalyticsWorkspace_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyLogAnalyticsWorkspace_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace_STATUS(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace_STATUS(generators)
	firewallPolicyLogAnalyticsWorkspace_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyLogAnalyticsWorkspace_STATUS{}), generators)

	return firewallPolicyLogAnalyticsWorkspace_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace_STATUS(gens map[string]gopter.Gen) {
	gens["Region"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyLogAnalyticsWorkspace_STATUS(gens map[string]gopter.Gen) {
	gens["WorkspaceId"] = gen.PtrOf(SubResource_STATUSGenerator())
}

func Test_FirewallPolicyOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyOperatorSpec, FirewallPolicyOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyOperatorSpec runs a test to see if a specific instance of FirewallPolicyOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyOperatorSpec(subject FirewallPolicyOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyOperatorSpec instances for property testing - lazily instantiated by
// FirewallPolicyOperatorSpecGenerator()
var firewallPolicyOperatorSpecGenerator gopter.Gen

// FirewallPolicyOperatorSpecGenerator returns a generator of FirewallPolicyOperatorSpec instances for property testing.
func FirewallPolicyOperatorSpecGenerator() gopter.Gen {
	if firewallPolicyOperatorSpecGenerator != nil {
		return firewallPolicyOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	firewallPolicyOperatorSpecGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyOperatorSpec{}), generators)

	return firewallPolicyOperatorSpecGenerator
}

func Test_FirewallPolicySNAT_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicySNAT via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicySNAT, FirewallPolicySNATGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicySNAT runs a test to see if a specific instance of FirewallPolicySNAT round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicySNAT(subject FirewallPolicySNAT) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicySNAT
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicySNAT instances for property testing - lazily instantiated by FirewallPolicySNATGenerator()
var firewallPolicySNATGenerator gopter.Gen

// FirewallPolicySNATGenerator returns a generator of FirewallPolicySNAT instances for property testing.
func FirewallPolicySNATGenerator() gopter.Gen {
	if firewallPolicySNATGenerator != nil {
		return firewallPolicySNATGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicySNAT(generators)
	firewallPolicySNATGenerator = gen.Struct(reflect.TypeOf(FirewallPolicySNAT{}), generators)

	return firewallPolicySNATGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicySNAT is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicySNAT(gens map[string]gopter.Gen) {
	gens["AutoLearnPrivateRanges"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateRanges"] = gen.SliceOf(gen.AlphaString())
}

func Test_FirewallPolicySNAT_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicySNAT_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicySNAT_STATUS, FirewallPolicySNAT_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicySNAT_STATUS runs a test to see if a specific instance of FirewallPolicySNAT_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicySNAT_STATUS(subject FirewallPolicySNAT_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicySNAT_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicySNAT_STATUS instances for property testing - lazily instantiated by
// FirewallPolicySNAT_STATUSGenerator()
var firewallPolicySNAT_STATUSGenerator gopter.Gen

// FirewallPolicySNAT_STATUSGenerator returns a generator of FirewallPolicySNAT_STATUS instances for property testing.
func FirewallPolicySNAT_STATUSGenerator() gopter.Gen {
	if firewallPolicySNAT_STATUSGenerator != nil {
		return firewallPolicySNAT_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicySNAT_STATUS(generators)
	firewallPolicySNAT_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicySNAT_STATUS{}), generators)

	return firewallPolicySNAT_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicySNAT_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicySNAT_STATUS(gens map[string]gopter.Gen) {
	gens["AutoLearnPrivateRanges"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateRanges"] = gen.SliceOf(gen.AlphaString())
}

func Test_FirewallPolicySQL_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicySQL via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicySQL, FirewallPolicySQLGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicySQL runs a test to see if a specific instance of FirewallPolicySQL round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicySQL(subject FirewallPolicySQL) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicySQL
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicySQL instances for property testing - lazily instantiated by FirewallPolicySQLGenerator()
var firewallPolicySQLGenerator gopter.Gen

// FirewallPolicySQLGenerator returns a generator of FirewallPolicySQL instances for property testing.
func FirewallPolicySQLGenerator() gopter.Gen {
	if firewallPolicySQLGenerator != nil {
		return firewallPolicySQLGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicySQL(generators)
	firewallPolicySQLGenerator = gen.Struct(reflect.TypeOf(FirewallPolicySQL{}), generators)

	return firewallPolicySQLGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicySQL is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicySQL(gens map[string]gopter.Gen) {
	gens["AllowSqlRedirect"] = gen.PtrOf(gen.Bool())
}

func Test_FirewallPolicySQL_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicySQL_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicySQL_STATUS, FirewallPolicySQL_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicySQL_STATUS runs a test to see if a specific instance of FirewallPolicySQL_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicySQL_STATUS(subject FirewallPolicySQL_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicySQL_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicySQL_STATUS instances for property testing - lazily instantiated by
// FirewallPolicySQL_STATUSGenerator()
var firewallPolicySQL_STATUSGenerator gopter.Gen

// FirewallPolicySQL_STATUSGenerator returns a generator of FirewallPolicySQL_STATUS instances for property testing.
func FirewallPolicySQL_STATUSGenerator() gopter.Gen {
	if firewallPolicySQL_STATUSGenerator != nil {
		return firewallPolicySQL_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicySQL_STATUS(generators)
	firewallPolicySQL_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicySQL_STATUS{}), generators)

	return firewallPolicySQL_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicySQL_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicySQL_STATUS(gens map[string]gopter.Gen) {
	gens["AllowSqlRedirect"] = gen.PtrOf(gen.Bool())
}

func Test_FirewallPolicySku_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicySku via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicySku, FirewallPolicySkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicySku runs a test to see if a specific instance of FirewallPolicySku round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicySku(subject FirewallPolicySku) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicySku
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicySku instances for property testing - lazily instantiated by FirewallPolicySkuGenerator()
var firewallPolicySkuGenerator gopter.Gen

// FirewallPolicySkuGenerator returns a generator of FirewallPolicySku instances for property testing.
func FirewallPolicySkuGenerator() gopter.Gen {
	if firewallPolicySkuGenerator != nil {
		return firewallPolicySkuGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicySku(generators)
	firewallPolicySkuGenerator = gen.Struct(reflect.TypeOf(FirewallPolicySku{}), generators)

	return firewallPolicySkuGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicySku is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicySku(gens map[string]gopter.Gen) {
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_FirewallPolicySku_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicySku_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicySku_STATUS, FirewallPolicySku_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicySku_STATUS runs a test to see if a specific instance of FirewallPolicySku_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicySku_STATUS(subject FirewallPolicySku_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicySku_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicySku_STATUS instances for property testing - lazily instantiated by
// FirewallPolicySku_STATUSGenerator()
var firewallPolicySku_STATUSGenerator gopter.Gen

// FirewallPolicySku_STATUSGenerator returns a generator of FirewallPolicySku_STATUS instances for property testing.
func FirewallPolicySku_STATUSGenerator() gopter.Gen {
	if firewallPolicySku_STATUSGenerator != nil {
		return firewallPolicySku_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicySku_STATUS(generators)
	firewallPolicySku_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicySku_STATUS{}), generators)

	return firewallPolicySku_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicySku_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicySku_STATUS(gens map[string]gopter.Gen) {
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_FirewallPolicyThreatIntelWhitelist_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyThreatIntelWhitelist via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyThreatIntelWhitelist, FirewallPolicyThreatIntelWhitelistGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyThreatIntelWhitelist runs a test to see if a specific instance of FirewallPolicyThreatIntelWhitelist round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyThreatIntelWhitelist(subject FirewallPolicyThreatIntelWhitelist) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyThreatIntelWhitelist
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyThreatIntelWhitelist instances for property testing - lazily instantiated by
// FirewallPolicyThreatIntelWhitelistGenerator()
var firewallPolicyThreatIntelWhitelistGenerator gopter.Gen

// FirewallPolicyThreatIntelWhitelistGenerator returns a generator of FirewallPolicyThreatIntelWhitelist instances for property testing.
func FirewallPolicyThreatIntelWhitelistGenerator() gopter.Gen {
	if firewallPolicyThreatIntelWhitelistGenerator != nil {
		return firewallPolicyThreatIntelWhitelistGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyThreatIntelWhitelist(generators)
	firewallPolicyThreatIntelWhitelistGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyThreatIntelWhitelist{}), generators)

	return firewallPolicyThreatIntelWhitelistGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyThreatIntelWhitelist is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyThreatIntelWhitelist(gens map[string]gopter.Gen) {
	gens["Fqdns"] = gen.SliceOf(gen.AlphaString())
	gens["IpAddresses"] = gen.SliceOf(gen.AlphaString())
}

func Test_FirewallPolicyThreatIntelWhitelist_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyThreatIntelWhitelist_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyThreatIntelWhitelist_STATUS, FirewallPolicyThreatIntelWhitelist_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyThreatIntelWhitelist_STATUS runs a test to see if a specific instance of FirewallPolicyThreatIntelWhitelist_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyThreatIntelWhitelist_STATUS(subject FirewallPolicyThreatIntelWhitelist_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyThreatIntelWhitelist_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyThreatIntelWhitelist_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyThreatIntelWhitelist_STATUSGenerator()
var firewallPolicyThreatIntelWhitelist_STATUSGenerator gopter.Gen

// FirewallPolicyThreatIntelWhitelist_STATUSGenerator returns a generator of FirewallPolicyThreatIntelWhitelist_STATUS instances for property testing.
func FirewallPolicyThreatIntelWhitelist_STATUSGenerator() gopter.Gen {
	if firewallPolicyThreatIntelWhitelist_STATUSGenerator != nil {
		return firewallPolicyThreatIntelWhitelist_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicyThreatIntelWhitelist_STATUS(generators)
	firewallPolicyThreatIntelWhitelist_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyThreatIntelWhitelist_STATUS{}), generators)

	return firewallPolicyThreatIntelWhitelist_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicyThreatIntelWhitelist_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicyThreatIntelWhitelist_STATUS(gens map[string]gopter.Gen) {
	gens["Fqdns"] = gen.SliceOf(gen.AlphaString())
	gens["IpAddresses"] = gen.SliceOf(gen.AlphaString())
}

func Test_FirewallPolicyTransportSecurity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyTransportSecurity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyTransportSecurity, FirewallPolicyTransportSecurityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyTransportSecurity runs a test to see if a specific instance of FirewallPolicyTransportSecurity round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyTransportSecurity(subject FirewallPolicyTransportSecurity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyTransportSecurity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyTransportSecurity instances for property testing - lazily instantiated by
// FirewallPolicyTransportSecurityGenerator()
var firewallPolicyTransportSecurityGenerator gopter.Gen

// FirewallPolicyTransportSecurityGenerator returns a generator of FirewallPolicyTransportSecurity instances for property testing.
func FirewallPolicyTransportSecurityGenerator() gopter.Gen {
	if firewallPolicyTransportSecurityGenerator != nil {
		return firewallPolicyTransportSecurityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForFirewallPolicyTransportSecurity(generators)
	firewallPolicyTransportSecurityGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyTransportSecurity{}), generators)

	return firewallPolicyTransportSecurityGenerator
}

// AddRelatedPropertyGeneratorsForFirewallPolicyTransportSecurity is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyTransportSecurity(gens map[string]gopter.Gen) {
	gens["CertificateAuthority"] = gen.PtrOf(FirewallPolicyCertificateAuthorityGenerator())
}

func Test_FirewallPolicyTransportSecurity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicyTransportSecurity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicyTransportSecurity_STATUS, FirewallPolicyTransportSecurity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicyTransportSecurity_STATUS runs a test to see if a specific instance of FirewallPolicyTransportSecurity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicyTransportSecurity_STATUS(subject FirewallPolicyTransportSecurity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicyTransportSecurity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicyTransportSecurity_STATUS instances for property testing - lazily instantiated by
// FirewallPolicyTransportSecurity_STATUSGenerator()
var firewallPolicyTransportSecurity_STATUSGenerator gopter.Gen

// FirewallPolicyTransportSecurity_STATUSGenerator returns a generator of FirewallPolicyTransportSecurity_STATUS instances for property testing.
func FirewallPolicyTransportSecurity_STATUSGenerator() gopter.Gen {
	if firewallPolicyTransportSecurity_STATUSGenerator != nil {
		return firewallPolicyTransportSecurity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForFirewallPolicyTransportSecurity_STATUS(generators)
	firewallPolicyTransportSecurity_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicyTransportSecurity_STATUS{}), generators)

	return firewallPolicyTransportSecurity_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForFirewallPolicyTransportSecurity_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicyTransportSecurity_STATUS(gens map[string]gopter.Gen) {
	gens["CertificateAuthority"] = gen.PtrOf(FirewallPolicyCertificateAuthority_STATUSGenerator())
}

func Test_FirewallPolicy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicy_STATUS, FirewallPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicy_STATUS runs a test to see if a specific instance of FirewallPolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicy_STATUS(subject FirewallPolicy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicy_STATUS instances for property testing - lazily instantiated by
// FirewallPolicy_STATUSGenerator()
var firewallPolicy_STATUSGenerator gopter.Gen

// FirewallPolicy_STATUSGenerator returns a generator of FirewallPolicy_STATUS instances for property testing.
// We first initialize firewallPolicy_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicy_STATUSGenerator() gopter.Gen {
	if firewallPolicy_STATUSGenerator != nil {
		return firewallPolicy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicy_STATUS(generators)
	firewallPolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicy_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicy_STATUS(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicy_STATUS(generators)
	firewallPolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(FirewallPolicy_STATUS{}), generators)

	return firewallPolicy_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicy_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicy_STATUS(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Size"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["ThreatIntelMode"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFirewallPolicy_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicy_STATUS(gens map[string]gopter.Gen) {
	gens["BasePolicy"] = gen.PtrOf(SubResource_STATUSGenerator())
	gens["ChildPolicies"] = gen.SliceOf(SubResource_STATUSGenerator())
	gens["DnsSettings"] = gen.PtrOf(DnsSettings_STATUSGenerator())
	gens["ExplicitProxy"] = gen.PtrOf(ExplicitProxy_STATUSGenerator())
	gens["Firewalls"] = gen.SliceOf(SubResource_STATUSGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentity_STATUSGenerator())
	gens["Insights"] = gen.PtrOf(FirewallPolicyInsights_STATUSGenerator())
	gens["IntrusionDetection"] = gen.PtrOf(FirewallPolicyIntrusionDetection_STATUSGenerator())
	gens["RuleCollectionGroups"] = gen.SliceOf(SubResource_STATUSGenerator())
	gens["Sku"] = gen.PtrOf(FirewallPolicySku_STATUSGenerator())
	gens["Snat"] = gen.PtrOf(FirewallPolicySNAT_STATUSGenerator())
	gens["Sql"] = gen.PtrOf(FirewallPolicySQL_STATUSGenerator())
	gens["ThreatIntelWhitelist"] = gen.PtrOf(FirewallPolicyThreatIntelWhitelist_STATUSGenerator())
	gens["TransportSecurity"] = gen.PtrOf(FirewallPolicyTransportSecurity_STATUSGenerator())
}

func Test_FirewallPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FirewallPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFirewallPolicy_Spec, FirewallPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFirewallPolicy_Spec runs a test to see if a specific instance of FirewallPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForFirewallPolicy_Spec(subject FirewallPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FirewallPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FirewallPolicy_Spec instances for property testing - lazily instantiated by
// FirewallPolicy_SpecGenerator()
var firewallPolicy_SpecGenerator gopter.Gen

// FirewallPolicy_SpecGenerator returns a generator of FirewallPolicy_Spec instances for property testing.
// We first initialize firewallPolicy_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FirewallPolicy_SpecGenerator() gopter.Gen {
	if firewallPolicy_SpecGenerator != nil {
		return firewallPolicy_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicy_Spec(generators)
	firewallPolicy_SpecGenerator = gen.Struct(reflect.TypeOf(FirewallPolicy_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFirewallPolicy_Spec(generators)
	AddRelatedPropertyGeneratorsForFirewallPolicy_Spec(generators)
	firewallPolicy_SpecGenerator = gen.Struct(reflect.TypeOf(FirewallPolicy_Spec{}), generators)

	return firewallPolicy_SpecGenerator
}

// AddIndependentPropertyGeneratorsForFirewallPolicy_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFirewallPolicy_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["ThreatIntelMode"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFirewallPolicy_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFirewallPolicy_Spec(gens map[string]gopter.Gen) {
	gens["BasePolicy"] = gen.PtrOf(SubResourceGenerator())
	gens["DnsSettings"] = gen.PtrOf(DnsSettingsGenerator())
	gens["ExplicitProxy"] = gen.PtrOf(ExplicitProxyGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentityGenerator())
	gens["Insights"] = gen.PtrOf(FirewallPolicyInsightsGenerator())
	gens["IntrusionDetection"] = gen.PtrOf(FirewallPolicyIntrusionDetectionGenerator())
	gens["OperatorSpec"] = gen.PtrOf(FirewallPolicyOperatorSpecGenerator())
	gens["Sku"] = gen.PtrOf(FirewallPolicySkuGenerator())
	gens["Snat"] = gen.PtrOf(FirewallPolicySNATGenerator())
	gens["Sql"] = gen.PtrOf(FirewallPolicySQLGenerator())
	gens["ThreatIntelWhitelist"] = gen.PtrOf(FirewallPolicyThreatIntelWhitelistGenerator())
	gens["TransportSecurity"] = gen.PtrOf(FirewallPolicyTransportSecurityGenerator())
}

func Test_ManagedServiceIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity, ManagedServiceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity runs a test to see if a specific instance of ManagedServiceIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity(subject ManagedServiceIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity instances for property testing - lazily instantiated by
// ManagedServiceIdentityGenerator()
var managedServiceIdentityGenerator gopter.Gen

// ManagedServiceIdentityGenerator returns a generator of ManagedServiceIdentity instances for property testing.
// We first initialize managedServiceIdentityGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentityGenerator() gopter.Gen {
	if managedServiceIdentityGenerator != nil {
		return managedServiceIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity(generators)
	managedServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentity(generators)
	managedServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity{}), generators)

	return managedServiceIdentityGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentity is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentity(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.SliceOf(UserAssignedIdentityDetailsGenerator())
}

func Test_ManagedServiceIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity_STATUS, ManagedServiceIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity_STATUS runs a test to see if a specific instance of ManagedServiceIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity_STATUS(subject ManagedServiceIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_STATUS instances for property testing - lazily instantiated by
// ManagedServiceIdentity_STATUSGenerator()
var managedServiceIdentity_STATUSGenerator gopter.Gen

// ManagedServiceIdentity_STATUSGenerator returns a generator of ManagedServiceIdentity_STATUS instances for property testing.
// We first initialize managedServiceIdentity_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentity_STATUSGenerator() gopter.Gen {
	if managedServiceIdentity_STATUSGenerator != nil {
		return managedServiceIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS(generators)
	managedServiceIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUS(generators)
	managedServiceIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_STATUS{}), generators)

	return managedServiceIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(
		gen.AlphaString(),
		ManagedServiceIdentity_UserAssignedIdentities_STATUSGenerator())
}

func Test_ManagedServiceIdentity_UserAssignedIdentities_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_UserAssignedIdentities_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity_UserAssignedIdentities_STATUS, ManagedServiceIdentity_UserAssignedIdentities_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity_UserAssignedIdentities_STATUS runs a test to see if a specific instance of ManagedServiceIdentity_UserAssignedIdentities_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity_UserAssignedIdentities_STATUS(subject ManagedServiceIdentity_UserAssignedIdentities_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_UserAssignedIdentities_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_UserAssignedIdentities_STATUS instances for property testing - lazily
// instantiated by ManagedServiceIdentity_UserAssignedIdentities_STATUSGenerator()
var managedServiceIdentity_UserAssignedIdentities_STATUSGenerator gopter.Gen

// ManagedServiceIdentity_UserAssignedIdentities_STATUSGenerator returns a generator of ManagedServiceIdentity_UserAssignedIdentities_STATUS instances for property testing.
func ManagedServiceIdentity_UserAssignedIdentities_STATUSGenerator() gopter.Gen {
	if managedServiceIdentity_UserAssignedIdentities_STATUSGenerator != nil {
		return managedServiceIdentity_UserAssignedIdentities_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_UserAssignedIdentities_STATUS(generators)
	managedServiceIdentity_UserAssignedIdentities_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_UserAssignedIdentities_STATUS{}), generators)

	return managedServiceIdentity_UserAssignedIdentities_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity_UserAssignedIdentities_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity_UserAssignedIdentities_STATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserAssignedIdentityDetails_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails runs a test to see if a specific instance of UserAssignedIdentityDetails round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails instances for property testing - lazily instantiated by
// UserAssignedIdentityDetailsGenerator()
var userAssignedIdentityDetailsGenerator gopter.Gen

// UserAssignedIdentityDetailsGenerator returns a generator of UserAssignedIdentityDetails instances for property testing.
func UserAssignedIdentityDetailsGenerator() gopter.Gen {
	if userAssignedIdentityDetailsGenerator != nil {
		return userAssignedIdentityDetailsGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetailsGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails{}), generators)

	return userAssignedIdentityDetailsGenerator
}
