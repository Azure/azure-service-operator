// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ExclusionManagedRuleGroup_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExclusionManagedRuleGroup_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExclusionManagedRuleGroup_ARM, ExclusionManagedRuleGroup_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExclusionManagedRuleGroup_ARM runs a test to see if a specific instance of ExclusionManagedRuleGroup_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExclusionManagedRuleGroup_ARM(subject ExclusionManagedRuleGroup_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExclusionManagedRuleGroup_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExclusionManagedRuleGroup_ARM instances for property testing - lazily instantiated by
// ExclusionManagedRuleGroup_ARMGenerator()
var exclusionManagedRuleGroup_ARMGenerator gopter.Gen

// ExclusionManagedRuleGroup_ARMGenerator returns a generator of ExclusionManagedRuleGroup_ARM instances for property testing.
// We first initialize exclusionManagedRuleGroup_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ExclusionManagedRuleGroup_ARMGenerator() gopter.Gen {
	if exclusionManagedRuleGroup_ARMGenerator != nil {
		return exclusionManagedRuleGroup_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExclusionManagedRuleGroup_ARM(generators)
	exclusionManagedRuleGroup_ARMGenerator = gen.Struct(reflect.TypeOf(ExclusionManagedRuleGroup_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExclusionManagedRuleGroup_ARM(generators)
	AddRelatedPropertyGeneratorsForExclusionManagedRuleGroup_ARM(generators)
	exclusionManagedRuleGroup_ARMGenerator = gen.Struct(reflect.TypeOf(ExclusionManagedRuleGroup_ARM{}), generators)

	return exclusionManagedRuleGroup_ARMGenerator
}

// AddIndependentPropertyGeneratorsForExclusionManagedRuleGroup_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExclusionManagedRuleGroup_ARM(gens map[string]gopter.Gen) {
	gens["RuleGroupName"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForExclusionManagedRuleGroup_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExclusionManagedRuleGroup_ARM(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(ExclusionManagedRule_ARMGenerator())
}

func Test_ExclusionManagedRuleSet_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExclusionManagedRuleSet_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExclusionManagedRuleSet_ARM, ExclusionManagedRuleSet_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExclusionManagedRuleSet_ARM runs a test to see if a specific instance of ExclusionManagedRuleSet_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExclusionManagedRuleSet_ARM(subject ExclusionManagedRuleSet_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExclusionManagedRuleSet_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExclusionManagedRuleSet_ARM instances for property testing - lazily instantiated by
// ExclusionManagedRuleSet_ARMGenerator()
var exclusionManagedRuleSet_ARMGenerator gopter.Gen

// ExclusionManagedRuleSet_ARMGenerator returns a generator of ExclusionManagedRuleSet_ARM instances for property testing.
// We first initialize exclusionManagedRuleSet_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ExclusionManagedRuleSet_ARMGenerator() gopter.Gen {
	if exclusionManagedRuleSet_ARMGenerator != nil {
		return exclusionManagedRuleSet_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExclusionManagedRuleSet_ARM(generators)
	exclusionManagedRuleSet_ARMGenerator = gen.Struct(reflect.TypeOf(ExclusionManagedRuleSet_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExclusionManagedRuleSet_ARM(generators)
	AddRelatedPropertyGeneratorsForExclusionManagedRuleSet_ARM(generators)
	exclusionManagedRuleSet_ARMGenerator = gen.Struct(reflect.TypeOf(ExclusionManagedRuleSet_ARM{}), generators)

	return exclusionManagedRuleSet_ARMGenerator
}

// AddIndependentPropertyGeneratorsForExclusionManagedRuleSet_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExclusionManagedRuleSet_ARM(gens map[string]gopter.Gen) {
	gens["RuleSetType"] = gen.PtrOf(gen.AlphaString())
	gens["RuleSetVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForExclusionManagedRuleSet_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExclusionManagedRuleSet_ARM(gens map[string]gopter.Gen) {
	gens["RuleGroups"] = gen.SliceOf(ExclusionManagedRuleGroup_ARMGenerator())
}

func Test_ExclusionManagedRule_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExclusionManagedRule_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExclusionManagedRule_ARM, ExclusionManagedRule_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExclusionManagedRule_ARM runs a test to see if a specific instance of ExclusionManagedRule_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExclusionManagedRule_ARM(subject ExclusionManagedRule_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExclusionManagedRule_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExclusionManagedRule_ARM instances for property testing - lazily instantiated by
// ExclusionManagedRule_ARMGenerator()
var exclusionManagedRule_ARMGenerator gopter.Gen

// ExclusionManagedRule_ARMGenerator returns a generator of ExclusionManagedRule_ARM instances for property testing.
func ExclusionManagedRule_ARMGenerator() gopter.Gen {
	if exclusionManagedRule_ARMGenerator != nil {
		return exclusionManagedRule_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExclusionManagedRule_ARM(generators)
	exclusionManagedRule_ARMGenerator = gen.Struct(reflect.TypeOf(ExclusionManagedRule_ARM{}), generators)

	return exclusionManagedRule_ARMGenerator
}

// AddIndependentPropertyGeneratorsForExclusionManagedRule_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExclusionManagedRule_ARM(gens map[string]gopter.Gen) {
	gens["RuleId"] = gen.PtrOf(gen.AlphaString())
}

func Test_GroupByUserSession_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GroupByUserSession_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGroupByUserSession_ARM, GroupByUserSession_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGroupByUserSession_ARM runs a test to see if a specific instance of GroupByUserSession_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForGroupByUserSession_ARM(subject GroupByUserSession_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GroupByUserSession_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GroupByUserSession_ARM instances for property testing - lazily instantiated by
// GroupByUserSession_ARMGenerator()
var groupByUserSession_ARMGenerator gopter.Gen

// GroupByUserSession_ARMGenerator returns a generator of GroupByUserSession_ARM instances for property testing.
func GroupByUserSession_ARMGenerator() gopter.Gen {
	if groupByUserSession_ARMGenerator != nil {
		return groupByUserSession_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForGroupByUserSession_ARM(generators)
	groupByUserSession_ARMGenerator = gen.Struct(reflect.TypeOf(GroupByUserSession_ARM{}), generators)

	return groupByUserSession_ARMGenerator
}

// AddRelatedPropertyGeneratorsForGroupByUserSession_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForGroupByUserSession_ARM(gens map[string]gopter.Gen) {
	gens["GroupByVariables"] = gen.SliceOf(GroupByVariable_ARMGenerator())
}

func Test_GroupByVariable_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GroupByVariable_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGroupByVariable_ARM, GroupByVariable_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGroupByVariable_ARM runs a test to see if a specific instance of GroupByVariable_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForGroupByVariable_ARM(subject GroupByVariable_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GroupByVariable_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GroupByVariable_ARM instances for property testing - lazily instantiated by
// GroupByVariable_ARMGenerator()
var groupByVariable_ARMGenerator gopter.Gen

// GroupByVariable_ARMGenerator returns a generator of GroupByVariable_ARM instances for property testing.
func GroupByVariable_ARMGenerator() gopter.Gen {
	if groupByVariable_ARMGenerator != nil {
		return groupByVariable_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGroupByVariable_ARM(generators)
	groupByVariable_ARMGenerator = gen.Struct(reflect.TypeOf(GroupByVariable_ARM{}), generators)

	return groupByVariable_ARMGenerator
}

// AddIndependentPropertyGeneratorsForGroupByVariable_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGroupByVariable_ARM(gens map[string]gopter.Gen) {
	gens["VariableName"] = gen.PtrOf(gen.OneConstOf(GroupByVariable_VariableName_ARM_ClientAddr, GroupByVariable_VariableName_ARM_GeoLocation, GroupByVariable_VariableName_ARM_None))
}

func Test_ManagedRuleGroupOverride_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedRuleGroupOverride_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedRuleGroupOverride_ARM, ManagedRuleGroupOverride_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedRuleGroupOverride_ARM runs a test to see if a specific instance of ManagedRuleGroupOverride_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedRuleGroupOverride_ARM(subject ManagedRuleGroupOverride_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedRuleGroupOverride_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedRuleGroupOverride_ARM instances for property testing - lazily instantiated by
// ManagedRuleGroupOverride_ARMGenerator()
var managedRuleGroupOverride_ARMGenerator gopter.Gen

// ManagedRuleGroupOverride_ARMGenerator returns a generator of ManagedRuleGroupOverride_ARM instances for property testing.
// We first initialize managedRuleGroupOverride_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedRuleGroupOverride_ARMGenerator() gopter.Gen {
	if managedRuleGroupOverride_ARMGenerator != nil {
		return managedRuleGroupOverride_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleGroupOverride_ARM(generators)
	managedRuleGroupOverride_ARMGenerator = gen.Struct(reflect.TypeOf(ManagedRuleGroupOverride_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleGroupOverride_ARM(generators)
	AddRelatedPropertyGeneratorsForManagedRuleGroupOverride_ARM(generators)
	managedRuleGroupOverride_ARMGenerator = gen.Struct(reflect.TypeOf(ManagedRuleGroupOverride_ARM{}), generators)

	return managedRuleGroupOverride_ARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedRuleGroupOverride_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedRuleGroupOverride_ARM(gens map[string]gopter.Gen) {
	gens["RuleGroupName"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedRuleGroupOverride_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedRuleGroupOverride_ARM(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(ManagedRuleOverride_ARMGenerator())
}

func Test_ManagedRuleOverride_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedRuleOverride_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedRuleOverride_ARM, ManagedRuleOverride_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedRuleOverride_ARM runs a test to see if a specific instance of ManagedRuleOverride_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedRuleOverride_ARM(subject ManagedRuleOverride_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedRuleOverride_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedRuleOverride_ARM instances for property testing - lazily instantiated by
// ManagedRuleOverride_ARMGenerator()
var managedRuleOverride_ARMGenerator gopter.Gen

// ManagedRuleOverride_ARMGenerator returns a generator of ManagedRuleOverride_ARM instances for property testing.
func ManagedRuleOverride_ARMGenerator() gopter.Gen {
	if managedRuleOverride_ARMGenerator != nil {
		return managedRuleOverride_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleOverride_ARM(generators)
	managedRuleOverride_ARMGenerator = gen.Struct(reflect.TypeOf(ManagedRuleOverride_ARM{}), generators)

	return managedRuleOverride_ARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedRuleOverride_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedRuleOverride_ARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(
		ActionType_ARM_Allow,
		ActionType_ARM_AnomalyScoring,
		ActionType_ARM_Block,
		ActionType_ARM_JSChallenge,
		ActionType_ARM_Log))
	gens["RuleId"] = gen.PtrOf(gen.AlphaString())
	gens["State"] = gen.PtrOf(gen.OneConstOf(ManagedRuleOverride_State_ARM_Disabled, ManagedRuleOverride_State_ARM_Enabled))
}

func Test_ManagedRuleSet_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedRuleSet_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedRuleSet_ARM, ManagedRuleSet_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedRuleSet_ARM runs a test to see if a specific instance of ManagedRuleSet_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedRuleSet_ARM(subject ManagedRuleSet_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedRuleSet_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedRuleSet_ARM instances for property testing - lazily instantiated by ManagedRuleSet_ARMGenerator()
var managedRuleSet_ARMGenerator gopter.Gen

// ManagedRuleSet_ARMGenerator returns a generator of ManagedRuleSet_ARM instances for property testing.
// We first initialize managedRuleSet_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedRuleSet_ARMGenerator() gopter.Gen {
	if managedRuleSet_ARMGenerator != nil {
		return managedRuleSet_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleSet_ARM(generators)
	managedRuleSet_ARMGenerator = gen.Struct(reflect.TypeOf(ManagedRuleSet_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleSet_ARM(generators)
	AddRelatedPropertyGeneratorsForManagedRuleSet_ARM(generators)
	managedRuleSet_ARMGenerator = gen.Struct(reflect.TypeOf(ManagedRuleSet_ARM{}), generators)

	return managedRuleSet_ARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedRuleSet_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedRuleSet_ARM(gens map[string]gopter.Gen) {
	gens["RuleSetType"] = gen.PtrOf(gen.AlphaString())
	gens["RuleSetVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedRuleSet_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedRuleSet_ARM(gens map[string]gopter.Gen) {
	gens["RuleGroupOverrides"] = gen.SliceOf(ManagedRuleGroupOverride_ARMGenerator())
}

func Test_ManagedRulesDefinition_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedRulesDefinition_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedRulesDefinition_ARM, ManagedRulesDefinition_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedRulesDefinition_ARM runs a test to see if a specific instance of ManagedRulesDefinition_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedRulesDefinition_ARM(subject ManagedRulesDefinition_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedRulesDefinition_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedRulesDefinition_ARM instances for property testing - lazily instantiated by
// ManagedRulesDefinition_ARMGenerator()
var managedRulesDefinition_ARMGenerator gopter.Gen

// ManagedRulesDefinition_ARMGenerator returns a generator of ManagedRulesDefinition_ARM instances for property testing.
func ManagedRulesDefinition_ARMGenerator() gopter.Gen {
	if managedRulesDefinition_ARMGenerator != nil {
		return managedRulesDefinition_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagedRulesDefinition_ARM(generators)
	managedRulesDefinition_ARMGenerator = gen.Struct(reflect.TypeOf(ManagedRulesDefinition_ARM{}), generators)

	return managedRulesDefinition_ARMGenerator
}

// AddRelatedPropertyGeneratorsForManagedRulesDefinition_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedRulesDefinition_ARM(gens map[string]gopter.Gen) {
	gens["Exclusions"] = gen.SliceOf(OwaspCrsExclusionEntry_ARMGenerator())
	gens["ManagedRuleSets"] = gen.SliceOf(ManagedRuleSet_ARMGenerator())
}

func Test_MatchCondition_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MatchCondition_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMatchCondition_ARM, MatchCondition_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMatchCondition_ARM runs a test to see if a specific instance of MatchCondition_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForMatchCondition_ARM(subject MatchCondition_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MatchCondition_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MatchCondition_ARM instances for property testing - lazily instantiated by MatchCondition_ARMGenerator()
var matchCondition_ARMGenerator gopter.Gen

// MatchCondition_ARMGenerator returns a generator of MatchCondition_ARM instances for property testing.
// We first initialize matchCondition_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MatchCondition_ARMGenerator() gopter.Gen {
	if matchCondition_ARMGenerator != nil {
		return matchCondition_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMatchCondition_ARM(generators)
	matchCondition_ARMGenerator = gen.Struct(reflect.TypeOf(MatchCondition_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMatchCondition_ARM(generators)
	AddRelatedPropertyGeneratorsForMatchCondition_ARM(generators)
	matchCondition_ARMGenerator = gen.Struct(reflect.TypeOf(MatchCondition_ARM{}), generators)

	return matchCondition_ARMGenerator
}

// AddIndependentPropertyGeneratorsForMatchCondition_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMatchCondition_ARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegationConditon"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		MatchCondition_Operator_ARM_Any,
		MatchCondition_Operator_ARM_BeginsWith,
		MatchCondition_Operator_ARM_Contains,
		MatchCondition_Operator_ARM_EndsWith,
		MatchCondition_Operator_ARM_Equal,
		MatchCondition_Operator_ARM_GeoMatch,
		MatchCondition_Operator_ARM_GreaterThan,
		MatchCondition_Operator_ARM_GreaterThanOrEqual,
		MatchCondition_Operator_ARM_IPMatch,
		MatchCondition_Operator_ARM_LessThan,
		MatchCondition_Operator_ARM_LessThanOrEqual,
		MatchCondition_Operator_ARM_Regex))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_ARM_HtmlEntityDecode,
		Transform_ARM_Lowercase,
		Transform_ARM_RemoveNulls,
		Transform_ARM_Trim,
		Transform_ARM_Uppercase,
		Transform_ARM_UrlDecode,
		Transform_ARM_UrlEncode))
}

// AddRelatedPropertyGeneratorsForMatchCondition_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMatchCondition_ARM(gens map[string]gopter.Gen) {
	gens["MatchVariables"] = gen.SliceOf(MatchVariable_ARMGenerator())
}

func Test_MatchVariable_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MatchVariable_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMatchVariable_ARM, MatchVariable_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMatchVariable_ARM runs a test to see if a specific instance of MatchVariable_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForMatchVariable_ARM(subject MatchVariable_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MatchVariable_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MatchVariable_ARM instances for property testing - lazily instantiated by MatchVariable_ARMGenerator()
var matchVariable_ARMGenerator gopter.Gen

// MatchVariable_ARMGenerator returns a generator of MatchVariable_ARM instances for property testing.
func MatchVariable_ARMGenerator() gopter.Gen {
	if matchVariable_ARMGenerator != nil {
		return matchVariable_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMatchVariable_ARM(generators)
	matchVariable_ARMGenerator = gen.Struct(reflect.TypeOf(MatchVariable_ARM{}), generators)

	return matchVariable_ARMGenerator
}

// AddIndependentPropertyGeneratorsForMatchVariable_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMatchVariable_ARM(gens map[string]gopter.Gen) {
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["VariableName"] = gen.PtrOf(gen.OneConstOf(
		MatchVariable_VariableName_ARM_PostArgs,
		MatchVariable_VariableName_ARM_QueryString,
		MatchVariable_VariableName_ARM_RemoteAddr,
		MatchVariable_VariableName_ARM_RequestBody,
		MatchVariable_VariableName_ARM_RequestCookies,
		MatchVariable_VariableName_ARM_RequestHeaders,
		MatchVariable_VariableName_ARM_RequestMethod,
		MatchVariable_VariableName_ARM_RequestUri))
}

func Test_OwaspCrsExclusionEntry_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OwaspCrsExclusionEntry_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOwaspCrsExclusionEntry_ARM, OwaspCrsExclusionEntry_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOwaspCrsExclusionEntry_ARM runs a test to see if a specific instance of OwaspCrsExclusionEntry_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOwaspCrsExclusionEntry_ARM(subject OwaspCrsExclusionEntry_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OwaspCrsExclusionEntry_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OwaspCrsExclusionEntry_ARM instances for property testing - lazily instantiated by
// OwaspCrsExclusionEntry_ARMGenerator()
var owaspCrsExclusionEntry_ARMGenerator gopter.Gen

// OwaspCrsExclusionEntry_ARMGenerator returns a generator of OwaspCrsExclusionEntry_ARM instances for property testing.
// We first initialize owaspCrsExclusionEntry_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OwaspCrsExclusionEntry_ARMGenerator() gopter.Gen {
	if owaspCrsExclusionEntry_ARMGenerator != nil {
		return owaspCrsExclusionEntry_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOwaspCrsExclusionEntry_ARM(generators)
	owaspCrsExclusionEntry_ARMGenerator = gen.Struct(reflect.TypeOf(OwaspCrsExclusionEntry_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOwaspCrsExclusionEntry_ARM(generators)
	AddRelatedPropertyGeneratorsForOwaspCrsExclusionEntry_ARM(generators)
	owaspCrsExclusionEntry_ARMGenerator = gen.Struct(reflect.TypeOf(OwaspCrsExclusionEntry_ARM{}), generators)

	return owaspCrsExclusionEntry_ARMGenerator
}

// AddIndependentPropertyGeneratorsForOwaspCrsExclusionEntry_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOwaspCrsExclusionEntry_ARM(gens map[string]gopter.Gen) {
	gens["MatchVariable"] = gen.PtrOf(gen.OneConstOf(
		OwaspCrsExclusionEntry_MatchVariable_ARM_RequestArgKeys,
		OwaspCrsExclusionEntry_MatchVariable_ARM_RequestArgNames,
		OwaspCrsExclusionEntry_MatchVariable_ARM_RequestArgValues,
		OwaspCrsExclusionEntry_MatchVariable_ARM_RequestCookieKeys,
		OwaspCrsExclusionEntry_MatchVariable_ARM_RequestCookieNames,
		OwaspCrsExclusionEntry_MatchVariable_ARM_RequestCookieValues,
		OwaspCrsExclusionEntry_MatchVariable_ARM_RequestHeaderKeys,
		OwaspCrsExclusionEntry_MatchVariable_ARM_RequestHeaderNames,
		OwaspCrsExclusionEntry_MatchVariable_ARM_RequestHeaderValues))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["SelectorMatchOperator"] = gen.PtrOf(gen.OneConstOf(
		OwaspCrsExclusionEntry_SelectorMatchOperator_ARM_Contains,
		OwaspCrsExclusionEntry_SelectorMatchOperator_ARM_EndsWith,
		OwaspCrsExclusionEntry_SelectorMatchOperator_ARM_Equals,
		OwaspCrsExclusionEntry_SelectorMatchOperator_ARM_EqualsAny,
		OwaspCrsExclusionEntry_SelectorMatchOperator_ARM_StartsWith))
}

// AddRelatedPropertyGeneratorsForOwaspCrsExclusionEntry_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOwaspCrsExclusionEntry_ARM(gens map[string]gopter.Gen) {
	gens["ExclusionManagedRuleSets"] = gen.SliceOf(ExclusionManagedRuleSet_ARMGenerator())
}

func Test_PolicySettings_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PolicySettings_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPolicySettings_ARM, PolicySettings_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPolicySettings_ARM runs a test to see if a specific instance of PolicySettings_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPolicySettings_ARM(subject PolicySettings_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PolicySettings_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PolicySettings_ARM instances for property testing - lazily instantiated by PolicySettings_ARMGenerator()
var policySettings_ARMGenerator gopter.Gen

// PolicySettings_ARMGenerator returns a generator of PolicySettings_ARM instances for property testing.
// We first initialize policySettings_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PolicySettings_ARMGenerator() gopter.Gen {
	if policySettings_ARMGenerator != nil {
		return policySettings_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPolicySettings_ARM(generators)
	policySettings_ARMGenerator = gen.Struct(reflect.TypeOf(PolicySettings_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPolicySettings_ARM(generators)
	AddRelatedPropertyGeneratorsForPolicySettings_ARM(generators)
	policySettings_ARMGenerator = gen.Struct(reflect.TypeOf(PolicySettings_ARM{}), generators)

	return policySettings_ARMGenerator
}

// AddIndependentPropertyGeneratorsForPolicySettings_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPolicySettings_ARM(gens map[string]gopter.Gen) {
	gens["CustomBlockResponseBody"] = gen.PtrOf(gen.AlphaString())
	gens["CustomBlockResponseStatusCode"] = gen.PtrOf(gen.Int())
	gens["FileUploadEnforcement"] = gen.PtrOf(gen.Bool())
	gens["FileUploadLimitInMb"] = gen.PtrOf(gen.Int())
	gens["JsChallengeCookieExpirationInMins"] = gen.PtrOf(gen.Int())
	gens["MaxRequestBodySizeInKb"] = gen.PtrOf(gen.Int())
	gens["Mode"] = gen.PtrOf(gen.OneConstOf(PolicySettings_Mode_ARM_Detection, PolicySettings_Mode_ARM_Prevention))
	gens["RequestBodyCheck"] = gen.PtrOf(gen.Bool())
	gens["RequestBodyEnforcement"] = gen.PtrOf(gen.Bool())
	gens["RequestBodyInspectLimitInKB"] = gen.PtrOf(gen.Int())
	gens["State"] = gen.PtrOf(gen.OneConstOf(PolicySettings_State_ARM_Disabled, PolicySettings_State_ARM_Enabled))
}

// AddRelatedPropertyGeneratorsForPolicySettings_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPolicySettings_ARM(gens map[string]gopter.Gen) {
	gens["LogScrubbing"] = gen.PtrOf(PolicySettings_LogScrubbing_ARMGenerator())
}

func Test_PolicySettings_LogScrubbing_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PolicySettings_LogScrubbing_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPolicySettings_LogScrubbing_ARM, PolicySettings_LogScrubbing_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPolicySettings_LogScrubbing_ARM runs a test to see if a specific instance of PolicySettings_LogScrubbing_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPolicySettings_LogScrubbing_ARM(subject PolicySettings_LogScrubbing_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PolicySettings_LogScrubbing_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PolicySettings_LogScrubbing_ARM instances for property testing - lazily instantiated by
// PolicySettings_LogScrubbing_ARMGenerator()
var policySettings_LogScrubbing_ARMGenerator gopter.Gen

// PolicySettings_LogScrubbing_ARMGenerator returns a generator of PolicySettings_LogScrubbing_ARM instances for property testing.
// We first initialize policySettings_LogScrubbing_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PolicySettings_LogScrubbing_ARMGenerator() gopter.Gen {
	if policySettings_LogScrubbing_ARMGenerator != nil {
		return policySettings_LogScrubbing_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPolicySettings_LogScrubbing_ARM(generators)
	policySettings_LogScrubbing_ARMGenerator = gen.Struct(reflect.TypeOf(PolicySettings_LogScrubbing_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPolicySettings_LogScrubbing_ARM(generators)
	AddRelatedPropertyGeneratorsForPolicySettings_LogScrubbing_ARM(generators)
	policySettings_LogScrubbing_ARMGenerator = gen.Struct(reflect.TypeOf(PolicySettings_LogScrubbing_ARM{}), generators)

	return policySettings_LogScrubbing_ARMGenerator
}

// AddIndependentPropertyGeneratorsForPolicySettings_LogScrubbing_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPolicySettings_LogScrubbing_ARM(gens map[string]gopter.Gen) {
	gens["State"] = gen.PtrOf(gen.OneConstOf(PolicySettings_LogScrubbing_State_ARM_Disabled, PolicySettings_LogScrubbing_State_ARM_Enabled))
}

// AddRelatedPropertyGeneratorsForPolicySettings_LogScrubbing_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPolicySettings_LogScrubbing_ARM(gens map[string]gopter.Gen) {
	gens["ScrubbingRules"] = gen.SliceOf(WebApplicationFirewallScrubbingRules_ARMGenerator())
}

func Test_WebApplicationFirewallCustomRule_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebApplicationFirewallCustomRule_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebApplicationFirewallCustomRule_ARM, WebApplicationFirewallCustomRule_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebApplicationFirewallCustomRule_ARM runs a test to see if a specific instance of WebApplicationFirewallCustomRule_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebApplicationFirewallCustomRule_ARM(subject WebApplicationFirewallCustomRule_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebApplicationFirewallCustomRule_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebApplicationFirewallCustomRule_ARM instances for property testing - lazily instantiated by
// WebApplicationFirewallCustomRule_ARMGenerator()
var webApplicationFirewallCustomRule_ARMGenerator gopter.Gen

// WebApplicationFirewallCustomRule_ARMGenerator returns a generator of WebApplicationFirewallCustomRule_ARM instances for property testing.
// We first initialize webApplicationFirewallCustomRule_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WebApplicationFirewallCustomRule_ARMGenerator() gopter.Gen {
	if webApplicationFirewallCustomRule_ARMGenerator != nil {
		return webApplicationFirewallCustomRule_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebApplicationFirewallCustomRule_ARM(generators)
	webApplicationFirewallCustomRule_ARMGenerator = gen.Struct(reflect.TypeOf(WebApplicationFirewallCustomRule_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebApplicationFirewallCustomRule_ARM(generators)
	AddRelatedPropertyGeneratorsForWebApplicationFirewallCustomRule_ARM(generators)
	webApplicationFirewallCustomRule_ARMGenerator = gen.Struct(reflect.TypeOf(WebApplicationFirewallCustomRule_ARM{}), generators)

	return webApplicationFirewallCustomRule_ARMGenerator
}

// AddIndependentPropertyGeneratorsForWebApplicationFirewallCustomRule_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebApplicationFirewallCustomRule_ARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(
		WebApplicationFirewallCustomRule_Action_ARM_Allow,
		WebApplicationFirewallCustomRule_Action_ARM_Block,
		WebApplicationFirewallCustomRule_Action_ARM_JSChallenge,
		WebApplicationFirewallCustomRule_Action_ARM_Log))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["RateLimitDuration"] = gen.PtrOf(gen.OneConstOf(WebApplicationFirewallCustomRule_RateLimitDuration_ARM_FiveMins, WebApplicationFirewallCustomRule_RateLimitDuration_ARM_OneMin))
	gens["RateLimitThreshold"] = gen.PtrOf(gen.Int())
	gens["RuleType"] = gen.PtrOf(gen.OneConstOf(WebApplicationFirewallCustomRule_RuleType_ARM_Invalid, WebApplicationFirewallCustomRule_RuleType_ARM_MatchRule, WebApplicationFirewallCustomRule_RuleType_ARM_RateLimitRule))
	gens["State"] = gen.PtrOf(gen.OneConstOf(WebApplicationFirewallCustomRule_State_ARM_Disabled, WebApplicationFirewallCustomRule_State_ARM_Enabled))
}

// AddRelatedPropertyGeneratorsForWebApplicationFirewallCustomRule_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebApplicationFirewallCustomRule_ARM(gens map[string]gopter.Gen) {
	gens["GroupByUserSession"] = gen.SliceOf(GroupByUserSession_ARMGenerator())
	gens["MatchConditions"] = gen.SliceOf(MatchCondition_ARMGenerator())
}

func Test_WebApplicationFirewallPolicyPropertiesFormat_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebApplicationFirewallPolicyPropertiesFormat_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebApplicationFirewallPolicyPropertiesFormat_ARM, WebApplicationFirewallPolicyPropertiesFormat_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebApplicationFirewallPolicyPropertiesFormat_ARM runs a test to see if a specific instance of WebApplicationFirewallPolicyPropertiesFormat_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebApplicationFirewallPolicyPropertiesFormat_ARM(subject WebApplicationFirewallPolicyPropertiesFormat_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebApplicationFirewallPolicyPropertiesFormat_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebApplicationFirewallPolicyPropertiesFormat_ARM instances for property testing - lazily instantiated by
// WebApplicationFirewallPolicyPropertiesFormat_ARMGenerator()
var webApplicationFirewallPolicyPropertiesFormat_ARMGenerator gopter.Gen

// WebApplicationFirewallPolicyPropertiesFormat_ARMGenerator returns a generator of WebApplicationFirewallPolicyPropertiesFormat_ARM instances for property testing.
func WebApplicationFirewallPolicyPropertiesFormat_ARMGenerator() gopter.Gen {
	if webApplicationFirewallPolicyPropertiesFormat_ARMGenerator != nil {
		return webApplicationFirewallPolicyPropertiesFormat_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWebApplicationFirewallPolicyPropertiesFormat_ARM(generators)
	webApplicationFirewallPolicyPropertiesFormat_ARMGenerator = gen.Struct(reflect.TypeOf(WebApplicationFirewallPolicyPropertiesFormat_ARM{}), generators)

	return webApplicationFirewallPolicyPropertiesFormat_ARMGenerator
}

// AddRelatedPropertyGeneratorsForWebApplicationFirewallPolicyPropertiesFormat_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebApplicationFirewallPolicyPropertiesFormat_ARM(gens map[string]gopter.Gen) {
	gens["CustomRules"] = gen.SliceOf(WebApplicationFirewallCustomRule_ARMGenerator())
	gens["ManagedRules"] = gen.PtrOf(ManagedRulesDefinition_ARMGenerator())
	gens["PolicySettings"] = gen.PtrOf(PolicySettings_ARMGenerator())
}

func Test_WebApplicationFirewallPolicy_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebApplicationFirewallPolicy_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebApplicationFirewallPolicy_Spec_ARM, WebApplicationFirewallPolicy_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebApplicationFirewallPolicy_Spec_ARM runs a test to see if a specific instance of WebApplicationFirewallPolicy_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebApplicationFirewallPolicy_Spec_ARM(subject WebApplicationFirewallPolicy_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebApplicationFirewallPolicy_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebApplicationFirewallPolicy_Spec_ARM instances for property testing - lazily instantiated by
// WebApplicationFirewallPolicy_Spec_ARMGenerator()
var webApplicationFirewallPolicy_Spec_ARMGenerator gopter.Gen

// WebApplicationFirewallPolicy_Spec_ARMGenerator returns a generator of WebApplicationFirewallPolicy_Spec_ARM instances for property testing.
// We first initialize webApplicationFirewallPolicy_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WebApplicationFirewallPolicy_Spec_ARMGenerator() gopter.Gen {
	if webApplicationFirewallPolicy_Spec_ARMGenerator != nil {
		return webApplicationFirewallPolicy_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebApplicationFirewallPolicy_Spec_ARM(generators)
	webApplicationFirewallPolicy_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(WebApplicationFirewallPolicy_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebApplicationFirewallPolicy_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForWebApplicationFirewallPolicy_Spec_ARM(generators)
	webApplicationFirewallPolicy_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(WebApplicationFirewallPolicy_Spec_ARM{}), generators)

	return webApplicationFirewallPolicy_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForWebApplicationFirewallPolicy_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebApplicationFirewallPolicy_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWebApplicationFirewallPolicy_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebApplicationFirewallPolicy_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(WebApplicationFirewallPolicyPropertiesFormat_ARMGenerator())
}

func Test_WebApplicationFirewallScrubbingRules_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebApplicationFirewallScrubbingRules_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebApplicationFirewallScrubbingRules_ARM, WebApplicationFirewallScrubbingRules_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebApplicationFirewallScrubbingRules_ARM runs a test to see if a specific instance of WebApplicationFirewallScrubbingRules_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebApplicationFirewallScrubbingRules_ARM(subject WebApplicationFirewallScrubbingRules_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebApplicationFirewallScrubbingRules_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebApplicationFirewallScrubbingRules_ARM instances for property testing - lazily instantiated by
// WebApplicationFirewallScrubbingRules_ARMGenerator()
var webApplicationFirewallScrubbingRules_ARMGenerator gopter.Gen

// WebApplicationFirewallScrubbingRules_ARMGenerator returns a generator of WebApplicationFirewallScrubbingRules_ARM instances for property testing.
func WebApplicationFirewallScrubbingRules_ARMGenerator() gopter.Gen {
	if webApplicationFirewallScrubbingRules_ARMGenerator != nil {
		return webApplicationFirewallScrubbingRules_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebApplicationFirewallScrubbingRules_ARM(generators)
	webApplicationFirewallScrubbingRules_ARMGenerator = gen.Struct(reflect.TypeOf(WebApplicationFirewallScrubbingRules_ARM{}), generators)

	return webApplicationFirewallScrubbingRules_ARMGenerator
}

// AddIndependentPropertyGeneratorsForWebApplicationFirewallScrubbingRules_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebApplicationFirewallScrubbingRules_ARM(gens map[string]gopter.Gen) {
	gens["MatchVariable"] = gen.PtrOf(gen.OneConstOf(
		WebApplicationFirewallScrubbingRules_MatchVariable_ARM_RequestArgNames,
		WebApplicationFirewallScrubbingRules_MatchVariable_ARM_RequestCookieNames,
		WebApplicationFirewallScrubbingRules_MatchVariable_ARM_RequestHeaderNames,
		WebApplicationFirewallScrubbingRules_MatchVariable_ARM_RequestIPAddress,
		WebApplicationFirewallScrubbingRules_MatchVariable_ARM_RequestJSONArgNames,
		WebApplicationFirewallScrubbingRules_MatchVariable_ARM_RequestPostArgNames))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["SelectorMatchOperator"] = gen.PtrOf(gen.OneConstOf(WebApplicationFirewallScrubbingRules_SelectorMatchOperator_ARM_Equals, WebApplicationFirewallScrubbingRules_SelectorMatchOperator_ARM_EqualsAny))
	gens["State"] = gen.PtrOf(gen.OneConstOf(WebApplicationFirewallScrubbingRules_State_ARM_Disabled, WebApplicationFirewallScrubbingRules_State_ARM_Enabled))
}
