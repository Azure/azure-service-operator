// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240101

import (
	"encoding/json"
	storage "github.com/Azure/azure-service-operator/v2/api/network/v1api20240101/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded to ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded via AssignProperties_To_ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded & AssignProperties_From_ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded, ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded tests if a specific instance of ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded(subject ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded
	err := copied.AssignProperties_To_ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded
	err = actual.AssignProperties_From_ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded, ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded runs a test to see if a specific instance of ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded(subject ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded instances
// for property testing - lazily instantiated by
// ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbeddedGenerator()
var applicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbeddedGenerator gopter.Gen

// ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbeddedGenerator returns a generator of ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded instances for property testing.
func ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbeddedGenerator() gopter.Gen {
	if applicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbeddedGenerator != nil {
		return applicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded(generators)
	applicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded{}), generators)

	return applicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExclusionManagedRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExclusionManagedRule to ExclusionManagedRule via AssignProperties_To_ExclusionManagedRule & AssignProperties_From_ExclusionManagedRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForExclusionManagedRule, ExclusionManagedRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExclusionManagedRule tests if a specific instance of ExclusionManagedRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForExclusionManagedRule(subject ExclusionManagedRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ExclusionManagedRule
	err := copied.AssignProperties_To_ExclusionManagedRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExclusionManagedRule
	err = actual.AssignProperties_From_ExclusionManagedRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExclusionManagedRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExclusionManagedRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExclusionManagedRule, ExclusionManagedRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExclusionManagedRule runs a test to see if a specific instance of ExclusionManagedRule round trips to JSON and back losslessly
func RunJSONSerializationTestForExclusionManagedRule(subject ExclusionManagedRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExclusionManagedRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExclusionManagedRule instances for property testing - lazily instantiated by
// ExclusionManagedRuleGenerator()
var exclusionManagedRuleGenerator gopter.Gen

// ExclusionManagedRuleGenerator returns a generator of ExclusionManagedRule instances for property testing.
func ExclusionManagedRuleGenerator() gopter.Gen {
	if exclusionManagedRuleGenerator != nil {
		return exclusionManagedRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExclusionManagedRule(generators)
	exclusionManagedRuleGenerator = gen.Struct(reflect.TypeOf(ExclusionManagedRule{}), generators)

	return exclusionManagedRuleGenerator
}

// AddIndependentPropertyGeneratorsForExclusionManagedRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExclusionManagedRule(gens map[string]gopter.Gen) {
	gens["RuleId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExclusionManagedRuleGroup_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExclusionManagedRuleGroup to ExclusionManagedRuleGroup via AssignProperties_To_ExclusionManagedRuleGroup & AssignProperties_From_ExclusionManagedRuleGroup returns original",
		prop.ForAll(RunPropertyAssignmentTestForExclusionManagedRuleGroup, ExclusionManagedRuleGroupGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExclusionManagedRuleGroup tests if a specific instance of ExclusionManagedRuleGroup can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForExclusionManagedRuleGroup(subject ExclusionManagedRuleGroup) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ExclusionManagedRuleGroup
	err := copied.AssignProperties_To_ExclusionManagedRuleGroup(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExclusionManagedRuleGroup
	err = actual.AssignProperties_From_ExclusionManagedRuleGroup(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExclusionManagedRuleGroup_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExclusionManagedRuleGroup via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExclusionManagedRuleGroup, ExclusionManagedRuleGroupGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExclusionManagedRuleGroup runs a test to see if a specific instance of ExclusionManagedRuleGroup round trips to JSON and back losslessly
func RunJSONSerializationTestForExclusionManagedRuleGroup(subject ExclusionManagedRuleGroup) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExclusionManagedRuleGroup
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExclusionManagedRuleGroup instances for property testing - lazily instantiated by
// ExclusionManagedRuleGroupGenerator()
var exclusionManagedRuleGroupGenerator gopter.Gen

// ExclusionManagedRuleGroupGenerator returns a generator of ExclusionManagedRuleGroup instances for property testing.
// We first initialize exclusionManagedRuleGroupGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ExclusionManagedRuleGroupGenerator() gopter.Gen {
	if exclusionManagedRuleGroupGenerator != nil {
		return exclusionManagedRuleGroupGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExclusionManagedRuleGroup(generators)
	exclusionManagedRuleGroupGenerator = gen.Struct(reflect.TypeOf(ExclusionManagedRuleGroup{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExclusionManagedRuleGroup(generators)
	AddRelatedPropertyGeneratorsForExclusionManagedRuleGroup(generators)
	exclusionManagedRuleGroupGenerator = gen.Struct(reflect.TypeOf(ExclusionManagedRuleGroup{}), generators)

	return exclusionManagedRuleGroupGenerator
}

// AddIndependentPropertyGeneratorsForExclusionManagedRuleGroup is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExclusionManagedRuleGroup(gens map[string]gopter.Gen) {
	gens["RuleGroupName"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForExclusionManagedRuleGroup is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExclusionManagedRuleGroup(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(ExclusionManagedRuleGenerator())
}

func Test_ExclusionManagedRuleGroup_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExclusionManagedRuleGroup_STATUS to ExclusionManagedRuleGroup_STATUS via AssignProperties_To_ExclusionManagedRuleGroup_STATUS & AssignProperties_From_ExclusionManagedRuleGroup_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForExclusionManagedRuleGroup_STATUS, ExclusionManagedRuleGroup_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExclusionManagedRuleGroup_STATUS tests if a specific instance of ExclusionManagedRuleGroup_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForExclusionManagedRuleGroup_STATUS(subject ExclusionManagedRuleGroup_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ExclusionManagedRuleGroup_STATUS
	err := copied.AssignProperties_To_ExclusionManagedRuleGroup_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExclusionManagedRuleGroup_STATUS
	err = actual.AssignProperties_From_ExclusionManagedRuleGroup_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExclusionManagedRuleGroup_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExclusionManagedRuleGroup_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExclusionManagedRuleGroup_STATUS, ExclusionManagedRuleGroup_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExclusionManagedRuleGroup_STATUS runs a test to see if a specific instance of ExclusionManagedRuleGroup_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForExclusionManagedRuleGroup_STATUS(subject ExclusionManagedRuleGroup_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExclusionManagedRuleGroup_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExclusionManagedRuleGroup_STATUS instances for property testing - lazily instantiated by
// ExclusionManagedRuleGroup_STATUSGenerator()
var exclusionManagedRuleGroup_STATUSGenerator gopter.Gen

// ExclusionManagedRuleGroup_STATUSGenerator returns a generator of ExclusionManagedRuleGroup_STATUS instances for property testing.
// We first initialize exclusionManagedRuleGroup_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ExclusionManagedRuleGroup_STATUSGenerator() gopter.Gen {
	if exclusionManagedRuleGroup_STATUSGenerator != nil {
		return exclusionManagedRuleGroup_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExclusionManagedRuleGroup_STATUS(generators)
	exclusionManagedRuleGroup_STATUSGenerator = gen.Struct(reflect.TypeOf(ExclusionManagedRuleGroup_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExclusionManagedRuleGroup_STATUS(generators)
	AddRelatedPropertyGeneratorsForExclusionManagedRuleGroup_STATUS(generators)
	exclusionManagedRuleGroup_STATUSGenerator = gen.Struct(reflect.TypeOf(ExclusionManagedRuleGroup_STATUS{}), generators)

	return exclusionManagedRuleGroup_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForExclusionManagedRuleGroup_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExclusionManagedRuleGroup_STATUS(gens map[string]gopter.Gen) {
	gens["RuleGroupName"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForExclusionManagedRuleGroup_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExclusionManagedRuleGroup_STATUS(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(ExclusionManagedRule_STATUSGenerator())
}

func Test_ExclusionManagedRuleSet_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExclusionManagedRuleSet to ExclusionManagedRuleSet via AssignProperties_To_ExclusionManagedRuleSet & AssignProperties_From_ExclusionManagedRuleSet returns original",
		prop.ForAll(RunPropertyAssignmentTestForExclusionManagedRuleSet, ExclusionManagedRuleSetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExclusionManagedRuleSet tests if a specific instance of ExclusionManagedRuleSet can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForExclusionManagedRuleSet(subject ExclusionManagedRuleSet) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ExclusionManagedRuleSet
	err := copied.AssignProperties_To_ExclusionManagedRuleSet(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExclusionManagedRuleSet
	err = actual.AssignProperties_From_ExclusionManagedRuleSet(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExclusionManagedRuleSet_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExclusionManagedRuleSet via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExclusionManagedRuleSet, ExclusionManagedRuleSetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExclusionManagedRuleSet runs a test to see if a specific instance of ExclusionManagedRuleSet round trips to JSON and back losslessly
func RunJSONSerializationTestForExclusionManagedRuleSet(subject ExclusionManagedRuleSet) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExclusionManagedRuleSet
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExclusionManagedRuleSet instances for property testing - lazily instantiated by
// ExclusionManagedRuleSetGenerator()
var exclusionManagedRuleSetGenerator gopter.Gen

// ExclusionManagedRuleSetGenerator returns a generator of ExclusionManagedRuleSet instances for property testing.
// We first initialize exclusionManagedRuleSetGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ExclusionManagedRuleSetGenerator() gopter.Gen {
	if exclusionManagedRuleSetGenerator != nil {
		return exclusionManagedRuleSetGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExclusionManagedRuleSet(generators)
	exclusionManagedRuleSetGenerator = gen.Struct(reflect.TypeOf(ExclusionManagedRuleSet{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExclusionManagedRuleSet(generators)
	AddRelatedPropertyGeneratorsForExclusionManagedRuleSet(generators)
	exclusionManagedRuleSetGenerator = gen.Struct(reflect.TypeOf(ExclusionManagedRuleSet{}), generators)

	return exclusionManagedRuleSetGenerator
}

// AddIndependentPropertyGeneratorsForExclusionManagedRuleSet is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExclusionManagedRuleSet(gens map[string]gopter.Gen) {
	gens["RuleSetType"] = gen.PtrOf(gen.AlphaString())
	gens["RuleSetVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForExclusionManagedRuleSet is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExclusionManagedRuleSet(gens map[string]gopter.Gen) {
	gens["RuleGroups"] = gen.SliceOf(ExclusionManagedRuleGroupGenerator())
}

func Test_ExclusionManagedRuleSet_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExclusionManagedRuleSet_STATUS to ExclusionManagedRuleSet_STATUS via AssignProperties_To_ExclusionManagedRuleSet_STATUS & AssignProperties_From_ExclusionManagedRuleSet_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForExclusionManagedRuleSet_STATUS, ExclusionManagedRuleSet_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExclusionManagedRuleSet_STATUS tests if a specific instance of ExclusionManagedRuleSet_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForExclusionManagedRuleSet_STATUS(subject ExclusionManagedRuleSet_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ExclusionManagedRuleSet_STATUS
	err := copied.AssignProperties_To_ExclusionManagedRuleSet_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExclusionManagedRuleSet_STATUS
	err = actual.AssignProperties_From_ExclusionManagedRuleSet_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExclusionManagedRuleSet_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExclusionManagedRuleSet_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExclusionManagedRuleSet_STATUS, ExclusionManagedRuleSet_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExclusionManagedRuleSet_STATUS runs a test to see if a specific instance of ExclusionManagedRuleSet_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForExclusionManagedRuleSet_STATUS(subject ExclusionManagedRuleSet_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExclusionManagedRuleSet_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExclusionManagedRuleSet_STATUS instances for property testing - lazily instantiated by
// ExclusionManagedRuleSet_STATUSGenerator()
var exclusionManagedRuleSet_STATUSGenerator gopter.Gen

// ExclusionManagedRuleSet_STATUSGenerator returns a generator of ExclusionManagedRuleSet_STATUS instances for property testing.
// We first initialize exclusionManagedRuleSet_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ExclusionManagedRuleSet_STATUSGenerator() gopter.Gen {
	if exclusionManagedRuleSet_STATUSGenerator != nil {
		return exclusionManagedRuleSet_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExclusionManagedRuleSet_STATUS(generators)
	exclusionManagedRuleSet_STATUSGenerator = gen.Struct(reflect.TypeOf(ExclusionManagedRuleSet_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExclusionManagedRuleSet_STATUS(generators)
	AddRelatedPropertyGeneratorsForExclusionManagedRuleSet_STATUS(generators)
	exclusionManagedRuleSet_STATUSGenerator = gen.Struct(reflect.TypeOf(ExclusionManagedRuleSet_STATUS{}), generators)

	return exclusionManagedRuleSet_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForExclusionManagedRuleSet_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExclusionManagedRuleSet_STATUS(gens map[string]gopter.Gen) {
	gens["RuleSetType"] = gen.PtrOf(gen.AlphaString())
	gens["RuleSetVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForExclusionManagedRuleSet_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExclusionManagedRuleSet_STATUS(gens map[string]gopter.Gen) {
	gens["RuleGroups"] = gen.SliceOf(ExclusionManagedRuleGroup_STATUSGenerator())
}

func Test_ExclusionManagedRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExclusionManagedRule_STATUS to ExclusionManagedRule_STATUS via AssignProperties_To_ExclusionManagedRule_STATUS & AssignProperties_From_ExclusionManagedRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForExclusionManagedRule_STATUS, ExclusionManagedRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExclusionManagedRule_STATUS tests if a specific instance of ExclusionManagedRule_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForExclusionManagedRule_STATUS(subject ExclusionManagedRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ExclusionManagedRule_STATUS
	err := copied.AssignProperties_To_ExclusionManagedRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExclusionManagedRule_STATUS
	err = actual.AssignProperties_From_ExclusionManagedRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExclusionManagedRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExclusionManagedRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExclusionManagedRule_STATUS, ExclusionManagedRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExclusionManagedRule_STATUS runs a test to see if a specific instance of ExclusionManagedRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForExclusionManagedRule_STATUS(subject ExclusionManagedRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExclusionManagedRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExclusionManagedRule_STATUS instances for property testing - lazily instantiated by
// ExclusionManagedRule_STATUSGenerator()
var exclusionManagedRule_STATUSGenerator gopter.Gen

// ExclusionManagedRule_STATUSGenerator returns a generator of ExclusionManagedRule_STATUS instances for property testing.
func ExclusionManagedRule_STATUSGenerator() gopter.Gen {
	if exclusionManagedRule_STATUSGenerator != nil {
		return exclusionManagedRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExclusionManagedRule_STATUS(generators)
	exclusionManagedRule_STATUSGenerator = gen.Struct(reflect.TypeOf(ExclusionManagedRule_STATUS{}), generators)

	return exclusionManagedRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForExclusionManagedRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExclusionManagedRule_STATUS(gens map[string]gopter.Gen) {
	gens["RuleId"] = gen.PtrOf(gen.AlphaString())
}

func Test_GroupByUserSession_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from GroupByUserSession to GroupByUserSession via AssignProperties_To_GroupByUserSession & AssignProperties_From_GroupByUserSession returns original",
		prop.ForAll(RunPropertyAssignmentTestForGroupByUserSession, GroupByUserSessionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForGroupByUserSession tests if a specific instance of GroupByUserSession can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForGroupByUserSession(subject GroupByUserSession) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.GroupByUserSession
	err := copied.AssignProperties_To_GroupByUserSession(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual GroupByUserSession
	err = actual.AssignProperties_From_GroupByUserSession(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_GroupByUserSession_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GroupByUserSession via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGroupByUserSession, GroupByUserSessionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGroupByUserSession runs a test to see if a specific instance of GroupByUserSession round trips to JSON and back losslessly
func RunJSONSerializationTestForGroupByUserSession(subject GroupByUserSession) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GroupByUserSession
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GroupByUserSession instances for property testing - lazily instantiated by GroupByUserSessionGenerator()
var groupByUserSessionGenerator gopter.Gen

// GroupByUserSessionGenerator returns a generator of GroupByUserSession instances for property testing.
func GroupByUserSessionGenerator() gopter.Gen {
	if groupByUserSessionGenerator != nil {
		return groupByUserSessionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForGroupByUserSession(generators)
	groupByUserSessionGenerator = gen.Struct(reflect.TypeOf(GroupByUserSession{}), generators)

	return groupByUserSessionGenerator
}

// AddRelatedPropertyGeneratorsForGroupByUserSession is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForGroupByUserSession(gens map[string]gopter.Gen) {
	gens["GroupByVariables"] = gen.SliceOf(GroupByVariableGenerator())
}

func Test_GroupByUserSession_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from GroupByUserSession_STATUS to GroupByUserSession_STATUS via AssignProperties_To_GroupByUserSession_STATUS & AssignProperties_From_GroupByUserSession_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForGroupByUserSession_STATUS, GroupByUserSession_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForGroupByUserSession_STATUS tests if a specific instance of GroupByUserSession_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForGroupByUserSession_STATUS(subject GroupByUserSession_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.GroupByUserSession_STATUS
	err := copied.AssignProperties_To_GroupByUserSession_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual GroupByUserSession_STATUS
	err = actual.AssignProperties_From_GroupByUserSession_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_GroupByUserSession_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GroupByUserSession_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGroupByUserSession_STATUS, GroupByUserSession_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGroupByUserSession_STATUS runs a test to see if a specific instance of GroupByUserSession_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForGroupByUserSession_STATUS(subject GroupByUserSession_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GroupByUserSession_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GroupByUserSession_STATUS instances for property testing - lazily instantiated by
// GroupByUserSession_STATUSGenerator()
var groupByUserSession_STATUSGenerator gopter.Gen

// GroupByUserSession_STATUSGenerator returns a generator of GroupByUserSession_STATUS instances for property testing.
func GroupByUserSession_STATUSGenerator() gopter.Gen {
	if groupByUserSession_STATUSGenerator != nil {
		return groupByUserSession_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForGroupByUserSession_STATUS(generators)
	groupByUserSession_STATUSGenerator = gen.Struct(reflect.TypeOf(GroupByUserSession_STATUS{}), generators)

	return groupByUserSession_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForGroupByUserSession_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForGroupByUserSession_STATUS(gens map[string]gopter.Gen) {
	gens["GroupByVariables"] = gen.SliceOf(GroupByVariable_STATUSGenerator())
}

func Test_GroupByVariable_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from GroupByVariable to GroupByVariable via AssignProperties_To_GroupByVariable & AssignProperties_From_GroupByVariable returns original",
		prop.ForAll(RunPropertyAssignmentTestForGroupByVariable, GroupByVariableGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForGroupByVariable tests if a specific instance of GroupByVariable can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForGroupByVariable(subject GroupByVariable) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.GroupByVariable
	err := copied.AssignProperties_To_GroupByVariable(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual GroupByVariable
	err = actual.AssignProperties_From_GroupByVariable(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_GroupByVariable_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GroupByVariable via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGroupByVariable, GroupByVariableGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGroupByVariable runs a test to see if a specific instance of GroupByVariable round trips to JSON and back losslessly
func RunJSONSerializationTestForGroupByVariable(subject GroupByVariable) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GroupByVariable
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GroupByVariable instances for property testing - lazily instantiated by GroupByVariableGenerator()
var groupByVariableGenerator gopter.Gen

// GroupByVariableGenerator returns a generator of GroupByVariable instances for property testing.
func GroupByVariableGenerator() gopter.Gen {
	if groupByVariableGenerator != nil {
		return groupByVariableGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGroupByVariable(generators)
	groupByVariableGenerator = gen.Struct(reflect.TypeOf(GroupByVariable{}), generators)

	return groupByVariableGenerator
}

// AddIndependentPropertyGeneratorsForGroupByVariable is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGroupByVariable(gens map[string]gopter.Gen) {
	gens["VariableName"] = gen.PtrOf(gen.OneConstOf(GroupByVariable_VariableName_ClientAddr, GroupByVariable_VariableName_GeoLocation, GroupByVariable_VariableName_None))
}

func Test_GroupByVariable_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from GroupByVariable_STATUS to GroupByVariable_STATUS via AssignProperties_To_GroupByVariable_STATUS & AssignProperties_From_GroupByVariable_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForGroupByVariable_STATUS, GroupByVariable_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForGroupByVariable_STATUS tests if a specific instance of GroupByVariable_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForGroupByVariable_STATUS(subject GroupByVariable_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.GroupByVariable_STATUS
	err := copied.AssignProperties_To_GroupByVariable_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual GroupByVariable_STATUS
	err = actual.AssignProperties_From_GroupByVariable_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_GroupByVariable_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GroupByVariable_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGroupByVariable_STATUS, GroupByVariable_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGroupByVariable_STATUS runs a test to see if a specific instance of GroupByVariable_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForGroupByVariable_STATUS(subject GroupByVariable_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GroupByVariable_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GroupByVariable_STATUS instances for property testing - lazily instantiated by
// GroupByVariable_STATUSGenerator()
var groupByVariable_STATUSGenerator gopter.Gen

// GroupByVariable_STATUSGenerator returns a generator of GroupByVariable_STATUS instances for property testing.
func GroupByVariable_STATUSGenerator() gopter.Gen {
	if groupByVariable_STATUSGenerator != nil {
		return groupByVariable_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGroupByVariable_STATUS(generators)
	groupByVariable_STATUSGenerator = gen.Struct(reflect.TypeOf(GroupByVariable_STATUS{}), generators)

	return groupByVariable_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForGroupByVariable_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGroupByVariable_STATUS(gens map[string]gopter.Gen) {
	gens["VariableName"] = gen.PtrOf(gen.OneConstOf(GroupByVariable_VariableName_STATUS_ClientAddr, GroupByVariable_VariableName_STATUS_GeoLocation, GroupByVariable_VariableName_STATUS_None))
}

func Test_ManagedRuleGroupOverride_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedRuleGroupOverride to ManagedRuleGroupOverride via AssignProperties_To_ManagedRuleGroupOverride & AssignProperties_From_ManagedRuleGroupOverride returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedRuleGroupOverride, ManagedRuleGroupOverrideGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedRuleGroupOverride tests if a specific instance of ManagedRuleGroupOverride can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedRuleGroupOverride(subject ManagedRuleGroupOverride) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedRuleGroupOverride
	err := copied.AssignProperties_To_ManagedRuleGroupOverride(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedRuleGroupOverride
	err = actual.AssignProperties_From_ManagedRuleGroupOverride(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedRuleGroupOverride_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedRuleGroupOverride via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedRuleGroupOverride, ManagedRuleGroupOverrideGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedRuleGroupOverride runs a test to see if a specific instance of ManagedRuleGroupOverride round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedRuleGroupOverride(subject ManagedRuleGroupOverride) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedRuleGroupOverride
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedRuleGroupOverride instances for property testing - lazily instantiated by
// ManagedRuleGroupOverrideGenerator()
var managedRuleGroupOverrideGenerator gopter.Gen

// ManagedRuleGroupOverrideGenerator returns a generator of ManagedRuleGroupOverride instances for property testing.
// We first initialize managedRuleGroupOverrideGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedRuleGroupOverrideGenerator() gopter.Gen {
	if managedRuleGroupOverrideGenerator != nil {
		return managedRuleGroupOverrideGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleGroupOverride(generators)
	managedRuleGroupOverrideGenerator = gen.Struct(reflect.TypeOf(ManagedRuleGroupOverride{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleGroupOverride(generators)
	AddRelatedPropertyGeneratorsForManagedRuleGroupOverride(generators)
	managedRuleGroupOverrideGenerator = gen.Struct(reflect.TypeOf(ManagedRuleGroupOverride{}), generators)

	return managedRuleGroupOverrideGenerator
}

// AddIndependentPropertyGeneratorsForManagedRuleGroupOverride is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedRuleGroupOverride(gens map[string]gopter.Gen) {
	gens["RuleGroupName"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedRuleGroupOverride is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedRuleGroupOverride(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(ManagedRuleOverrideGenerator())
}

func Test_ManagedRuleGroupOverride_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedRuleGroupOverride_STATUS to ManagedRuleGroupOverride_STATUS via AssignProperties_To_ManagedRuleGroupOverride_STATUS & AssignProperties_From_ManagedRuleGroupOverride_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedRuleGroupOverride_STATUS, ManagedRuleGroupOverride_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedRuleGroupOverride_STATUS tests if a specific instance of ManagedRuleGroupOverride_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedRuleGroupOverride_STATUS(subject ManagedRuleGroupOverride_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedRuleGroupOverride_STATUS
	err := copied.AssignProperties_To_ManagedRuleGroupOverride_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedRuleGroupOverride_STATUS
	err = actual.AssignProperties_From_ManagedRuleGroupOverride_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedRuleGroupOverride_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedRuleGroupOverride_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedRuleGroupOverride_STATUS, ManagedRuleGroupOverride_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedRuleGroupOverride_STATUS runs a test to see if a specific instance of ManagedRuleGroupOverride_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedRuleGroupOverride_STATUS(subject ManagedRuleGroupOverride_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedRuleGroupOverride_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedRuleGroupOverride_STATUS instances for property testing - lazily instantiated by
// ManagedRuleGroupOverride_STATUSGenerator()
var managedRuleGroupOverride_STATUSGenerator gopter.Gen

// ManagedRuleGroupOverride_STATUSGenerator returns a generator of ManagedRuleGroupOverride_STATUS instances for property testing.
// We first initialize managedRuleGroupOverride_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedRuleGroupOverride_STATUSGenerator() gopter.Gen {
	if managedRuleGroupOverride_STATUSGenerator != nil {
		return managedRuleGroupOverride_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleGroupOverride_STATUS(generators)
	managedRuleGroupOverride_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedRuleGroupOverride_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleGroupOverride_STATUS(generators)
	AddRelatedPropertyGeneratorsForManagedRuleGroupOverride_STATUS(generators)
	managedRuleGroupOverride_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedRuleGroupOverride_STATUS{}), generators)

	return managedRuleGroupOverride_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedRuleGroupOverride_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedRuleGroupOverride_STATUS(gens map[string]gopter.Gen) {
	gens["RuleGroupName"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedRuleGroupOverride_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedRuleGroupOverride_STATUS(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(ManagedRuleOverride_STATUSGenerator())
}

func Test_ManagedRuleOverride_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedRuleOverride to ManagedRuleOverride via AssignProperties_To_ManagedRuleOverride & AssignProperties_From_ManagedRuleOverride returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedRuleOverride, ManagedRuleOverrideGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedRuleOverride tests if a specific instance of ManagedRuleOverride can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedRuleOverride(subject ManagedRuleOverride) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedRuleOverride
	err := copied.AssignProperties_To_ManagedRuleOverride(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedRuleOverride
	err = actual.AssignProperties_From_ManagedRuleOverride(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedRuleOverride_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedRuleOverride via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedRuleOverride, ManagedRuleOverrideGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedRuleOverride runs a test to see if a specific instance of ManagedRuleOverride round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedRuleOverride(subject ManagedRuleOverride) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedRuleOverride
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedRuleOverride instances for property testing - lazily instantiated by
// ManagedRuleOverrideGenerator()
var managedRuleOverrideGenerator gopter.Gen

// ManagedRuleOverrideGenerator returns a generator of ManagedRuleOverride instances for property testing.
func ManagedRuleOverrideGenerator() gopter.Gen {
	if managedRuleOverrideGenerator != nil {
		return managedRuleOverrideGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleOverride(generators)
	managedRuleOverrideGenerator = gen.Struct(reflect.TypeOf(ManagedRuleOverride{}), generators)

	return managedRuleOverrideGenerator
}

// AddIndependentPropertyGeneratorsForManagedRuleOverride is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedRuleOverride(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(
		ActionType_Allow,
		ActionType_AnomalyScoring,
		ActionType_Block,
		ActionType_JSChallenge,
		ActionType_Log))
	gens["RuleId"] = gen.PtrOf(gen.AlphaString())
	gens["State"] = gen.PtrOf(gen.OneConstOf(ManagedRuleOverride_State_Disabled, ManagedRuleOverride_State_Enabled))
}

func Test_ManagedRuleOverride_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedRuleOverride_STATUS to ManagedRuleOverride_STATUS via AssignProperties_To_ManagedRuleOverride_STATUS & AssignProperties_From_ManagedRuleOverride_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedRuleOverride_STATUS, ManagedRuleOverride_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedRuleOverride_STATUS tests if a specific instance of ManagedRuleOverride_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedRuleOverride_STATUS(subject ManagedRuleOverride_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedRuleOverride_STATUS
	err := copied.AssignProperties_To_ManagedRuleOverride_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedRuleOverride_STATUS
	err = actual.AssignProperties_From_ManagedRuleOverride_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedRuleOverride_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedRuleOverride_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedRuleOverride_STATUS, ManagedRuleOverride_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedRuleOverride_STATUS runs a test to see if a specific instance of ManagedRuleOverride_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedRuleOverride_STATUS(subject ManagedRuleOverride_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedRuleOverride_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedRuleOverride_STATUS instances for property testing - lazily instantiated by
// ManagedRuleOverride_STATUSGenerator()
var managedRuleOverride_STATUSGenerator gopter.Gen

// ManagedRuleOverride_STATUSGenerator returns a generator of ManagedRuleOverride_STATUS instances for property testing.
func ManagedRuleOverride_STATUSGenerator() gopter.Gen {
	if managedRuleOverride_STATUSGenerator != nil {
		return managedRuleOverride_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleOverride_STATUS(generators)
	managedRuleOverride_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedRuleOverride_STATUS{}), generators)

	return managedRuleOverride_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedRuleOverride_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedRuleOverride_STATUS(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(
		ActionType_STATUS_Allow,
		ActionType_STATUS_AnomalyScoring,
		ActionType_STATUS_Block,
		ActionType_STATUS_JSChallenge,
		ActionType_STATUS_Log))
	gens["RuleId"] = gen.PtrOf(gen.AlphaString())
	gens["State"] = gen.PtrOf(gen.OneConstOf(ManagedRuleOverride_State_STATUS_Disabled, ManagedRuleOverride_State_STATUS_Enabled))
}

func Test_ManagedRuleSet_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedRuleSet to ManagedRuleSet via AssignProperties_To_ManagedRuleSet & AssignProperties_From_ManagedRuleSet returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedRuleSet, ManagedRuleSetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedRuleSet tests if a specific instance of ManagedRuleSet can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedRuleSet(subject ManagedRuleSet) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedRuleSet
	err := copied.AssignProperties_To_ManagedRuleSet(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedRuleSet
	err = actual.AssignProperties_From_ManagedRuleSet(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedRuleSet_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedRuleSet via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedRuleSet, ManagedRuleSetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedRuleSet runs a test to see if a specific instance of ManagedRuleSet round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedRuleSet(subject ManagedRuleSet) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedRuleSet
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedRuleSet instances for property testing - lazily instantiated by ManagedRuleSetGenerator()
var managedRuleSetGenerator gopter.Gen

// ManagedRuleSetGenerator returns a generator of ManagedRuleSet instances for property testing.
// We first initialize managedRuleSetGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedRuleSetGenerator() gopter.Gen {
	if managedRuleSetGenerator != nil {
		return managedRuleSetGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleSet(generators)
	managedRuleSetGenerator = gen.Struct(reflect.TypeOf(ManagedRuleSet{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleSet(generators)
	AddRelatedPropertyGeneratorsForManagedRuleSet(generators)
	managedRuleSetGenerator = gen.Struct(reflect.TypeOf(ManagedRuleSet{}), generators)

	return managedRuleSetGenerator
}

// AddIndependentPropertyGeneratorsForManagedRuleSet is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedRuleSet(gens map[string]gopter.Gen) {
	gens["RuleSetType"] = gen.PtrOf(gen.AlphaString())
	gens["RuleSetVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedRuleSet is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedRuleSet(gens map[string]gopter.Gen) {
	gens["RuleGroupOverrides"] = gen.SliceOf(ManagedRuleGroupOverrideGenerator())
}

func Test_ManagedRuleSet_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedRuleSet_STATUS to ManagedRuleSet_STATUS via AssignProperties_To_ManagedRuleSet_STATUS & AssignProperties_From_ManagedRuleSet_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedRuleSet_STATUS, ManagedRuleSet_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedRuleSet_STATUS tests if a specific instance of ManagedRuleSet_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedRuleSet_STATUS(subject ManagedRuleSet_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedRuleSet_STATUS
	err := copied.AssignProperties_To_ManagedRuleSet_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedRuleSet_STATUS
	err = actual.AssignProperties_From_ManagedRuleSet_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedRuleSet_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedRuleSet_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedRuleSet_STATUS, ManagedRuleSet_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedRuleSet_STATUS runs a test to see if a specific instance of ManagedRuleSet_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedRuleSet_STATUS(subject ManagedRuleSet_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedRuleSet_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedRuleSet_STATUS instances for property testing - lazily instantiated by
// ManagedRuleSet_STATUSGenerator()
var managedRuleSet_STATUSGenerator gopter.Gen

// ManagedRuleSet_STATUSGenerator returns a generator of ManagedRuleSet_STATUS instances for property testing.
// We first initialize managedRuleSet_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedRuleSet_STATUSGenerator() gopter.Gen {
	if managedRuleSet_STATUSGenerator != nil {
		return managedRuleSet_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleSet_STATUS(generators)
	managedRuleSet_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedRuleSet_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedRuleSet_STATUS(generators)
	AddRelatedPropertyGeneratorsForManagedRuleSet_STATUS(generators)
	managedRuleSet_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedRuleSet_STATUS{}), generators)

	return managedRuleSet_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedRuleSet_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedRuleSet_STATUS(gens map[string]gopter.Gen) {
	gens["RuleSetType"] = gen.PtrOf(gen.AlphaString())
	gens["RuleSetVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedRuleSet_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedRuleSet_STATUS(gens map[string]gopter.Gen) {
	gens["RuleGroupOverrides"] = gen.SliceOf(ManagedRuleGroupOverride_STATUSGenerator())
}

func Test_ManagedRulesDefinition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedRulesDefinition to ManagedRulesDefinition via AssignProperties_To_ManagedRulesDefinition & AssignProperties_From_ManagedRulesDefinition returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedRulesDefinition, ManagedRulesDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedRulesDefinition tests if a specific instance of ManagedRulesDefinition can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedRulesDefinition(subject ManagedRulesDefinition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedRulesDefinition
	err := copied.AssignProperties_To_ManagedRulesDefinition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedRulesDefinition
	err = actual.AssignProperties_From_ManagedRulesDefinition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedRulesDefinition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedRulesDefinition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedRulesDefinition, ManagedRulesDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedRulesDefinition runs a test to see if a specific instance of ManagedRulesDefinition round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedRulesDefinition(subject ManagedRulesDefinition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedRulesDefinition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedRulesDefinition instances for property testing - lazily instantiated by
// ManagedRulesDefinitionGenerator()
var managedRulesDefinitionGenerator gopter.Gen

// ManagedRulesDefinitionGenerator returns a generator of ManagedRulesDefinition instances for property testing.
func ManagedRulesDefinitionGenerator() gopter.Gen {
	if managedRulesDefinitionGenerator != nil {
		return managedRulesDefinitionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagedRulesDefinition(generators)
	managedRulesDefinitionGenerator = gen.Struct(reflect.TypeOf(ManagedRulesDefinition{}), generators)

	return managedRulesDefinitionGenerator
}

// AddRelatedPropertyGeneratorsForManagedRulesDefinition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedRulesDefinition(gens map[string]gopter.Gen) {
	gens["Exclusions"] = gen.SliceOf(OwaspCrsExclusionEntryGenerator())
	gens["ManagedRuleSets"] = gen.SliceOf(ManagedRuleSetGenerator())
}

func Test_ManagedRulesDefinition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedRulesDefinition_STATUS to ManagedRulesDefinition_STATUS via AssignProperties_To_ManagedRulesDefinition_STATUS & AssignProperties_From_ManagedRulesDefinition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedRulesDefinition_STATUS, ManagedRulesDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedRulesDefinition_STATUS tests if a specific instance of ManagedRulesDefinition_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedRulesDefinition_STATUS(subject ManagedRulesDefinition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedRulesDefinition_STATUS
	err := copied.AssignProperties_To_ManagedRulesDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedRulesDefinition_STATUS
	err = actual.AssignProperties_From_ManagedRulesDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedRulesDefinition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedRulesDefinition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedRulesDefinition_STATUS, ManagedRulesDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedRulesDefinition_STATUS runs a test to see if a specific instance of ManagedRulesDefinition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedRulesDefinition_STATUS(subject ManagedRulesDefinition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedRulesDefinition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedRulesDefinition_STATUS instances for property testing - lazily instantiated by
// ManagedRulesDefinition_STATUSGenerator()
var managedRulesDefinition_STATUSGenerator gopter.Gen

// ManagedRulesDefinition_STATUSGenerator returns a generator of ManagedRulesDefinition_STATUS instances for property testing.
func ManagedRulesDefinition_STATUSGenerator() gopter.Gen {
	if managedRulesDefinition_STATUSGenerator != nil {
		return managedRulesDefinition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagedRulesDefinition_STATUS(generators)
	managedRulesDefinition_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedRulesDefinition_STATUS{}), generators)

	return managedRulesDefinition_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForManagedRulesDefinition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedRulesDefinition_STATUS(gens map[string]gopter.Gen) {
	gens["Exclusions"] = gen.SliceOf(OwaspCrsExclusionEntry_STATUSGenerator())
	gens["ManagedRuleSets"] = gen.SliceOf(ManagedRuleSet_STATUSGenerator())
}

func Test_MatchCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MatchCondition to MatchCondition via AssignProperties_To_MatchCondition & AssignProperties_From_MatchCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForMatchCondition, MatchConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMatchCondition tests if a specific instance of MatchCondition can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMatchCondition(subject MatchCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MatchCondition
	err := copied.AssignProperties_To_MatchCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MatchCondition
	err = actual.AssignProperties_From_MatchCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MatchCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MatchCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMatchCondition, MatchConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMatchCondition runs a test to see if a specific instance of MatchCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForMatchCondition(subject MatchCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MatchCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MatchCondition instances for property testing - lazily instantiated by MatchConditionGenerator()
var matchConditionGenerator gopter.Gen

// MatchConditionGenerator returns a generator of MatchCondition instances for property testing.
// We first initialize matchConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MatchConditionGenerator() gopter.Gen {
	if matchConditionGenerator != nil {
		return matchConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMatchCondition(generators)
	matchConditionGenerator = gen.Struct(reflect.TypeOf(MatchCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMatchCondition(generators)
	AddRelatedPropertyGeneratorsForMatchCondition(generators)
	matchConditionGenerator = gen.Struct(reflect.TypeOf(MatchCondition{}), generators)

	return matchConditionGenerator
}

// AddIndependentPropertyGeneratorsForMatchCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMatchCondition(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegationConditon"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		MatchCondition_Operator_Any,
		MatchCondition_Operator_BeginsWith,
		MatchCondition_Operator_Contains,
		MatchCondition_Operator_EndsWith,
		MatchCondition_Operator_Equal,
		MatchCondition_Operator_GeoMatch,
		MatchCondition_Operator_GreaterThan,
		MatchCondition_Operator_GreaterThanOrEqual,
		MatchCondition_Operator_IPMatch,
		MatchCondition_Operator_LessThan,
		MatchCondition_Operator_LessThanOrEqual,
		MatchCondition_Operator_Regex))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_HtmlEntityDecode,
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
}

// AddRelatedPropertyGeneratorsForMatchCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMatchCondition(gens map[string]gopter.Gen) {
	gens["MatchVariables"] = gen.SliceOf(MatchVariableGenerator())
}

func Test_MatchCondition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MatchCondition_STATUS to MatchCondition_STATUS via AssignProperties_To_MatchCondition_STATUS & AssignProperties_From_MatchCondition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForMatchCondition_STATUS, MatchCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMatchCondition_STATUS tests if a specific instance of MatchCondition_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMatchCondition_STATUS(subject MatchCondition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MatchCondition_STATUS
	err := copied.AssignProperties_To_MatchCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MatchCondition_STATUS
	err = actual.AssignProperties_From_MatchCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MatchCondition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MatchCondition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMatchCondition_STATUS, MatchCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMatchCondition_STATUS runs a test to see if a specific instance of MatchCondition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMatchCondition_STATUS(subject MatchCondition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MatchCondition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MatchCondition_STATUS instances for property testing - lazily instantiated by
// MatchCondition_STATUSGenerator()
var matchCondition_STATUSGenerator gopter.Gen

// MatchCondition_STATUSGenerator returns a generator of MatchCondition_STATUS instances for property testing.
// We first initialize matchCondition_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MatchCondition_STATUSGenerator() gopter.Gen {
	if matchCondition_STATUSGenerator != nil {
		return matchCondition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMatchCondition_STATUS(generators)
	matchCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(MatchCondition_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMatchCondition_STATUS(generators)
	AddRelatedPropertyGeneratorsForMatchCondition_STATUS(generators)
	matchCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(MatchCondition_STATUS{}), generators)

	return matchCondition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMatchCondition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMatchCondition_STATUS(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegationConditon"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		MatchCondition_Operator_STATUS_Any,
		MatchCondition_Operator_STATUS_BeginsWith,
		MatchCondition_Operator_STATUS_Contains,
		MatchCondition_Operator_STATUS_EndsWith,
		MatchCondition_Operator_STATUS_Equal,
		MatchCondition_Operator_STATUS_GeoMatch,
		MatchCondition_Operator_STATUS_GreaterThan,
		MatchCondition_Operator_STATUS_GreaterThanOrEqual,
		MatchCondition_Operator_STATUS_IPMatch,
		MatchCondition_Operator_STATUS_LessThan,
		MatchCondition_Operator_STATUS_LessThanOrEqual,
		MatchCondition_Operator_STATUS_Regex))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_STATUS_HtmlEntityDecode,
		Transform_STATUS_Lowercase,
		Transform_STATUS_RemoveNulls,
		Transform_STATUS_Trim,
		Transform_STATUS_Uppercase,
		Transform_STATUS_UrlDecode,
		Transform_STATUS_UrlEncode))
}

// AddRelatedPropertyGeneratorsForMatchCondition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMatchCondition_STATUS(gens map[string]gopter.Gen) {
	gens["MatchVariables"] = gen.SliceOf(MatchVariable_STATUSGenerator())
}

func Test_MatchVariable_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MatchVariable to MatchVariable via AssignProperties_To_MatchVariable & AssignProperties_From_MatchVariable returns original",
		prop.ForAll(RunPropertyAssignmentTestForMatchVariable, MatchVariableGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMatchVariable tests if a specific instance of MatchVariable can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMatchVariable(subject MatchVariable) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MatchVariable
	err := copied.AssignProperties_To_MatchVariable(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MatchVariable
	err = actual.AssignProperties_From_MatchVariable(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MatchVariable_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MatchVariable via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMatchVariable, MatchVariableGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMatchVariable runs a test to see if a specific instance of MatchVariable round trips to JSON and back losslessly
func RunJSONSerializationTestForMatchVariable(subject MatchVariable) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MatchVariable
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MatchVariable instances for property testing - lazily instantiated by MatchVariableGenerator()
var matchVariableGenerator gopter.Gen

// MatchVariableGenerator returns a generator of MatchVariable instances for property testing.
func MatchVariableGenerator() gopter.Gen {
	if matchVariableGenerator != nil {
		return matchVariableGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMatchVariable(generators)
	matchVariableGenerator = gen.Struct(reflect.TypeOf(MatchVariable{}), generators)

	return matchVariableGenerator
}

// AddIndependentPropertyGeneratorsForMatchVariable is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMatchVariable(gens map[string]gopter.Gen) {
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["VariableName"] = gen.PtrOf(gen.OneConstOf(
		MatchVariable_VariableName_PostArgs,
		MatchVariable_VariableName_QueryString,
		MatchVariable_VariableName_RemoteAddr,
		MatchVariable_VariableName_RequestBody,
		MatchVariable_VariableName_RequestCookies,
		MatchVariable_VariableName_RequestHeaders,
		MatchVariable_VariableName_RequestMethod,
		MatchVariable_VariableName_RequestUri))
}

func Test_MatchVariable_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MatchVariable_STATUS to MatchVariable_STATUS via AssignProperties_To_MatchVariable_STATUS & AssignProperties_From_MatchVariable_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForMatchVariable_STATUS, MatchVariable_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMatchVariable_STATUS tests if a specific instance of MatchVariable_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMatchVariable_STATUS(subject MatchVariable_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MatchVariable_STATUS
	err := copied.AssignProperties_To_MatchVariable_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MatchVariable_STATUS
	err = actual.AssignProperties_From_MatchVariable_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MatchVariable_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MatchVariable_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMatchVariable_STATUS, MatchVariable_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMatchVariable_STATUS runs a test to see if a specific instance of MatchVariable_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMatchVariable_STATUS(subject MatchVariable_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MatchVariable_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MatchVariable_STATUS instances for property testing - lazily instantiated by
// MatchVariable_STATUSGenerator()
var matchVariable_STATUSGenerator gopter.Gen

// MatchVariable_STATUSGenerator returns a generator of MatchVariable_STATUS instances for property testing.
func MatchVariable_STATUSGenerator() gopter.Gen {
	if matchVariable_STATUSGenerator != nil {
		return matchVariable_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMatchVariable_STATUS(generators)
	matchVariable_STATUSGenerator = gen.Struct(reflect.TypeOf(MatchVariable_STATUS{}), generators)

	return matchVariable_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMatchVariable_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMatchVariable_STATUS(gens map[string]gopter.Gen) {
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["VariableName"] = gen.PtrOf(gen.OneConstOf(
		MatchVariable_VariableName_STATUS_PostArgs,
		MatchVariable_VariableName_STATUS_QueryString,
		MatchVariable_VariableName_STATUS_RemoteAddr,
		MatchVariable_VariableName_STATUS_RequestBody,
		MatchVariable_VariableName_STATUS_RequestCookies,
		MatchVariable_VariableName_STATUS_RequestHeaders,
		MatchVariable_VariableName_STATUS_RequestMethod,
		MatchVariable_VariableName_STATUS_RequestUri))
}

func Test_OwaspCrsExclusionEntry_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OwaspCrsExclusionEntry to OwaspCrsExclusionEntry via AssignProperties_To_OwaspCrsExclusionEntry & AssignProperties_From_OwaspCrsExclusionEntry returns original",
		prop.ForAll(RunPropertyAssignmentTestForOwaspCrsExclusionEntry, OwaspCrsExclusionEntryGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOwaspCrsExclusionEntry tests if a specific instance of OwaspCrsExclusionEntry can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForOwaspCrsExclusionEntry(subject OwaspCrsExclusionEntry) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.OwaspCrsExclusionEntry
	err := copied.AssignProperties_To_OwaspCrsExclusionEntry(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OwaspCrsExclusionEntry
	err = actual.AssignProperties_From_OwaspCrsExclusionEntry(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OwaspCrsExclusionEntry_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OwaspCrsExclusionEntry via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOwaspCrsExclusionEntry, OwaspCrsExclusionEntryGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOwaspCrsExclusionEntry runs a test to see if a specific instance of OwaspCrsExclusionEntry round trips to JSON and back losslessly
func RunJSONSerializationTestForOwaspCrsExclusionEntry(subject OwaspCrsExclusionEntry) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OwaspCrsExclusionEntry
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OwaspCrsExclusionEntry instances for property testing - lazily instantiated by
// OwaspCrsExclusionEntryGenerator()
var owaspCrsExclusionEntryGenerator gopter.Gen

// OwaspCrsExclusionEntryGenerator returns a generator of OwaspCrsExclusionEntry instances for property testing.
// We first initialize owaspCrsExclusionEntryGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OwaspCrsExclusionEntryGenerator() gopter.Gen {
	if owaspCrsExclusionEntryGenerator != nil {
		return owaspCrsExclusionEntryGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOwaspCrsExclusionEntry(generators)
	owaspCrsExclusionEntryGenerator = gen.Struct(reflect.TypeOf(OwaspCrsExclusionEntry{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOwaspCrsExclusionEntry(generators)
	AddRelatedPropertyGeneratorsForOwaspCrsExclusionEntry(generators)
	owaspCrsExclusionEntryGenerator = gen.Struct(reflect.TypeOf(OwaspCrsExclusionEntry{}), generators)

	return owaspCrsExclusionEntryGenerator
}

// AddIndependentPropertyGeneratorsForOwaspCrsExclusionEntry is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOwaspCrsExclusionEntry(gens map[string]gopter.Gen) {
	gens["MatchVariable"] = gen.PtrOf(gen.OneConstOf(
		OwaspCrsExclusionEntry_MatchVariable_RequestArgKeys,
		OwaspCrsExclusionEntry_MatchVariable_RequestArgNames,
		OwaspCrsExclusionEntry_MatchVariable_RequestArgValues,
		OwaspCrsExclusionEntry_MatchVariable_RequestCookieKeys,
		OwaspCrsExclusionEntry_MatchVariable_RequestCookieNames,
		OwaspCrsExclusionEntry_MatchVariable_RequestCookieValues,
		OwaspCrsExclusionEntry_MatchVariable_RequestHeaderKeys,
		OwaspCrsExclusionEntry_MatchVariable_RequestHeaderNames,
		OwaspCrsExclusionEntry_MatchVariable_RequestHeaderValues))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["SelectorMatchOperator"] = gen.PtrOf(gen.OneConstOf(
		OwaspCrsExclusionEntry_SelectorMatchOperator_Contains,
		OwaspCrsExclusionEntry_SelectorMatchOperator_EndsWith,
		OwaspCrsExclusionEntry_SelectorMatchOperator_Equals,
		OwaspCrsExclusionEntry_SelectorMatchOperator_EqualsAny,
		OwaspCrsExclusionEntry_SelectorMatchOperator_StartsWith))
}

// AddRelatedPropertyGeneratorsForOwaspCrsExclusionEntry is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOwaspCrsExclusionEntry(gens map[string]gopter.Gen) {
	gens["ExclusionManagedRuleSets"] = gen.SliceOf(ExclusionManagedRuleSetGenerator())
}

func Test_OwaspCrsExclusionEntry_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OwaspCrsExclusionEntry_STATUS to OwaspCrsExclusionEntry_STATUS via AssignProperties_To_OwaspCrsExclusionEntry_STATUS & AssignProperties_From_OwaspCrsExclusionEntry_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForOwaspCrsExclusionEntry_STATUS, OwaspCrsExclusionEntry_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOwaspCrsExclusionEntry_STATUS tests if a specific instance of OwaspCrsExclusionEntry_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForOwaspCrsExclusionEntry_STATUS(subject OwaspCrsExclusionEntry_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.OwaspCrsExclusionEntry_STATUS
	err := copied.AssignProperties_To_OwaspCrsExclusionEntry_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OwaspCrsExclusionEntry_STATUS
	err = actual.AssignProperties_From_OwaspCrsExclusionEntry_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OwaspCrsExclusionEntry_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OwaspCrsExclusionEntry_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOwaspCrsExclusionEntry_STATUS, OwaspCrsExclusionEntry_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOwaspCrsExclusionEntry_STATUS runs a test to see if a specific instance of OwaspCrsExclusionEntry_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForOwaspCrsExclusionEntry_STATUS(subject OwaspCrsExclusionEntry_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OwaspCrsExclusionEntry_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OwaspCrsExclusionEntry_STATUS instances for property testing - lazily instantiated by
// OwaspCrsExclusionEntry_STATUSGenerator()
var owaspCrsExclusionEntry_STATUSGenerator gopter.Gen

// OwaspCrsExclusionEntry_STATUSGenerator returns a generator of OwaspCrsExclusionEntry_STATUS instances for property testing.
// We first initialize owaspCrsExclusionEntry_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OwaspCrsExclusionEntry_STATUSGenerator() gopter.Gen {
	if owaspCrsExclusionEntry_STATUSGenerator != nil {
		return owaspCrsExclusionEntry_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOwaspCrsExclusionEntry_STATUS(generators)
	owaspCrsExclusionEntry_STATUSGenerator = gen.Struct(reflect.TypeOf(OwaspCrsExclusionEntry_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOwaspCrsExclusionEntry_STATUS(generators)
	AddRelatedPropertyGeneratorsForOwaspCrsExclusionEntry_STATUS(generators)
	owaspCrsExclusionEntry_STATUSGenerator = gen.Struct(reflect.TypeOf(OwaspCrsExclusionEntry_STATUS{}), generators)

	return owaspCrsExclusionEntry_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForOwaspCrsExclusionEntry_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOwaspCrsExclusionEntry_STATUS(gens map[string]gopter.Gen) {
	gens["MatchVariable"] = gen.PtrOf(gen.OneConstOf(
		OwaspCrsExclusionEntry_MatchVariable_STATUS_RequestArgKeys,
		OwaspCrsExclusionEntry_MatchVariable_STATUS_RequestArgNames,
		OwaspCrsExclusionEntry_MatchVariable_STATUS_RequestArgValues,
		OwaspCrsExclusionEntry_MatchVariable_STATUS_RequestCookieKeys,
		OwaspCrsExclusionEntry_MatchVariable_STATUS_RequestCookieNames,
		OwaspCrsExclusionEntry_MatchVariable_STATUS_RequestCookieValues,
		OwaspCrsExclusionEntry_MatchVariable_STATUS_RequestHeaderKeys,
		OwaspCrsExclusionEntry_MatchVariable_STATUS_RequestHeaderNames,
		OwaspCrsExclusionEntry_MatchVariable_STATUS_RequestHeaderValues))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["SelectorMatchOperator"] = gen.PtrOf(gen.OneConstOf(
		OwaspCrsExclusionEntry_SelectorMatchOperator_STATUS_Contains,
		OwaspCrsExclusionEntry_SelectorMatchOperator_STATUS_EndsWith,
		OwaspCrsExclusionEntry_SelectorMatchOperator_STATUS_Equals,
		OwaspCrsExclusionEntry_SelectorMatchOperator_STATUS_EqualsAny,
		OwaspCrsExclusionEntry_SelectorMatchOperator_STATUS_StartsWith))
}

// AddRelatedPropertyGeneratorsForOwaspCrsExclusionEntry_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOwaspCrsExclusionEntry_STATUS(gens map[string]gopter.Gen) {
	gens["ExclusionManagedRuleSets"] = gen.SliceOf(ExclusionManagedRuleSet_STATUSGenerator())
}

func Test_PolicySettings_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PolicySettings to PolicySettings via AssignProperties_To_PolicySettings & AssignProperties_From_PolicySettings returns original",
		prop.ForAll(RunPropertyAssignmentTestForPolicySettings, PolicySettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPolicySettings tests if a specific instance of PolicySettings can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPolicySettings(subject PolicySettings) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PolicySettings
	err := copied.AssignProperties_To_PolicySettings(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PolicySettings
	err = actual.AssignProperties_From_PolicySettings(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PolicySettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PolicySettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPolicySettings, PolicySettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPolicySettings runs a test to see if a specific instance of PolicySettings round trips to JSON and back losslessly
func RunJSONSerializationTestForPolicySettings(subject PolicySettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PolicySettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PolicySettings instances for property testing - lazily instantiated by PolicySettingsGenerator()
var policySettingsGenerator gopter.Gen

// PolicySettingsGenerator returns a generator of PolicySettings instances for property testing.
// We first initialize policySettingsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PolicySettingsGenerator() gopter.Gen {
	if policySettingsGenerator != nil {
		return policySettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPolicySettings(generators)
	policySettingsGenerator = gen.Struct(reflect.TypeOf(PolicySettings{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPolicySettings(generators)
	AddRelatedPropertyGeneratorsForPolicySettings(generators)
	policySettingsGenerator = gen.Struct(reflect.TypeOf(PolicySettings{}), generators)

	return policySettingsGenerator
}

// AddIndependentPropertyGeneratorsForPolicySettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPolicySettings(gens map[string]gopter.Gen) {
	gens["CustomBlockResponseBody"] = gen.PtrOf(gen.AlphaString())
	gens["CustomBlockResponseStatusCode"] = gen.PtrOf(gen.Int())
	gens["FileUploadEnforcement"] = gen.PtrOf(gen.Bool())
	gens["FileUploadLimitInMb"] = gen.PtrOf(gen.Int())
	gens["JsChallengeCookieExpirationInMins"] = gen.PtrOf(gen.Int())
	gens["MaxRequestBodySizeInKb"] = gen.PtrOf(gen.Int())
	gens["Mode"] = gen.PtrOf(gen.OneConstOf(PolicySettings_Mode_Detection, PolicySettings_Mode_Prevention))
	gens["RequestBodyCheck"] = gen.PtrOf(gen.Bool())
	gens["RequestBodyEnforcement"] = gen.PtrOf(gen.Bool())
	gens["RequestBodyInspectLimitInKB"] = gen.PtrOf(gen.Int())
	gens["State"] = gen.PtrOf(gen.OneConstOf(PolicySettings_State_Disabled, PolicySettings_State_Enabled))
}

// AddRelatedPropertyGeneratorsForPolicySettings is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPolicySettings(gens map[string]gopter.Gen) {
	gens["LogScrubbing"] = gen.PtrOf(PolicySettings_LogScrubbingGenerator())
}

func Test_PolicySettings_LogScrubbing_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PolicySettings_LogScrubbing to PolicySettings_LogScrubbing via AssignProperties_To_PolicySettings_LogScrubbing & AssignProperties_From_PolicySettings_LogScrubbing returns original",
		prop.ForAll(RunPropertyAssignmentTestForPolicySettings_LogScrubbing, PolicySettings_LogScrubbingGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPolicySettings_LogScrubbing tests if a specific instance of PolicySettings_LogScrubbing can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPolicySettings_LogScrubbing(subject PolicySettings_LogScrubbing) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PolicySettings_LogScrubbing
	err := copied.AssignProperties_To_PolicySettings_LogScrubbing(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PolicySettings_LogScrubbing
	err = actual.AssignProperties_From_PolicySettings_LogScrubbing(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PolicySettings_LogScrubbing_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PolicySettings_LogScrubbing via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPolicySettings_LogScrubbing, PolicySettings_LogScrubbingGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPolicySettings_LogScrubbing runs a test to see if a specific instance of PolicySettings_LogScrubbing round trips to JSON and back losslessly
func RunJSONSerializationTestForPolicySettings_LogScrubbing(subject PolicySettings_LogScrubbing) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PolicySettings_LogScrubbing
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PolicySettings_LogScrubbing instances for property testing - lazily instantiated by
// PolicySettings_LogScrubbingGenerator()
var policySettings_LogScrubbingGenerator gopter.Gen

// PolicySettings_LogScrubbingGenerator returns a generator of PolicySettings_LogScrubbing instances for property testing.
// We first initialize policySettings_LogScrubbingGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PolicySettings_LogScrubbingGenerator() gopter.Gen {
	if policySettings_LogScrubbingGenerator != nil {
		return policySettings_LogScrubbingGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPolicySettings_LogScrubbing(generators)
	policySettings_LogScrubbingGenerator = gen.Struct(reflect.TypeOf(PolicySettings_LogScrubbing{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPolicySettings_LogScrubbing(generators)
	AddRelatedPropertyGeneratorsForPolicySettings_LogScrubbing(generators)
	policySettings_LogScrubbingGenerator = gen.Struct(reflect.TypeOf(PolicySettings_LogScrubbing{}), generators)

	return policySettings_LogScrubbingGenerator
}

// AddIndependentPropertyGeneratorsForPolicySettings_LogScrubbing is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPolicySettings_LogScrubbing(gens map[string]gopter.Gen) {
	gens["State"] = gen.PtrOf(gen.OneConstOf(PolicySettings_LogScrubbing_State_Disabled, PolicySettings_LogScrubbing_State_Enabled))
}

// AddRelatedPropertyGeneratorsForPolicySettings_LogScrubbing is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPolicySettings_LogScrubbing(gens map[string]gopter.Gen) {
	gens["ScrubbingRules"] = gen.SliceOf(WebApplicationFirewallScrubbingRulesGenerator())
}

func Test_PolicySettings_LogScrubbing_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PolicySettings_LogScrubbing_STATUS to PolicySettings_LogScrubbing_STATUS via AssignProperties_To_PolicySettings_LogScrubbing_STATUS & AssignProperties_From_PolicySettings_LogScrubbing_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPolicySettings_LogScrubbing_STATUS, PolicySettings_LogScrubbing_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPolicySettings_LogScrubbing_STATUS tests if a specific instance of PolicySettings_LogScrubbing_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPolicySettings_LogScrubbing_STATUS(subject PolicySettings_LogScrubbing_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PolicySettings_LogScrubbing_STATUS
	err := copied.AssignProperties_To_PolicySettings_LogScrubbing_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PolicySettings_LogScrubbing_STATUS
	err = actual.AssignProperties_From_PolicySettings_LogScrubbing_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PolicySettings_LogScrubbing_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PolicySettings_LogScrubbing_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPolicySettings_LogScrubbing_STATUS, PolicySettings_LogScrubbing_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPolicySettings_LogScrubbing_STATUS runs a test to see if a specific instance of PolicySettings_LogScrubbing_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPolicySettings_LogScrubbing_STATUS(subject PolicySettings_LogScrubbing_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PolicySettings_LogScrubbing_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PolicySettings_LogScrubbing_STATUS instances for property testing - lazily instantiated by
// PolicySettings_LogScrubbing_STATUSGenerator()
var policySettings_LogScrubbing_STATUSGenerator gopter.Gen

// PolicySettings_LogScrubbing_STATUSGenerator returns a generator of PolicySettings_LogScrubbing_STATUS instances for property testing.
// We first initialize policySettings_LogScrubbing_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PolicySettings_LogScrubbing_STATUSGenerator() gopter.Gen {
	if policySettings_LogScrubbing_STATUSGenerator != nil {
		return policySettings_LogScrubbing_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPolicySettings_LogScrubbing_STATUS(generators)
	policySettings_LogScrubbing_STATUSGenerator = gen.Struct(reflect.TypeOf(PolicySettings_LogScrubbing_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPolicySettings_LogScrubbing_STATUS(generators)
	AddRelatedPropertyGeneratorsForPolicySettings_LogScrubbing_STATUS(generators)
	policySettings_LogScrubbing_STATUSGenerator = gen.Struct(reflect.TypeOf(PolicySettings_LogScrubbing_STATUS{}), generators)

	return policySettings_LogScrubbing_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPolicySettings_LogScrubbing_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPolicySettings_LogScrubbing_STATUS(gens map[string]gopter.Gen) {
	gens["State"] = gen.PtrOf(gen.OneConstOf(PolicySettings_LogScrubbing_State_STATUS_Disabled, PolicySettings_LogScrubbing_State_STATUS_Enabled))
}

// AddRelatedPropertyGeneratorsForPolicySettings_LogScrubbing_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPolicySettings_LogScrubbing_STATUS(gens map[string]gopter.Gen) {
	gens["ScrubbingRules"] = gen.SliceOf(WebApplicationFirewallScrubbingRules_STATUSGenerator())
}

func Test_PolicySettings_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PolicySettings_STATUS to PolicySettings_STATUS via AssignProperties_To_PolicySettings_STATUS & AssignProperties_From_PolicySettings_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPolicySettings_STATUS, PolicySettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPolicySettings_STATUS tests if a specific instance of PolicySettings_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPolicySettings_STATUS(subject PolicySettings_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PolicySettings_STATUS
	err := copied.AssignProperties_To_PolicySettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PolicySettings_STATUS
	err = actual.AssignProperties_From_PolicySettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PolicySettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PolicySettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPolicySettings_STATUS, PolicySettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPolicySettings_STATUS runs a test to see if a specific instance of PolicySettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPolicySettings_STATUS(subject PolicySettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PolicySettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PolicySettings_STATUS instances for property testing - lazily instantiated by
// PolicySettings_STATUSGenerator()
var policySettings_STATUSGenerator gopter.Gen

// PolicySettings_STATUSGenerator returns a generator of PolicySettings_STATUS instances for property testing.
// We first initialize policySettings_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PolicySettings_STATUSGenerator() gopter.Gen {
	if policySettings_STATUSGenerator != nil {
		return policySettings_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPolicySettings_STATUS(generators)
	policySettings_STATUSGenerator = gen.Struct(reflect.TypeOf(PolicySettings_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPolicySettings_STATUS(generators)
	AddRelatedPropertyGeneratorsForPolicySettings_STATUS(generators)
	policySettings_STATUSGenerator = gen.Struct(reflect.TypeOf(PolicySettings_STATUS{}), generators)

	return policySettings_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPolicySettings_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPolicySettings_STATUS(gens map[string]gopter.Gen) {
	gens["CustomBlockResponseBody"] = gen.PtrOf(gen.AlphaString())
	gens["CustomBlockResponseStatusCode"] = gen.PtrOf(gen.Int())
	gens["FileUploadEnforcement"] = gen.PtrOf(gen.Bool())
	gens["FileUploadLimitInMb"] = gen.PtrOf(gen.Int())
	gens["JsChallengeCookieExpirationInMins"] = gen.PtrOf(gen.Int())
	gens["MaxRequestBodySizeInKb"] = gen.PtrOf(gen.Int())
	gens["Mode"] = gen.PtrOf(gen.OneConstOf(PolicySettings_Mode_STATUS_Detection, PolicySettings_Mode_STATUS_Prevention))
	gens["RequestBodyCheck"] = gen.PtrOf(gen.Bool())
	gens["RequestBodyEnforcement"] = gen.PtrOf(gen.Bool())
	gens["RequestBodyInspectLimitInKB"] = gen.PtrOf(gen.Int())
	gens["State"] = gen.PtrOf(gen.OneConstOf(PolicySettings_State_STATUS_Disabled, PolicySettings_State_STATUS_Enabled))
}

// AddRelatedPropertyGeneratorsForPolicySettings_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPolicySettings_STATUS(gens map[string]gopter.Gen) {
	gens["LogScrubbing"] = gen.PtrOf(PolicySettings_LogScrubbing_STATUSGenerator())
}

func Test_SubResource_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SubResource_STATUS to SubResource_STATUS via AssignProperties_To_SubResource_STATUS & AssignProperties_From_SubResource_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSubResource_STATUS, SubResource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSubResource_STATUS tests if a specific instance of SubResource_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSubResource_STATUS(subject SubResource_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.SubResource_STATUS
	err := copied.AssignProperties_To_SubResource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SubResource_STATUS
	err = actual.AssignProperties_From_SubResource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SubResource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubResource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubResource_STATUS, SubResource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubResource_STATUS runs a test to see if a specific instance of SubResource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSubResource_STATUS(subject SubResource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubResource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubResource_STATUS instances for property testing - lazily instantiated by SubResource_STATUSGenerator()
var subResource_STATUSGenerator gopter.Gen

// SubResource_STATUSGenerator returns a generator of SubResource_STATUS instances for property testing.
func SubResource_STATUSGenerator() gopter.Gen {
	if subResource_STATUSGenerator != nil {
		return subResource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubResource_STATUS(generators)
	subResource_STATUSGenerator = gen.Struct(reflect.TypeOf(SubResource_STATUS{}), generators)

	return subResource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSubResource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubResource_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_WebApplicationFirewallCustomRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebApplicationFirewallCustomRule to WebApplicationFirewallCustomRule via AssignProperties_To_WebApplicationFirewallCustomRule & AssignProperties_From_WebApplicationFirewallCustomRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebApplicationFirewallCustomRule, WebApplicationFirewallCustomRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebApplicationFirewallCustomRule tests if a specific instance of WebApplicationFirewallCustomRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWebApplicationFirewallCustomRule(subject WebApplicationFirewallCustomRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WebApplicationFirewallCustomRule
	err := copied.AssignProperties_To_WebApplicationFirewallCustomRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WebApplicationFirewallCustomRule
	err = actual.AssignProperties_From_WebApplicationFirewallCustomRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebApplicationFirewallCustomRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebApplicationFirewallCustomRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebApplicationFirewallCustomRule, WebApplicationFirewallCustomRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebApplicationFirewallCustomRule runs a test to see if a specific instance of WebApplicationFirewallCustomRule round trips to JSON and back losslessly
func RunJSONSerializationTestForWebApplicationFirewallCustomRule(subject WebApplicationFirewallCustomRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebApplicationFirewallCustomRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebApplicationFirewallCustomRule instances for property testing - lazily instantiated by
// WebApplicationFirewallCustomRuleGenerator()
var webApplicationFirewallCustomRuleGenerator gopter.Gen

// WebApplicationFirewallCustomRuleGenerator returns a generator of WebApplicationFirewallCustomRule instances for property testing.
// We first initialize webApplicationFirewallCustomRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WebApplicationFirewallCustomRuleGenerator() gopter.Gen {
	if webApplicationFirewallCustomRuleGenerator != nil {
		return webApplicationFirewallCustomRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebApplicationFirewallCustomRule(generators)
	webApplicationFirewallCustomRuleGenerator = gen.Struct(reflect.TypeOf(WebApplicationFirewallCustomRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebApplicationFirewallCustomRule(generators)
	AddRelatedPropertyGeneratorsForWebApplicationFirewallCustomRule(generators)
	webApplicationFirewallCustomRuleGenerator = gen.Struct(reflect.TypeOf(WebApplicationFirewallCustomRule{}), generators)

	return webApplicationFirewallCustomRuleGenerator
}

// AddIndependentPropertyGeneratorsForWebApplicationFirewallCustomRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebApplicationFirewallCustomRule(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(
		WebApplicationFirewallCustomRule_Action_Allow,
		WebApplicationFirewallCustomRule_Action_Block,
		WebApplicationFirewallCustomRule_Action_JSChallenge,
		WebApplicationFirewallCustomRule_Action_Log))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["RateLimitDuration"] = gen.PtrOf(gen.OneConstOf(WebApplicationFirewallCustomRule_RateLimitDuration_FiveMins, WebApplicationFirewallCustomRule_RateLimitDuration_OneMin))
	gens["RateLimitThreshold"] = gen.PtrOf(gen.Int())
	gens["RuleType"] = gen.PtrOf(gen.OneConstOf(WebApplicationFirewallCustomRule_RuleType_Invalid, WebApplicationFirewallCustomRule_RuleType_MatchRule, WebApplicationFirewallCustomRule_RuleType_RateLimitRule))
	gens["State"] = gen.PtrOf(gen.OneConstOf(WebApplicationFirewallCustomRule_State_Disabled, WebApplicationFirewallCustomRule_State_Enabled))
}

// AddRelatedPropertyGeneratorsForWebApplicationFirewallCustomRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebApplicationFirewallCustomRule(gens map[string]gopter.Gen) {
	gens["GroupByUserSession"] = gen.SliceOf(GroupByUserSessionGenerator())
	gens["MatchConditions"] = gen.SliceOf(MatchConditionGenerator())
}

func Test_WebApplicationFirewallCustomRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebApplicationFirewallCustomRule_STATUS to WebApplicationFirewallCustomRule_STATUS via AssignProperties_To_WebApplicationFirewallCustomRule_STATUS & AssignProperties_From_WebApplicationFirewallCustomRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebApplicationFirewallCustomRule_STATUS, WebApplicationFirewallCustomRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebApplicationFirewallCustomRule_STATUS tests if a specific instance of WebApplicationFirewallCustomRule_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWebApplicationFirewallCustomRule_STATUS(subject WebApplicationFirewallCustomRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WebApplicationFirewallCustomRule_STATUS
	err := copied.AssignProperties_To_WebApplicationFirewallCustomRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WebApplicationFirewallCustomRule_STATUS
	err = actual.AssignProperties_From_WebApplicationFirewallCustomRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebApplicationFirewallCustomRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebApplicationFirewallCustomRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebApplicationFirewallCustomRule_STATUS, WebApplicationFirewallCustomRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebApplicationFirewallCustomRule_STATUS runs a test to see if a specific instance of WebApplicationFirewallCustomRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWebApplicationFirewallCustomRule_STATUS(subject WebApplicationFirewallCustomRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebApplicationFirewallCustomRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebApplicationFirewallCustomRule_STATUS instances for property testing - lazily instantiated by
// WebApplicationFirewallCustomRule_STATUSGenerator()
var webApplicationFirewallCustomRule_STATUSGenerator gopter.Gen

// WebApplicationFirewallCustomRule_STATUSGenerator returns a generator of WebApplicationFirewallCustomRule_STATUS instances for property testing.
// We first initialize webApplicationFirewallCustomRule_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WebApplicationFirewallCustomRule_STATUSGenerator() gopter.Gen {
	if webApplicationFirewallCustomRule_STATUSGenerator != nil {
		return webApplicationFirewallCustomRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebApplicationFirewallCustomRule_STATUS(generators)
	webApplicationFirewallCustomRule_STATUSGenerator = gen.Struct(reflect.TypeOf(WebApplicationFirewallCustomRule_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebApplicationFirewallCustomRule_STATUS(generators)
	AddRelatedPropertyGeneratorsForWebApplicationFirewallCustomRule_STATUS(generators)
	webApplicationFirewallCustomRule_STATUSGenerator = gen.Struct(reflect.TypeOf(WebApplicationFirewallCustomRule_STATUS{}), generators)

	return webApplicationFirewallCustomRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForWebApplicationFirewallCustomRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebApplicationFirewallCustomRule_STATUS(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(
		WebApplicationFirewallCustomRule_Action_STATUS_Allow,
		WebApplicationFirewallCustomRule_Action_STATUS_Block,
		WebApplicationFirewallCustomRule_Action_STATUS_JSChallenge,
		WebApplicationFirewallCustomRule_Action_STATUS_Log))
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["RateLimitDuration"] = gen.PtrOf(gen.OneConstOf(WebApplicationFirewallCustomRule_RateLimitDuration_STATUS_FiveMins, WebApplicationFirewallCustomRule_RateLimitDuration_STATUS_OneMin))
	gens["RateLimitThreshold"] = gen.PtrOf(gen.Int())
	gens["RuleType"] = gen.PtrOf(gen.OneConstOf(WebApplicationFirewallCustomRule_RuleType_STATUS_Invalid, WebApplicationFirewallCustomRule_RuleType_STATUS_MatchRule, WebApplicationFirewallCustomRule_RuleType_STATUS_RateLimitRule))
	gens["State"] = gen.PtrOf(gen.OneConstOf(WebApplicationFirewallCustomRule_State_STATUS_Disabled, WebApplicationFirewallCustomRule_State_STATUS_Enabled))
}

// AddRelatedPropertyGeneratorsForWebApplicationFirewallCustomRule_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebApplicationFirewallCustomRule_STATUS(gens map[string]gopter.Gen) {
	gens["GroupByUserSession"] = gen.SliceOf(GroupByUserSession_STATUSGenerator())
	gens["MatchConditions"] = gen.SliceOf(MatchCondition_STATUSGenerator())
}

func Test_WebApplicationFirewallPolicy_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebApplicationFirewallPolicy to hub returns original",
		prop.ForAll(RunResourceConversionTestForWebApplicationFirewallPolicy, WebApplicationFirewallPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForWebApplicationFirewallPolicy tests if a specific instance of WebApplicationFirewallPolicy round trips to the hub storage version and back losslessly
func RunResourceConversionTestForWebApplicationFirewallPolicy(subject WebApplicationFirewallPolicy) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub storage.WebApplicationFirewallPolicy
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual WebApplicationFirewallPolicy
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebApplicationFirewallPolicy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebApplicationFirewallPolicy to WebApplicationFirewallPolicy via AssignProperties_To_WebApplicationFirewallPolicy & AssignProperties_From_WebApplicationFirewallPolicy returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebApplicationFirewallPolicy, WebApplicationFirewallPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebApplicationFirewallPolicy tests if a specific instance of WebApplicationFirewallPolicy can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWebApplicationFirewallPolicy(subject WebApplicationFirewallPolicy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WebApplicationFirewallPolicy
	err := copied.AssignProperties_To_WebApplicationFirewallPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WebApplicationFirewallPolicy
	err = actual.AssignProperties_From_WebApplicationFirewallPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebApplicationFirewallPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebApplicationFirewallPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebApplicationFirewallPolicy, WebApplicationFirewallPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebApplicationFirewallPolicy runs a test to see if a specific instance of WebApplicationFirewallPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForWebApplicationFirewallPolicy(subject WebApplicationFirewallPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebApplicationFirewallPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebApplicationFirewallPolicy instances for property testing - lazily instantiated by
// WebApplicationFirewallPolicyGenerator()
var webApplicationFirewallPolicyGenerator gopter.Gen

// WebApplicationFirewallPolicyGenerator returns a generator of WebApplicationFirewallPolicy instances for property testing.
func WebApplicationFirewallPolicyGenerator() gopter.Gen {
	if webApplicationFirewallPolicyGenerator != nil {
		return webApplicationFirewallPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWebApplicationFirewallPolicy(generators)
	webApplicationFirewallPolicyGenerator = gen.Struct(reflect.TypeOf(WebApplicationFirewallPolicy{}), generators)

	return webApplicationFirewallPolicyGenerator
}

// AddRelatedPropertyGeneratorsForWebApplicationFirewallPolicy is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebApplicationFirewallPolicy(gens map[string]gopter.Gen) {
	gens["Spec"] = WebApplicationFirewallPolicy_SpecGenerator()
	gens["Status"] = WebApplicationFirewallPolicy_STATUSGenerator()
}

func Test_WebApplicationFirewallPolicyOperatorSpec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebApplicationFirewallPolicyOperatorSpec to WebApplicationFirewallPolicyOperatorSpec via AssignProperties_To_WebApplicationFirewallPolicyOperatorSpec & AssignProperties_From_WebApplicationFirewallPolicyOperatorSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebApplicationFirewallPolicyOperatorSpec, WebApplicationFirewallPolicyOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebApplicationFirewallPolicyOperatorSpec tests if a specific instance of WebApplicationFirewallPolicyOperatorSpec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWebApplicationFirewallPolicyOperatorSpec(subject WebApplicationFirewallPolicyOperatorSpec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WebApplicationFirewallPolicyOperatorSpec
	err := copied.AssignProperties_To_WebApplicationFirewallPolicyOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WebApplicationFirewallPolicyOperatorSpec
	err = actual.AssignProperties_From_WebApplicationFirewallPolicyOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebApplicationFirewallPolicyOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebApplicationFirewallPolicyOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebApplicationFirewallPolicyOperatorSpec, WebApplicationFirewallPolicyOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebApplicationFirewallPolicyOperatorSpec runs a test to see if a specific instance of WebApplicationFirewallPolicyOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForWebApplicationFirewallPolicyOperatorSpec(subject WebApplicationFirewallPolicyOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebApplicationFirewallPolicyOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebApplicationFirewallPolicyOperatorSpec instances for property testing - lazily instantiated by
// WebApplicationFirewallPolicyOperatorSpecGenerator()
var webApplicationFirewallPolicyOperatorSpecGenerator gopter.Gen

// WebApplicationFirewallPolicyOperatorSpecGenerator returns a generator of WebApplicationFirewallPolicyOperatorSpec instances for property testing.
func WebApplicationFirewallPolicyOperatorSpecGenerator() gopter.Gen {
	if webApplicationFirewallPolicyOperatorSpecGenerator != nil {
		return webApplicationFirewallPolicyOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	webApplicationFirewallPolicyOperatorSpecGenerator = gen.Struct(reflect.TypeOf(WebApplicationFirewallPolicyOperatorSpec{}), generators)

	return webApplicationFirewallPolicyOperatorSpecGenerator
}

func Test_WebApplicationFirewallPolicy_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebApplicationFirewallPolicy_STATUS to WebApplicationFirewallPolicy_STATUS via AssignProperties_To_WebApplicationFirewallPolicy_STATUS & AssignProperties_From_WebApplicationFirewallPolicy_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebApplicationFirewallPolicy_STATUS, WebApplicationFirewallPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebApplicationFirewallPolicy_STATUS tests if a specific instance of WebApplicationFirewallPolicy_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWebApplicationFirewallPolicy_STATUS(subject WebApplicationFirewallPolicy_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WebApplicationFirewallPolicy_STATUS
	err := copied.AssignProperties_To_WebApplicationFirewallPolicy_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WebApplicationFirewallPolicy_STATUS
	err = actual.AssignProperties_From_WebApplicationFirewallPolicy_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebApplicationFirewallPolicy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebApplicationFirewallPolicy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebApplicationFirewallPolicy_STATUS, WebApplicationFirewallPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebApplicationFirewallPolicy_STATUS runs a test to see if a specific instance of WebApplicationFirewallPolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWebApplicationFirewallPolicy_STATUS(subject WebApplicationFirewallPolicy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebApplicationFirewallPolicy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebApplicationFirewallPolicy_STATUS instances for property testing - lazily instantiated by
// WebApplicationFirewallPolicy_STATUSGenerator()
var webApplicationFirewallPolicy_STATUSGenerator gopter.Gen

// WebApplicationFirewallPolicy_STATUSGenerator returns a generator of WebApplicationFirewallPolicy_STATUS instances for property testing.
// We first initialize webApplicationFirewallPolicy_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WebApplicationFirewallPolicy_STATUSGenerator() gopter.Gen {
	if webApplicationFirewallPolicy_STATUSGenerator != nil {
		return webApplicationFirewallPolicy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebApplicationFirewallPolicy_STATUS(generators)
	webApplicationFirewallPolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(WebApplicationFirewallPolicy_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebApplicationFirewallPolicy_STATUS(generators)
	AddRelatedPropertyGeneratorsForWebApplicationFirewallPolicy_STATUS(generators)
	webApplicationFirewallPolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(WebApplicationFirewallPolicy_STATUS{}), generators)

	return webApplicationFirewallPolicy_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForWebApplicationFirewallPolicy_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebApplicationFirewallPolicy_STATUS(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Updating))
	gens["ResourceState"] = gen.PtrOf(gen.OneConstOf(
		WebApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS_Creating,
		WebApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS_Deleting,
		WebApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS_Disabled,
		WebApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS_Disabling,
		WebApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS_Enabled,
		WebApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS_Enabling))
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWebApplicationFirewallPolicy_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebApplicationFirewallPolicy_STATUS(gens map[string]gopter.Gen) {
	gens["ApplicationGateways"] = gen.SliceOf(ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbeddedGenerator())
	gens["CustomRules"] = gen.SliceOf(WebApplicationFirewallCustomRule_STATUSGenerator())
	gens["HttpListeners"] = gen.SliceOf(SubResource_STATUSGenerator())
	gens["ManagedRules"] = gen.PtrOf(ManagedRulesDefinition_STATUSGenerator())
	gens["PathBasedRules"] = gen.SliceOf(SubResource_STATUSGenerator())
	gens["PolicySettings"] = gen.PtrOf(PolicySettings_STATUSGenerator())
}

func Test_WebApplicationFirewallPolicy_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebApplicationFirewallPolicy_Spec to WebApplicationFirewallPolicy_Spec via AssignProperties_To_WebApplicationFirewallPolicy_Spec & AssignProperties_From_WebApplicationFirewallPolicy_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebApplicationFirewallPolicy_Spec, WebApplicationFirewallPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebApplicationFirewallPolicy_Spec tests if a specific instance of WebApplicationFirewallPolicy_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWebApplicationFirewallPolicy_Spec(subject WebApplicationFirewallPolicy_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WebApplicationFirewallPolicy_Spec
	err := copied.AssignProperties_To_WebApplicationFirewallPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WebApplicationFirewallPolicy_Spec
	err = actual.AssignProperties_From_WebApplicationFirewallPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebApplicationFirewallPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebApplicationFirewallPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebApplicationFirewallPolicy_Spec, WebApplicationFirewallPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebApplicationFirewallPolicy_Spec runs a test to see if a specific instance of WebApplicationFirewallPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForWebApplicationFirewallPolicy_Spec(subject WebApplicationFirewallPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebApplicationFirewallPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebApplicationFirewallPolicy_Spec instances for property testing - lazily instantiated by
// WebApplicationFirewallPolicy_SpecGenerator()
var webApplicationFirewallPolicy_SpecGenerator gopter.Gen

// WebApplicationFirewallPolicy_SpecGenerator returns a generator of WebApplicationFirewallPolicy_Spec instances for property testing.
// We first initialize webApplicationFirewallPolicy_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WebApplicationFirewallPolicy_SpecGenerator() gopter.Gen {
	if webApplicationFirewallPolicy_SpecGenerator != nil {
		return webApplicationFirewallPolicy_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebApplicationFirewallPolicy_Spec(generators)
	webApplicationFirewallPolicy_SpecGenerator = gen.Struct(reflect.TypeOf(WebApplicationFirewallPolicy_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebApplicationFirewallPolicy_Spec(generators)
	AddRelatedPropertyGeneratorsForWebApplicationFirewallPolicy_Spec(generators)
	webApplicationFirewallPolicy_SpecGenerator = gen.Struct(reflect.TypeOf(WebApplicationFirewallPolicy_Spec{}), generators)

	return webApplicationFirewallPolicy_SpecGenerator
}

// AddIndependentPropertyGeneratorsForWebApplicationFirewallPolicy_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebApplicationFirewallPolicy_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWebApplicationFirewallPolicy_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebApplicationFirewallPolicy_Spec(gens map[string]gopter.Gen) {
	gens["CustomRules"] = gen.SliceOf(WebApplicationFirewallCustomRuleGenerator())
	gens["ManagedRules"] = gen.PtrOf(ManagedRulesDefinitionGenerator())
	gens["OperatorSpec"] = gen.PtrOf(WebApplicationFirewallPolicyOperatorSpecGenerator())
	gens["PolicySettings"] = gen.PtrOf(PolicySettingsGenerator())
}

func Test_WebApplicationFirewallScrubbingRules_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebApplicationFirewallScrubbingRules to WebApplicationFirewallScrubbingRules via AssignProperties_To_WebApplicationFirewallScrubbingRules & AssignProperties_From_WebApplicationFirewallScrubbingRules returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebApplicationFirewallScrubbingRules, WebApplicationFirewallScrubbingRulesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebApplicationFirewallScrubbingRules tests if a specific instance of WebApplicationFirewallScrubbingRules can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWebApplicationFirewallScrubbingRules(subject WebApplicationFirewallScrubbingRules) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WebApplicationFirewallScrubbingRules
	err := copied.AssignProperties_To_WebApplicationFirewallScrubbingRules(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WebApplicationFirewallScrubbingRules
	err = actual.AssignProperties_From_WebApplicationFirewallScrubbingRules(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebApplicationFirewallScrubbingRules_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebApplicationFirewallScrubbingRules via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebApplicationFirewallScrubbingRules, WebApplicationFirewallScrubbingRulesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebApplicationFirewallScrubbingRules runs a test to see if a specific instance of WebApplicationFirewallScrubbingRules round trips to JSON and back losslessly
func RunJSONSerializationTestForWebApplicationFirewallScrubbingRules(subject WebApplicationFirewallScrubbingRules) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebApplicationFirewallScrubbingRules
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebApplicationFirewallScrubbingRules instances for property testing - lazily instantiated by
// WebApplicationFirewallScrubbingRulesGenerator()
var webApplicationFirewallScrubbingRulesGenerator gopter.Gen

// WebApplicationFirewallScrubbingRulesGenerator returns a generator of WebApplicationFirewallScrubbingRules instances for property testing.
func WebApplicationFirewallScrubbingRulesGenerator() gopter.Gen {
	if webApplicationFirewallScrubbingRulesGenerator != nil {
		return webApplicationFirewallScrubbingRulesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebApplicationFirewallScrubbingRules(generators)
	webApplicationFirewallScrubbingRulesGenerator = gen.Struct(reflect.TypeOf(WebApplicationFirewallScrubbingRules{}), generators)

	return webApplicationFirewallScrubbingRulesGenerator
}

// AddIndependentPropertyGeneratorsForWebApplicationFirewallScrubbingRules is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebApplicationFirewallScrubbingRules(gens map[string]gopter.Gen) {
	gens["MatchVariable"] = gen.PtrOf(gen.OneConstOf(
		WebApplicationFirewallScrubbingRules_MatchVariable_RequestArgNames,
		WebApplicationFirewallScrubbingRules_MatchVariable_RequestCookieNames,
		WebApplicationFirewallScrubbingRules_MatchVariable_RequestHeaderNames,
		WebApplicationFirewallScrubbingRules_MatchVariable_RequestIPAddress,
		WebApplicationFirewallScrubbingRules_MatchVariable_RequestJSONArgNames,
		WebApplicationFirewallScrubbingRules_MatchVariable_RequestPostArgNames))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["SelectorMatchOperator"] = gen.PtrOf(gen.OneConstOf(WebApplicationFirewallScrubbingRules_SelectorMatchOperator_Equals, WebApplicationFirewallScrubbingRules_SelectorMatchOperator_EqualsAny))
	gens["State"] = gen.PtrOf(gen.OneConstOf(WebApplicationFirewallScrubbingRules_State_Disabled, WebApplicationFirewallScrubbingRules_State_Enabled))
}

func Test_WebApplicationFirewallScrubbingRules_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebApplicationFirewallScrubbingRules_STATUS to WebApplicationFirewallScrubbingRules_STATUS via AssignProperties_To_WebApplicationFirewallScrubbingRules_STATUS & AssignProperties_From_WebApplicationFirewallScrubbingRules_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebApplicationFirewallScrubbingRules_STATUS, WebApplicationFirewallScrubbingRules_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebApplicationFirewallScrubbingRules_STATUS tests if a specific instance of WebApplicationFirewallScrubbingRules_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWebApplicationFirewallScrubbingRules_STATUS(subject WebApplicationFirewallScrubbingRules_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WebApplicationFirewallScrubbingRules_STATUS
	err := copied.AssignProperties_To_WebApplicationFirewallScrubbingRules_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WebApplicationFirewallScrubbingRules_STATUS
	err = actual.AssignProperties_From_WebApplicationFirewallScrubbingRules_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebApplicationFirewallScrubbingRules_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebApplicationFirewallScrubbingRules_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebApplicationFirewallScrubbingRules_STATUS, WebApplicationFirewallScrubbingRules_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebApplicationFirewallScrubbingRules_STATUS runs a test to see if a specific instance of WebApplicationFirewallScrubbingRules_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWebApplicationFirewallScrubbingRules_STATUS(subject WebApplicationFirewallScrubbingRules_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebApplicationFirewallScrubbingRules_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebApplicationFirewallScrubbingRules_STATUS instances for property testing - lazily instantiated by
// WebApplicationFirewallScrubbingRules_STATUSGenerator()
var webApplicationFirewallScrubbingRules_STATUSGenerator gopter.Gen

// WebApplicationFirewallScrubbingRules_STATUSGenerator returns a generator of WebApplicationFirewallScrubbingRules_STATUS instances for property testing.
func WebApplicationFirewallScrubbingRules_STATUSGenerator() gopter.Gen {
	if webApplicationFirewallScrubbingRules_STATUSGenerator != nil {
		return webApplicationFirewallScrubbingRules_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebApplicationFirewallScrubbingRules_STATUS(generators)
	webApplicationFirewallScrubbingRules_STATUSGenerator = gen.Struct(reflect.TypeOf(WebApplicationFirewallScrubbingRules_STATUS{}), generators)

	return webApplicationFirewallScrubbingRules_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForWebApplicationFirewallScrubbingRules_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebApplicationFirewallScrubbingRules_STATUS(gens map[string]gopter.Gen) {
	gens["MatchVariable"] = gen.PtrOf(gen.OneConstOf(
		WebApplicationFirewallScrubbingRules_MatchVariable_STATUS_RequestArgNames,
		WebApplicationFirewallScrubbingRules_MatchVariable_STATUS_RequestCookieNames,
		WebApplicationFirewallScrubbingRules_MatchVariable_STATUS_RequestHeaderNames,
		WebApplicationFirewallScrubbingRules_MatchVariable_STATUS_RequestIPAddress,
		WebApplicationFirewallScrubbingRules_MatchVariable_STATUS_RequestJSONArgNames,
		WebApplicationFirewallScrubbingRules_MatchVariable_STATUS_RequestPostArgNames))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["SelectorMatchOperator"] = gen.PtrOf(gen.OneConstOf(WebApplicationFirewallScrubbingRules_SelectorMatchOperator_STATUS_Equals, WebApplicationFirewallScrubbingRules_SelectorMatchOperator_STATUS_EqualsAny))
	gens["State"] = gen.PtrOf(gen.OneConstOf(WebApplicationFirewallScrubbingRules_State_STATUS_Disabled, WebApplicationFirewallScrubbingRules_State_STATUS_Enabled))
}
